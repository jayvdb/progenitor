pub mod operations {
    #![doc = r" [`When`](httpmock::When) and [`Then`](httpmock::Then)"]
    #![doc = r" wrappers for each operation. Each can be converted to"]
    #![doc = r" its inner type with a call to `into_inner()`. This can"]
    #![doc = r" be used to explicitly deviate from permitted values."]
    use sdk::*;
    pub struct MetaRootWhen(httpmock::When);
    impl MetaRootWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct MetaRootThen(httpmock::Then);
    impl MetaRootThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Root) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetAuthenticatedWhen(httpmock::When);
    impl AppsGetAuthenticatedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct AppsGetAuthenticatedThen(httpmock::Then);
    impl AppsGetAuthenticatedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Integration) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsCreateFromManifestWhen(httpmock::When);
    impl AppsCreateFromManifestWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/app-manifests/.*/conversions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn code(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/app-manifests/{}/conversions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsCreateFromManifestThen(httpmock::Then);
    impl AppsCreateFromManifestThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Integration) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetWebhookConfigForAppWhen(httpmock::When);
    impl AppsGetWebhookConfigForAppWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/hook/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct AppsGetWebhookConfigForAppThen(httpmock::Then);
    impl AppsGetWebhookConfigForAppThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsUpdateWebhookConfigForAppWhen(httpmock::When);
    impl AppsUpdateWebhookConfigForAppWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/app/hook/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::AppsUpdateWebhookConfigForAppBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsUpdateWebhookConfigForAppThen(httpmock::Then);
    impl AppsUpdateWebhookConfigForAppThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListWebhookDeliveriesWhen(httpmock::When);
    impl AppsListWebhookDeliveriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/hook/deliveries$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn cursor(self, value: &str) -> Self {
            Self(self.0.query_param("cursor", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn redelivery(self, value: bool) -> Self {
            Self(self.0.query_param("redelivery", value.to_string()))
        }
    }

    pub struct AppsListWebhookDeliveriesThen(httpmock::Then);
    impl AppsListWebhookDeliveriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::HookDeliveryItem>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetWebhookDeliveryWhen(httpmock::When);
    impl AppsGetWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/hook/deliveries/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/app/hook/deliveries/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetWebhookDeliveryThen(httpmock::Then);
    impl AppsGetWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::HookDelivery) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsRedeliverWebhookDeliveryWhen(httpmock::When);
    impl AppsRedeliverWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/app/hook/deliveries/.*/attempts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/app/hook/deliveries/{}/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsRedeliverWebhookDeliveryThen(httpmock::Then);
    impl AppsRedeliverWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListInstallationRequestsForAuthenticatedAppWhen(httpmock::When);
    impl AppsListInstallationRequestsForAuthenticatedAppWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/installation-requests$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListInstallationRequestsForAuthenticatedAppThen(httpmock::Then);
    impl AppsListInstallationRequestsForAuthenticatedAppThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::IntegrationInstallationRequest>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListInstallationsWhen(httpmock::When);
    impl AppsListInstallationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/installations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn outdated(self, value: &str) -> Self {
            Self(self.0.query_param("outdated", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct AppsListInstallationsThen(httpmock::Then);
    impl AppsListInstallationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Installation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetInstallationWhen(httpmock::When);
    impl AppsGetInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/app/installations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/app/installations/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetInstallationThen(httpmock::Then);
    impl AppsGetInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Installation) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsDeleteInstallationWhen(httpmock::When);
    impl AppsDeleteInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/app/installations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/app/installations/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsDeleteInstallationThen(httpmock::Then);
    impl AppsDeleteInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsCreateInstallationAccessTokenWhen(httpmock::When);
    impl AppsCreateInstallationAccessTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/app/installations/.*/access_tokens$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/app/installations/{}/access_tokens$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsCreateInstallationAccessTokenBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsCreateInstallationAccessTokenThen(httpmock::Then);
    impl AppsCreateInstallationAccessTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::InstallationToken) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsSuspendInstallationWhen(httpmock::When);
    impl AppsSuspendInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/app/installations/.*/suspended$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/app/installations/{}/suspended$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsSuspendInstallationThen(httpmock::Then);
    impl AppsSuspendInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsUnsuspendInstallationWhen(httpmock::When);
    impl AppsUnsuspendInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/app/installations/.*/suspended$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/app/installations/{}/suspended$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsUnsuspendInstallationThen(httpmock::Then);
    impl AppsUnsuspendInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsDeleteAuthorizationWhen(httpmock::When);
    impl AppsDeleteAuthorizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/applications/.*/grant$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn client_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/applications/{}/grant$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsDeleteAuthorizationBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsDeleteAuthorizationThen(httpmock::Then);
    impl AppsDeleteAuthorizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsCheckTokenWhen(httpmock::When);
    impl AppsCheckTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/applications/.*/token$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn client_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/applications/{}/token$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsCheckTokenBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsCheckTokenThen(httpmock::Then);
    impl AppsCheckTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Authorization) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsDeleteTokenWhen(httpmock::When);
    impl AppsDeleteTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/applications/.*/token$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn client_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/applications/{}/token$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsDeleteTokenBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsDeleteTokenThen(httpmock::Then);
    impl AppsDeleteTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsResetTokenWhen(httpmock::When);
    impl AppsResetTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/applications/.*/token$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn client_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/applications/{}/token$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsResetTokenBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsResetTokenThen(httpmock::Then);
    impl AppsResetTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Authorization) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsScopeTokenWhen(httpmock::When);
    impl AppsScopeTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/applications/.*/token/scoped$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn client_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/applications/{}/token/scoped$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::AppsScopeTokenBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct AppsScopeTokenThen(httpmock::Then);
    impl AppsScopeTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Authorization) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetBySlugWhen(httpmock::When);
    impl AppsGetBySlugWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/apps/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn app_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/apps/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetBySlugThen(httpmock::Then);
    impl AppsGetBySlugThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Integration) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodesOfConductGetAllCodesOfConductWhen(httpmock::When);
    impl CodesOfConductGetAllCodesOfConductWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/codes_of_conduct$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct CodesOfConductGetAllCodesOfConductThen(httpmock::Then);
    impl CodesOfConductGetAllCodesOfConductThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeOfConduct>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct CodesOfConductGetConductCodeWhen(httpmock::When);
    impl CodesOfConductGetConductCodeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/codes_of_conduct/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn key(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/codes_of_conduct/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodesOfConductGetConductCodeThen(httpmock::Then);
    impl CodesOfConductGetConductCodeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeOfConduct) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct EmojisGetWhen(httpmock::When);
    impl EmojisGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/emojis$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct EmojisGetThen(httpmock::Then);
    impl EmojisGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &std::collections::HashMap<String, String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct DependabotListAlertsForEnterpriseWhen(httpmock::When);
    impl DependabotListAlertsForEnterpriseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/enterprises/.*/dependabot/alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn enterprise(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/enterprises/{}/dependabot/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::DependabotListAlertsForEnterpriseDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn ecosystem(self, value: &str) -> Self {
            Self(self.0.query_param("ecosystem", value.to_string()))
        }

        pub fn first(self, value: i64) -> Self {
            Self(self.0.query_param("first", value.to_string()))
        }

        pub fn last(self, value: i64) -> Self {
            Self(self.0.query_param("last", value.to_string()))
        }

        pub fn package(self, value: &str) -> Self {
            Self(self.0.query_param("package", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn scope(self, value: types::DependabotListAlertsForEnterpriseScope) -> Self {
            Self(self.0.query_param("scope", value.to_string()))
        }

        pub fn severity(self, value: &str) -> Self {
            Self(self.0.query_param("severity", value.to_string()))
        }

        pub fn sort(self, value: types::DependabotListAlertsForEnterpriseSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: &str) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct DependabotListAlertsForEnterpriseThen(httpmock::Then);
    impl DependabotListAlertsForEnterpriseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DependabotAlertWithRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningListAlertsForEnterpriseWhen(httpmock::When);
    impl SecretScanningListAlertsForEnterpriseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/enterprises/.*/secret-scanning/alerts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn enterprise(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/enterprises/{}/secret-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(
            self,
            value: types::SecretScanningListAlertsForEnterpriseDirection,
        ) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn resolution(self, value: &str) -> Self {
            Self(self.0.query_param("resolution", value.to_string()))
        }

        pub fn secret_type(self, value: &str) -> Self {
            Self(self.0.query_param("secret_type", value.to_string()))
        }

        pub fn sort(self, value: types::SecretScanningListAlertsForEnterpriseSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::SecretScanningListAlertsForEnterpriseState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct SecretScanningListAlertsForEnterpriseThen(httpmock::Then);
    impl SecretScanningListAlertsForEnterpriseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationSecretScanningAlert>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::SecretScanningListAlertsForEnterpriseResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListPublicEventsWhen(httpmock::When);
    impl ActivityListPublicEventsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListPublicEventsThen(httpmock::Then);
    impl ActivityListPublicEventsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::ActivityListPublicEventsResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityGetFeedsWhen(httpmock::When);
    impl ActivityGetFeedsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/feeds$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct ActivityGetFeedsThen(httpmock::Then);
    impl ActivityGetFeedsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Feed) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListWhen(httpmock::When);
    impl GistsListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct GistsListThen(httpmock::Then);
    impl GistsListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::BaseGist>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsCreateWhen(httpmock::When);
    impl GistsCreateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/gists$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::GistsCreateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GistsCreateThen(httpmock::Then);
    impl GistsCreateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GistSimple) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListPublicWhen(httpmock::When);
    impl GistsListPublicWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/public$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct GistsListPublicThen(httpmock::Then);
    impl GistsListPublicThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::BaseGist>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListStarredWhen(httpmock::When);
    impl GistsListStarredWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/starred$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct GistsListStarredThen(httpmock::Then);
    impl GistsListStarredThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::BaseGist>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsGetWhen(httpmock::When);
    impl GistsGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsGetThen(httpmock::Then);
    impl GistsGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GistSimple) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::GistsGetResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct GistsDeleteWhen(httpmock::When);
    impl GistsDeleteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/gists/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsDeleteThen(httpmock::Then);
    impl GistsDeleteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsUpdateWhen(httpmock::When);
    impl GistsUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/gists/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GistsUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GistsUpdateThen(httpmock::Then);
    impl GistsUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GistSimple) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListCommentsWhen(httpmock::When);
    impl GistsListCommentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/{}/comments$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct GistsListCommentsThen(httpmock::Then);
    impl GistsListCommentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GistComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsCreateCommentWhen(httpmock::When);
    impl GistsCreateCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/gists/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/{}/comments$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GistsCreateCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GistsCreateCommentThen(httpmock::Then);
    impl GistsCreateCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GistComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsGetCommentWhen(httpmock::When);
    impl GistsGetCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/{}/comments/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/.*/comments/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsGetCommentThen(httpmock::Then);
    impl GistsGetCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GistComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::GistsGetCommentResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsDeleteCommentWhen(httpmock::When);
    impl GistsDeleteCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/gists/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/{}/comments/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/.*/comments/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsDeleteCommentThen(httpmock::Then);
    impl GistsDeleteCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsUpdateCommentWhen(httpmock::When);
    impl GistsUpdateCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/gists/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/{}/comments/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/gists/.*/comments/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GistsUpdateCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GistsUpdateCommentThen(httpmock::Then);
    impl GistsUpdateCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GistComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListCommitsWhen(httpmock::When);
    impl GistsListCommitsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/commits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/commits$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct GistsListCommitsThen(httpmock::Then);
    impl GistsListCommitsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GistCommit>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsListForksWhen(httpmock::When);
    impl GistsListForksWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/forks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct GistsListForksThen(httpmock::Then);
    impl GistsListForksThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GistSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsForkWhen(httpmock::When);
    impl GistsForkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/gists/.*/forks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsForkThen(httpmock::Then);
    impl GistsForkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::BaseGist) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsCheckIsStarredWhen(httpmock::When);
    impl GistsCheckIsStarredWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/star$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/star$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsCheckIsStarredThen(httpmock::Then);
    impl GistsCheckIsStarredThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::GistsCheckIsStarredResponse) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsStarWhen(httpmock::When);
    impl GistsStarWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/gists/.*/star$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/star$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsStarThen(httpmock::Then);
    impl GistsStarThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsUnstarWhen(httpmock::When);
    impl GistsUnstarWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/gists/.*/star$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/star$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsUnstarThen(httpmock::Then);
    impl GistsUnstarThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GistsGetRevisionWhen(httpmock::When);
    impl GistsGetRevisionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gists/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gist_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gists/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GistsGetRevisionThen(httpmock::Then);
    impl GistsGetRevisionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GistSimple) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitignoreGetAllTemplatesWhen(httpmock::When);
    impl GitignoreGetAllTemplatesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gitignore/templates$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct GitignoreGetAllTemplatesThen(httpmock::Then);
    impl GitignoreGetAllTemplatesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct GitignoreGetTemplateWhen(httpmock::When);
    impl GitignoreGetTemplateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/gitignore/templates/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/gitignore/templates/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitignoreGetTemplateThen(httpmock::Then);
    impl GitignoreGetTemplateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitignoreTemplate) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct AppsListReposAccessibleToInstallationWhen(httpmock::When);
    impl AppsListReposAccessibleToInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/installation/repositories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListReposAccessibleToInstallationThen(httpmock::Then);
    impl AppsListReposAccessibleToInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::AppsListReposAccessibleToInstallationResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsRevokeInstallationAccessTokenWhen(httpmock::When);
    impl AppsRevokeInstallationAccessTokenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/installation/token$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct AppsRevokeInstallationAccessTokenThen(httpmock::Then);
    impl AppsRevokeInstallationAccessTokenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesListWhen(httpmock::When);
    impl IssuesListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn collab(self, value: bool) -> Self {
            Self(self.0.query_param("collab", value.to_string()))
        }

        pub fn direction(self, value: types::IssuesListDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn filter(self, value: types::IssuesListFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn labels(self, value: &str) -> Self {
            Self(self.0.query_param("labels", value.to_string()))
        }

        pub fn orgs(self, value: bool) -> Self {
            Self(self.0.query_param("orgs", value.to_string()))
        }

        pub fn owned(self, value: bool) -> Self {
            Self(self.0.query_param("owned", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn pulls(self, value: bool) -> Self {
            Self(self.0.query_param("pulls", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::IssuesListState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct IssuesListThen(httpmock::Then);
    impl IssuesListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Issue>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct LicensesGetAllCommonlyUsedWhen(httpmock::When);
    impl LicensesGetAllCommonlyUsedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/licenses$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn featured(self, value: bool) -> Self {
            Self(self.0.query_param("featured", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct LicensesGetAllCommonlyUsedThen(httpmock::Then);
    impl LicensesGetAllCommonlyUsedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::LicenseSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct LicensesGetWhen(httpmock::When);
    impl LicensesGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/licenses/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn license(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/licenses/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct LicensesGetThen(httpmock::Then);
    impl LicensesGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::License) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct MarkdownRenderWhen(httpmock::When);
    impl MarkdownRenderWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/markdown$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::MarkdownRenderBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MarkdownRenderThen(httpmock::Then);
    impl MarkdownRenderThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: serde_json::Value) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct MetaGetAllVersionsWhen(httpmock::When);
    impl MetaGetAllVersionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/versions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct MetaGetAllVersionsThen(httpmock::Then);
    impl MetaGetAllVersionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<chrono::Date<chrono::offset::Utc>>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetSubscriptionPlanForAccountWhen(httpmock::When);
    impl AppsGetSubscriptionPlanForAccountWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/marketplace_listing/accounts/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn account_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/marketplace_listing/accounts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetSubscriptionPlanForAccountThen(httpmock::Then);
    impl AppsGetSubscriptionPlanForAccountThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::MarketplacePurchase) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListPlansWhen(httpmock::When);
    impl AppsListPlansWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/marketplace_listing/plans$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListPlansThen(httpmock::Then);
    impl AppsListPlansThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MarketplaceListingPlan>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListAccountsForPlanWhen(httpmock::When);
    impl AppsListAccountsForPlanWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/marketplace_listing/plans/.*/accounts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn plan_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/marketplace_listing/plans/{}/accounts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::AppsListAccountsForPlanDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::AppsListAccountsForPlanSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct AppsListAccountsForPlanThen(httpmock::Then);
    impl AppsListAccountsForPlanThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MarketplacePurchase>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetSubscriptionPlanForAccountStubbedWhen(httpmock::When);
    impl AppsGetSubscriptionPlanForAccountStubbedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/marketplace_listing/stubbed/accounts/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn account_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/marketplace_listing/stubbed/accounts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetSubscriptionPlanForAccountStubbedThen(httpmock::Then);
    impl AppsGetSubscriptionPlanForAccountStubbedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::MarketplacePurchase) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListPlansStubbedWhen(httpmock::When);
    impl AppsListPlansStubbedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/marketplace_listing/stubbed/plans$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListPlansStubbedThen(httpmock::Then);
    impl AppsListPlansStubbedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MarketplaceListingPlan>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListAccountsForPlanStubbedWhen(httpmock::When);
    impl AppsListAccountsForPlanStubbedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/marketplace_listing/stubbed/plans/.*/accounts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn plan_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/marketplace_listing/stubbed/plans/{}/accounts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::AppsListAccountsForPlanStubbedDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::AppsListAccountsForPlanStubbedSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct AppsListAccountsForPlanStubbedThen(httpmock::Then);
    impl AppsListAccountsForPlanStubbedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MarketplacePurchase>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MetaGetWhen(httpmock::When);
    impl MetaGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/meta$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct MetaGetThen(httpmock::Then);
    impl MetaGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ApiOverview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct ActivityListPublicEventsForRepoNetworkWhen(httpmock::When);
    impl ActivityListPublicEventsForRepoNetworkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/networks/.*/.*/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/networks/{}/.*/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/networks/.*/{}/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListPublicEventsForRepoNetworkThen(httpmock::Then);
    impl ActivityListPublicEventsForRepoNetworkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListNotificationsForAuthenticatedUserWhen(httpmock::When);
    impl ActivityListNotificationsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/notifications$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn all(self, value: bool) -> Self {
            Self(self.0.query_param("all", value.to_string()))
        }

        pub fn before(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn participating(self, value: bool) -> Self {
            Self(self.0.query_param("participating", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct ActivityListNotificationsForAuthenticatedUserThen(httpmock::Then);
    impl ActivityListNotificationsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Thread>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityMarkNotificationsAsReadWhen(httpmock::When);
    impl ActivityMarkNotificationsAsReadWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/notifications$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::ActivityMarkNotificationsAsReadBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActivityMarkNotificationsAsReadThen(httpmock::Then);
    impl ActivityMarkNotificationsAsReadThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::ActivityMarkNotificationsAsReadResponse) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn reset_content(self) -> Self {
            Self(self.0.status(205u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityGetThreadWhen(httpmock::When);
    impl ActivityGetThreadWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/notifications/threads/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn thread_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/notifications/threads/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityGetThreadThen(httpmock::Then);
    impl ActivityGetThreadThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Thread) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityMarkThreadAsReadWhen(httpmock::When);
    impl ActivityMarkThreadAsReadWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/notifications/threads/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn thread_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/notifications/threads/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityMarkThreadAsReadThen(httpmock::Then);
    impl ActivityMarkThreadAsReadThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn reset_content(self) -> Self {
            Self(self.0.status(205u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityGetThreadSubscriptionForAuthenticatedUserWhen(httpmock::When);
    impl ActivityGetThreadSubscriptionForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/notifications/threads/.*/subscription$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn thread_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/notifications/threads/{}/subscription$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityGetThreadSubscriptionForAuthenticatedUserThen(httpmock::Then);
    impl ActivityGetThreadSubscriptionForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ThreadSubscription) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivitySetThreadSubscriptionWhen(httpmock::When);
    impl ActivitySetThreadSubscriptionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/notifications/threads/.*/subscription$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn thread_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/notifications/threads/{}/subscription$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActivitySetThreadSubscriptionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActivitySetThreadSubscriptionThen(httpmock::Then);
    impl ActivitySetThreadSubscriptionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ThreadSubscription) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityDeleteThreadSubscriptionWhen(httpmock::When);
    impl ActivityDeleteThreadSubscriptionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/notifications/threads/.*/subscription$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn thread_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/notifications/threads/{}/subscription$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityDeleteThreadSubscriptionThen(httpmock::Then);
    impl ActivityDeleteThreadSubscriptionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MetaGetOctocatWhen(httpmock::When);
    impl MetaGetOctocatWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/octocat$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn s(self, value: &str) -> Self {
            Self(self.0.query_param("s", value.to_string()))
        }
    }

    pub struct MetaGetOctocatThen(httpmock::Then);
    impl MetaGetOctocatThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: serde_json::Value) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct OrgsListWhen(httpmock::When);
    impl OrgsListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/organizations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: i64) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct OrgsListThen(httpmock::Then);
    impl OrgsListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct OrgsListPatGrantRequestsWhen(httpmock::When);
    impl OrgsListPatGrantRequestsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-token-requests$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-token-requests$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::OrgsListPatGrantRequestsDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn last_used_after(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("last_used_after", value.to_string()))
        }

        pub fn last_used_before(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("last_used_before", value.to_string()))
        }

        pub fn owner(self, value: &Vec<String>) -> Self {
            Self(self.0.query_param("owner", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn permission(self, value: &str) -> Self {
            Self(self.0.query_param("permission", value.to_string()))
        }

        pub fn repository(self, value: &str) -> Self {
            Self(self.0.query_param("repository", value.to_string()))
        }

        pub fn sort(self, value: types::OrgsListPatGrantRequestsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct OrgsListPatGrantRequestsThen(httpmock::Then);
    impl OrgsListPatGrantRequestsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn ok(self, value: &Vec<types::OrganizationProgrammaticAccessGrantRequest>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsReviewPatGrantRequestsInBulkWhen(httpmock::When);
    impl OrgsReviewPatGrantRequestsInBulkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-token-requests$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-token-requests$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsReviewPatGrantRequestsInBulkBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsReviewPatGrantRequestsInBulkThen(httpmock::Then);
    impl OrgsReviewPatGrantRequestsInBulkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsReviewPatGrantRequestWhen(httpmock::When);
    impl OrgsReviewPatGrantRequestWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-token-requests/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-token-requests/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pat_request_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/.*/personal-access-token-requests/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsReviewPatGrantRequestBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsReviewPatGrantRequestThen(httpmock::Then);
    impl OrgsReviewPatGrantRequestThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct OrgsListPatGrantRequestRepositoriesWhen(httpmock::When);
    impl OrgsListPatGrantRequestRepositoriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/organizations/.*/personal-access-token-requests/.*/repositories$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-token-requests/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pat_request_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/.*/personal-access-token-requests/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListPatGrantRequestRepositoriesThen(httpmock::Then);
    impl OrgsListPatGrantRequestRepositoriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListPatGrantsWhen(httpmock::When);
    impl OrgsListPatGrantsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-tokens$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-tokens$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::OrgsListPatGrantsDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn last_used_after(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("last_used_after", value.to_string()))
        }

        pub fn last_used_before(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("last_used_before", value.to_string()))
        }

        pub fn owner(self, value: &Vec<String>) -> Self {
            Self(self.0.query_param("owner", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn permission(self, value: &str) -> Self {
            Self(self.0.query_param("permission", value.to_string()))
        }

        pub fn repository(self, value: &str) -> Self {
            Self(self.0.query_param("repository", value.to_string()))
        }

        pub fn sort(self, value: types::OrgsListPatGrantsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct OrgsListPatGrantsThen(httpmock::Then);
    impl OrgsListPatGrantsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn ok(self, value: &Vec<types::OrganizationProgrammaticAccessGrant>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUpdatePatAccessesWhen(httpmock::When);
    impl OrgsUpdatePatAccessesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-tokens$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-tokens$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsUpdatePatAccessesBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsUpdatePatAccessesThen(httpmock::Then);
    impl OrgsUpdatePatAccessesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUpdatePatAccessWhen(httpmock::When);
    impl OrgsUpdatePatAccessWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/organizations/.*/personal-access-tokens/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-tokens/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pat_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/.*/personal-access-tokens/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsUpdatePatAccessBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsUpdatePatAccessThen(httpmock::Then);
    impl OrgsUpdatePatAccessThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListPatGrantRepositoriesWhen(httpmock::When);
    impl OrgsListPatGrantRepositoriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/organizations/.*/personal-access-tokens/.*/repositories$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/{}/personal-access-tokens/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pat_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/organizations/.*/personal-access-tokens/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListPatGrantRepositoriesThen(httpmock::Then);
    impl OrgsListPatGrantRepositoriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MetaGetZenWhen(httpmock::When);
    impl MetaGetZenWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/zen$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct MetaGetZenThen(httpmock::Then);
    impl MetaGetZenThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: serde_json::Value) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ActionsGetActionsCacheUsageForOrgWhen(httpmock::When);
    impl ActionsGetActionsCacheUsageForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/cache/usage$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/cache/usage$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetActionsCacheUsageForOrgThen(httpmock::Then);
    impl ActionsGetActionsCacheUsageForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsCacheUsageOrgEnterprise) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetActionsCacheUsageByRepoForOrgWhen(httpmock::When);
    impl ActionsGetActionsCacheUsageByRepoForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/cache/usage-by-repository$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/cache/usage-by-repository$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsGetActionsCacheUsageByRepoForOrgThen(httpmock::Then);
    impl ActionsGetActionsCacheUsageByRepoForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsGetActionsCacheUsageByRepoForOrgResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OidcGetOidcCustomSubTemplateForOrgWhen(httpmock::When);
    impl OidcGetOidcCustomSubTemplateForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/oidc/customization/sub$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OidcGetOidcCustomSubTemplateForOrgThen(httpmock::Then);
    impl OidcGetOidcCustomSubTemplateForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OidcCustomSub) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OidcUpdateOidcCustomSubTemplateForOrgWhen(httpmock::When);
    impl OidcUpdateOidcCustomSubTemplateForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/oidc/customization/sub$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OidcCustomSub) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OidcUpdateOidcCustomSubTemplateForOrgThen(httpmock::Then);
    impl OidcUpdateOidcCustomSubTemplateForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetGithubActionsPermissionsOrganizationWhen(httpmock::When);
    impl ActionsGetGithubActionsPermissionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/permissions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetGithubActionsPermissionsOrganizationThen(httpmock::Then);
    impl ActionsGetGithubActionsPermissionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsOrganizationPermissions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetGithubActionsPermissionsOrganizationWhen(httpmock::When);
    impl ActionsSetGithubActionsPermissionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/permissions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsSetGithubActionsPermissionsOrganizationBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetGithubActionsPermissionsOrganizationThen(httpmock::Then);
    impl ActionsSetGithubActionsPermissionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationWhen(httpmock::When);
    impl ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationThen(httpmock::Then);
    impl ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWhen(httpmock::When);
    impl ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationThen(httpmock::Then);
    impl ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsEnableSelectedRepositoryGithubActionsOrganizationWhen(httpmock::When);
    impl ActionsEnableSelectedRepositoryGithubActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/permissions/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsEnableSelectedRepositoryGithubActionsOrganizationThen(httpmock::Then);
    impl ActionsEnableSelectedRepositoryGithubActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsDisableSelectedRepositoryGithubActionsOrganizationWhen(httpmock::When);
    impl ActionsDisableSelectedRepositoryGithubActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/permissions/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDisableSelectedRepositoryGithubActionsOrganizationThen(httpmock::Then);
    impl ActionsDisableSelectedRepositoryGithubActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetAllowedActionsOrganizationWhen(httpmock::When);
    impl ActionsGetAllowedActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/selected-actions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetAllowedActionsOrganizationThen(httpmock::Then);
    impl ActionsGetAllowedActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SelectedActions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetAllowedActionsOrganizationWhen(httpmock::When);
    impl ActionsSetAllowedActionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/selected-actions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::SelectedActions) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetAllowedActionsOrganizationThen(httpmock::Then);
    impl ActionsSetAllowedActionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWhen(httpmock::When);
    impl ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/workflow$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationThen(httpmock::Then);
    impl ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsGetDefaultWorkflowPermissions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWhen(httpmock::When);
    impl ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/permissions/workflow$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetDefaultWorkflowPermissions) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationThen(httpmock::Then);
    impl ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListRequiredWorkflowsWhen(httpmock::When);
    impl ActionsListRequiredWorkflowsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/required_workflows$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRequiredWorkflowsThen(httpmock::Then);
    impl ActionsListRequiredWorkflowsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRequiredWorkflowsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRequiredWorkflowWhen(httpmock::When);
    impl ActionsCreateRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/required_workflows$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateRequiredWorkflowBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateRequiredWorkflowThen(httpmock::Then);
    impl ActionsCreateRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RequiredWorkflow) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRequiredWorkflowWhen(httpmock::When);
    impl ActionsGetRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/required_workflows/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRequiredWorkflowThen(httpmock::Then);
    impl ActionsGetRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RequiredWorkflow) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteRequiredWorkflowWhen(httpmock::When);
    impl ActionsDeleteRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/actions/required_workflows/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteRequiredWorkflowThen(httpmock::Then);
    impl ActionsDeleteRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsUpdateRequiredWorkflowWhen(httpmock::When);
    impl ActionsUpdateRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/orgs/.*/actions/required_workflows/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsUpdateRequiredWorkflowBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsUpdateRequiredWorkflowThen(httpmock::Then);
    impl ActionsUpdateRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RequiredWorkflow) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListSelectedRepositoriesRequiredWorkflowWhen(httpmock::When);
    impl ActionsListSelectedRepositoriesRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/required_workflows/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsListSelectedRepositoriesRequiredWorkflowThen(httpmock::Then);
    impl ActionsListSelectedRepositoriesRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsListSelectedRepositoriesRequiredWorkflowResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct ActionsSetSelectedReposToRequiredWorkflowWhen(httpmock::When);
    impl ActionsSetSelectedReposToRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/required_workflows/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetSelectedReposToRequiredWorkflowBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetSelectedReposToRequiredWorkflowThen(httpmock::Then);
    impl ActionsSetSelectedReposToRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsAddSelectedRepoToRequiredWorkflowWhen(httpmock::When);
    impl ActionsAddSelectedRepoToRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/required_workflows/.*/repositories/.*$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsAddSelectedRepoToRequiredWorkflowThen(httpmock::Then);
    impl ActionsAddSelectedRepoToRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromRequiredWorkflowWhen(httpmock::When);
    impl ActionsRemoveSelectedRepoFromRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/required_workflows/.*/repositories/.*$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/required_workflows/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/required_workflows/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromRequiredWorkflowThen(httpmock::Then);
    impl ActionsRemoveSelectedRepoFromRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct ActionsListSelfHostedRunnersForOrgWhen(httpmock::When);
    impl ActionsListSelfHostedRunnersForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/runners$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/actions/runners$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListSelfHostedRunnersForOrgThen(httpmock::Then);
    impl ActionsListSelfHostedRunnersForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListSelfHostedRunnersForOrgResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRunnerApplicationsForOrgWhen(httpmock::When);
    impl ActionsListRunnerApplicationsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/runners/downloads$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/downloads$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsListRunnerApplicationsForOrgThen(httpmock::Then);
    impl ActionsListRunnerApplicationsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RunnerApplication>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRegistrationTokenForOrgWhen(httpmock::When);
    impl ActionsCreateRegistrationTokenForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/actions/runners/registration-token$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/registration-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsCreateRegistrationTokenForOrgThen(httpmock::Then);
    impl ActionsCreateRegistrationTokenForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::AuthenticationToken) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRemoveTokenForOrgWhen(httpmock::When);
    impl ActionsCreateRemoveTokenForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/actions/runners/remove-token$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/remove-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsCreateRemoveTokenForOrgThen(httpmock::Then);
    impl ActionsCreateRemoveTokenForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::AuthenticationToken) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsGetSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/runners/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/actions/runners/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/actions/runners/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsGetSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Runner) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteSelfHostedRunnerFromOrgWhen(httpmock::When);
    impl ActionsDeleteSelfHostedRunnerFromOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/runners/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/actions/runners/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/actions/runners/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteSelfHostedRunnerFromOrgThen(httpmock::Then);
    impl ActionsDeleteSelfHostedRunnerFromOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListLabelsForSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsListLabelsForSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/runners/.*/labels$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsListLabelsForSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsListLabelsForSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListLabelsForSelfHostedRunnerForOrgResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetCustomLabelsForSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsSetCustomLabelsForSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/runners/.*/labels$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsSetCustomLabelsForSelfHostedRunnerForOrgBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetCustomLabelsForSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsSetCustomLabelsForSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsAddCustomLabelsToSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsAddCustomLabelsToSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/runners/.*/labels$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsAddCustomLabelsToSelfHostedRunnerForOrgBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsAddCustomLabelsToSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsAddCustomLabelsToSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/runners/.*/labels$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgWhen(httpmock::When);
    impl ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/actions/runners/.*/labels/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/runners/.*/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/{}/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/runners/.*/labels/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgThen(httpmock::Then);
    impl ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListOrgSecretsWhen(httpmock::When);
    impl ActionsListOrgSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/actions/secrets$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListOrgSecretsThen(httpmock::Then);
    impl ActionsListOrgSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListOrgSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetOrgPublicKeyWhen(httpmock::When);
    impl ActionsGetOrgPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/actions/secrets/public-key$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetOrgPublicKeyThen(httpmock::Then);
    impl ActionsGetOrgPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetOrgSecretWhen(httpmock::When);
    impl ActionsGetOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/actions/secrets/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/actions/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetOrgSecretThen(httpmock::Then);
    impl ActionsGetOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrganizationActionsSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateOrUpdateOrgSecretWhen(httpmock::When);
    impl ActionsCreateOrUpdateOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/actions/secrets/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/actions/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateOrUpdateOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateOrUpdateOrgSecretThen(httpmock::Then);
    impl ActionsCreateOrUpdateOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsDeleteOrgSecretWhen(httpmock::When);
    impl ActionsDeleteOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/actions/secrets/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/actions/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteOrgSecretThen(httpmock::Then);
    impl ActionsDeleteOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListSelectedReposForOrgSecretWhen(httpmock::When);
    impl ActionsListSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListSelectedReposForOrgSecretThen(httpmock::Then);
    impl ActionsListSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListSelectedReposForOrgSecretResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetSelectedReposForOrgSecretWhen(httpmock::When);
    impl ActionsSetSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetSelectedReposForOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetSelectedReposForOrgSecretThen(httpmock::Then);
    impl ActionsSetSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsAddSelectedRepoToOrgSecretWhen(httpmock::When);
    impl ActionsAddSelectedRepoToOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsAddSelectedRepoToOrgSecretThen(httpmock::Then);
    impl ActionsAddSelectedRepoToOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromOrgSecretWhen(httpmock::When);
    impl ActionsRemoveSelectedRepoFromOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/actions/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromOrgSecretThen(httpmock::Then);
    impl ActionsRemoveSelectedRepoFromOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsListOrgVariablesWhen(httpmock::When);
    impl ActionsListOrgVariablesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/variables$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/actions/variables$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListOrgVariablesThen(httpmock::Then);
    impl ActionsListOrgVariablesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListOrgVariablesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateOrgVariableWhen(httpmock::When);
    impl ActionsCreateOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/variables$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/actions/variables$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateOrgVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateOrgVariableThen(httpmock::Then);
    impl ActionsCreateOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetOrgVariableWhen(httpmock::When);
    impl ActionsGetOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/variables/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetOrgVariableThen(httpmock::Then);
    impl ActionsGetOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrganizationActionsVariable) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteOrgVariableWhen(httpmock::When);
    impl ActionsDeleteOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/variables/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteOrgVariableThen(httpmock::Then);
    impl ActionsDeleteOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsUpdateOrgVariableWhen(httpmock::When);
    impl ActionsUpdateOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/orgs/.*/actions/variables/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsUpdateOrgVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsUpdateOrgVariableThen(httpmock::Then);
    impl ActionsUpdateOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListSelectedReposForOrgVariableWhen(httpmock::When);
    impl ActionsListSelectedReposForOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/actions/variables/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListSelectedReposForOrgVariableThen(httpmock::Then);
    impl ActionsListSelectedReposForOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListSelectedReposForOrgVariableResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsSetSelectedReposForOrgVariableWhen(httpmock::When);
    impl ActionsSetSelectedReposForOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/variables/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetSelectedReposForOrgVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetSelectedReposForOrgVariableThen(httpmock::Then);
    impl ActionsSetSelectedReposForOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsAddSelectedRepoToOrgVariableWhen(httpmock::When);
    impl ActionsAddSelectedRepoToOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/actions/variables/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsAddSelectedRepoToOrgVariableThen(httpmock::Then);
    impl ActionsAddSelectedRepoToOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromOrgVariableWhen(httpmock::When);
    impl ActionsRemoveSelectedRepoFromOrgVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/actions/variables/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/actions/variables/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/actions/variables/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveSelectedRepoFromOrgVariableThen(httpmock::Then);
    impl ActionsRemoveSelectedRepoFromOrgVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct OrgsListBlockedUsersWhen(httpmock::When);
    impl OrgsListBlockedUsersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/blocks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/blocks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListBlockedUsersThen(httpmock::Then);
    impl OrgsListBlockedUsersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCheckBlockedUserWhen(httpmock::When);
    impl OrgsCheckBlockedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/blocks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsCheckBlockedUserThen(httpmock::Then);
    impl OrgsCheckBlockedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsBlockUserWhen(httpmock::When);
    impl OrgsBlockUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/blocks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsBlockUserThen(httpmock::Then);
    impl OrgsBlockUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUnblockUserWhen(httpmock::When);
    impl OrgsUnblockUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/blocks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsUnblockUserThen(httpmock::Then);
    impl OrgsUnblockUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct CodeScanningListAlertsForOrgWhen(httpmock::When);
    impl CodeScanningListAlertsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/code-scanning/alerts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/code-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::CodeScanningListAlertsForOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn severity(self, value: types::CodeScanningAlertSeverity) -> Self {
            Self(self.0.query_param("severity", value.to_string()))
        }

        pub fn sort(self, value: types::CodeScanningListAlertsForOrgSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::CodeScanningAlertState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }

        pub fn tool_guid(self, value: &types::CodeScanningAnalysisToolGuid) -> Self {
            Self(self.0.query_param("tool_guid", value.to_string()))
        }

        pub fn tool_name(self, value: &types::CodeScanningAnalysisToolName) -> Self {
            Self(self.0.query_param("tool_name", value.to_string()))
        }
    }

    pub struct CodeScanningListAlertsForOrgThen(httpmock::Then);
    impl CodeScanningListAlertsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeScanningOrganizationAlertItems>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningListAlertsForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListInOrganizationWhen(httpmock::When);
    impl CodespacesListInOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/codespaces$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListInOrganizationThen(httpmock::Then);
    impl CodespacesListInOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListInOrganizationResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesSetCodespacesBillingWhen(httpmock::When);
    impl CodespacesSetCodespacesBillingWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces/billing$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/codespaces/billing$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesSetCodespacesBillingBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesSetCodespacesBillingThen(httpmock::Then);
    impl CodespacesSetCodespacesBillingThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesSetCodespacesBillingUsersWhen(httpmock::When);
    impl CodespacesSetCodespacesBillingUsersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/billing/selected_users$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/billing/selected_users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesSetCodespacesBillingUsersBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesSetCodespacesBillingUsersThen(httpmock::Then);
    impl CodespacesSetCodespacesBillingUsersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesDeleteCodespacesBillingUsersWhen(httpmock::When);
    impl CodespacesDeleteCodespacesBillingUsersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/billing/selected_users$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/billing/selected_users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesDeleteCodespacesBillingUsersBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesDeleteCodespacesBillingUsersThen(httpmock::Then);
    impl CodespacesDeleteCodespacesBillingUsersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListOrgSecretsWhen(httpmock::When);
    impl CodespacesListOrgSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/codespaces/secrets$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListOrgSecretsThen(httpmock::Then);
    impl CodespacesListOrgSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListOrgSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetOrgPublicKeyWhen(httpmock::When);
    impl CodespacesGetOrgPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetOrgPublicKeyThen(httpmock::Then);
    impl CodespacesGetOrgPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetOrgSecretWhen(httpmock::When);
    impl CodespacesGetOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetOrgSecretThen(httpmock::Then);
    impl CodespacesGetOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesOrgSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateOrUpdateOrgSecretWhen(httpmock::When);
    impl CodespacesCreateOrUpdateOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesCreateOrUpdateOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateOrUpdateOrgSecretThen(httpmock::Then);
    impl CodespacesCreateOrUpdateOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesDeleteOrgSecretWhen(httpmock::When);
    impl CodespacesDeleteOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesDeleteOrgSecretThen(httpmock::Then);
    impl CodespacesDeleteOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListSelectedReposForOrgSecretWhen(httpmock::When);
    impl CodespacesListSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListSelectedReposForOrgSecretThen(httpmock::Then);
    impl CodespacesListSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListSelectedReposForOrgSecretResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesSetSelectedReposForOrgSecretWhen(httpmock::When);
    impl CodespacesSetSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesSetSelectedReposForOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesSetSelectedReposForOrgSecretThen(httpmock::Then);
    impl CodespacesSetSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct CodespacesAddSelectedRepoToOrgSecretWhen(httpmock::When);
    impl CodespacesAddSelectedRepoToOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesAddSelectedRepoToOrgSecretThen(httpmock::Then);
    impl CodespacesAddSelectedRepoToOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesRemoveSelectedRepoFromOrgSecretWhen(httpmock::When);
    impl CodespacesRemoveSelectedRepoFromOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/codespaces/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/codespaces/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/codespaces/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesRemoveSelectedRepoFromOrgSecretThen(httpmock::Then);
    impl CodespacesRemoveSelectedRepoFromOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotListAlertsForOrgWhen(httpmock::When);
    impl DependabotListAlertsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/dependabot/alerts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/dependabot/alerts$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::DependabotListAlertsForOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn ecosystem(self, value: &str) -> Self {
            Self(self.0.query_param("ecosystem", value.to_string()))
        }

        pub fn first(self, value: i64) -> Self {
            Self(self.0.query_param("first", value.to_string()))
        }

        pub fn last(self, value: i64) -> Self {
            Self(self.0.query_param("last", value.to_string()))
        }

        pub fn package(self, value: &str) -> Self {
            Self(self.0.query_param("package", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn scope(self, value: types::DependabotListAlertsForOrgScope) -> Self {
            Self(self.0.query_param("scope", value.to_string()))
        }

        pub fn severity(self, value: &str) -> Self {
            Self(self.0.query_param("severity", value.to_string()))
        }

        pub fn sort(self, value: types::DependabotListAlertsForOrgSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: &str) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct DependabotListAlertsForOrgThen(httpmock::Then);
    impl DependabotListAlertsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DependabotAlertWithRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotListOrgSecretsWhen(httpmock::When);
    impl DependabotListOrgSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/dependabot/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/dependabot/secrets$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct DependabotListOrgSecretsThen(httpmock::Then);
    impl DependabotListOrgSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotListOrgSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotGetOrgPublicKeyWhen(httpmock::When);
    impl DependabotGetOrgPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/dependabot/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotGetOrgPublicKeyThen(httpmock::Then);
    impl DependabotGetOrgPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotGetOrgSecretWhen(httpmock::When);
    impl DependabotGetOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/dependabot/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotGetOrgSecretThen(httpmock::Then);
    impl DependabotGetOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrganizationDependabotSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotCreateOrUpdateOrgSecretWhen(httpmock::When);
    impl DependabotCreateOrUpdateOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/dependabot/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DependabotCreateOrUpdateOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct DependabotCreateOrUpdateOrgSecretThen(httpmock::Then);
    impl DependabotCreateOrUpdateOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct DependabotDeleteOrgSecretWhen(httpmock::When);
    impl DependabotDeleteOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/dependabot/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotDeleteOrgSecretThen(httpmock::Then);
    impl DependabotDeleteOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct DependabotListSelectedReposForOrgSecretWhen(httpmock::When);
    impl DependabotListSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/dependabot/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct DependabotListSelectedReposForOrgSecretThen(httpmock::Then);
    impl DependabotListSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotListSelectedReposForOrgSecretResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotSetSelectedReposForOrgSecretWhen(httpmock::When);
    impl DependabotSetSelectedReposForOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/dependabot/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DependabotSetSelectedReposForOrgSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct DependabotSetSelectedReposForOrgSecretThen(httpmock::Then);
    impl DependabotSetSelectedReposForOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct DependabotAddSelectedRepoToOrgSecretWhen(httpmock::When);
    impl DependabotAddSelectedRepoToOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/orgs/.*/dependabot/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotAddSelectedRepoToOrgSecretThen(httpmock::Then);
    impl DependabotAddSelectedRepoToOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct DependabotRemoveSelectedRepoFromOrgSecretWhen(httpmock::When);
    impl DependabotRemoveSelectedRepoFromOrgSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/dependabot/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/dependabot/secrets/.*/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/dependabot/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotRemoveSelectedRepoFromOrgSecretThen(httpmock::Then);
    impl DependabotRemoveSelectedRepoFromOrgSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForOrganizationWhen(httpmock::When);
    impl PackagesListDockerMigrationConflictingPackagesForOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/docker/conflicts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/docker/conflicts$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForOrganizationThen(httpmock::Then);
    impl PackagesListDockerMigrationConflictingPackagesForOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListPublicOrgEventsWhen(httpmock::When);
    impl ActivityListPublicOrgEventsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListPublicOrgEventsThen(httpmock::Then);
    impl ActivityListPublicOrgEventsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListFailedInvitationsWhen(httpmock::When);
    impl OrgsListFailedInvitationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/failed_invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/failed_invitations$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListFailedInvitationsThen(httpmock::Then);
    impl OrgsListFailedInvitationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListWebhooksWhen(httpmock::When);
    impl OrgsListWebhooksWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListWebhooksThen(httpmock::Then);
    impl OrgsListWebhooksThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrgHook>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCreateWebhookWhen(httpmock::When);
    impl OrgsCreateWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsCreateWebhookBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsCreateWebhookThen(httpmock::Then);
    impl OrgsCreateWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::OrgHook) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsGetWebhookWhen(httpmock::When);
    impl OrgsGetWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsGetWebhookThen(httpmock::Then);
    impl OrgsGetWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgHook) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsDeleteWebhookWhen(httpmock::When);
    impl OrgsDeleteWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsDeleteWebhookThen(httpmock::Then);
    impl OrgsDeleteWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUpdateWebhookWhen(httpmock::When);
    impl OrgsUpdateWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsUpdateWebhookBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsUpdateWebhookThen(httpmock::Then);
    impl OrgsUpdateWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgHook) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsGetWebhookConfigForOrgWhen(httpmock::When);
    impl OrgsGetWebhookConfigForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*/config$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}/config$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsGetWebhookConfigForOrgThen(httpmock::Then);
    impl OrgsGetWebhookConfigForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUpdateWebhookConfigForOrgWhen(httpmock::When);
    impl OrgsUpdateWebhookConfigForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*/config$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}/config$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsUpdateWebhookConfigForOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsUpdateWebhookConfigForOrgThen(httpmock::Then);
    impl OrgsUpdateWebhookConfigForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListWebhookDeliveriesWhen(httpmock::When);
    impl OrgsListWebhookDeliveriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*/deliveries$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/hooks/.*/deliveries$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/hooks/{}/deliveries$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn cursor(self, value: &str) -> Self {
            Self(self.0.query_param("cursor", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn redelivery(self, value: bool) -> Self {
            Self(self.0.query_param("redelivery", value.to_string()))
        }
    }

    pub struct OrgsListWebhookDeliveriesThen(httpmock::Then);
    impl OrgsListWebhookDeliveriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::HookDeliveryItem>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsGetWebhookDeliveryWhen(httpmock::When);
    impl OrgsGetWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*/deliveries/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/hooks/.*/deliveries/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/hooks/{}/deliveries/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/hooks/.*/deliveries/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsGetWebhookDeliveryThen(httpmock::Then);
    impl OrgsGetWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::HookDelivery) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsRedeliverWebhookDeliveryWhen(httpmock::When);
    impl OrgsRedeliverWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/hooks/.*/deliveries/.*/attempts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/hooks/.*/deliveries/.*/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/hooks/{}/deliveries/.*/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/hooks/.*/deliveries/{}/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRedeliverWebhookDeliveryThen(httpmock::Then);
    impl OrgsRedeliverWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsPingWebhookWhen(httpmock::When);
    impl OrgsPingWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/hooks/.*/pings$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/hooks/.*/pings$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/hooks/{}/pings$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsPingWebhookThen(httpmock::Then);
    impl OrgsPingWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetOrgInstallationWhen(httpmock::When);
    impl AppsGetOrgInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/installation$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/installation$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetOrgInstallationThen(httpmock::Then);
    impl AppsGetOrgInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Installation) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListAppInstallationsWhen(httpmock::When);
    impl OrgsListAppInstallationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/installations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/installations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListAppInstallationsThen(httpmock::Then);
    impl OrgsListAppInstallationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgsListAppInstallationsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsGetRestrictionsForOrgWhen(httpmock::When);
    impl InteractionsGetRestrictionsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/interaction-limits$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct InteractionsGetRestrictionsForOrgThen(httpmock::Then);
    impl InteractionsGetRestrictionsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::InteractionsGetRestrictionsForOrgResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsSetRestrictionsForOrgWhen(httpmock::When);
    impl InteractionsSetRestrictionsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/interaction-limits$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::InteractionLimit) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct InteractionsSetRestrictionsForOrgThen(httpmock::Then);
    impl InteractionsSetRestrictionsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::InteractionLimitResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsRemoveRestrictionsForOrgWhen(httpmock::When);
    impl InteractionsRemoveRestrictionsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/interaction-limits$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct InteractionsRemoveRestrictionsForOrgThen(httpmock::Then);
    impl InteractionsRemoveRestrictionsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct OrgsListPendingInvitationsWhen(httpmock::When);
    impl OrgsListPendingInvitationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/invitations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn invitation_source(
            self,
            value: types::OrgsListPendingInvitationsInvitationSource,
        ) -> Self {
            Self(self.0.query_param("invitation_source", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn role(self, value: types::OrgsListPendingInvitationsRole) -> Self {
            Self(self.0.query_param("role", value.to_string()))
        }
    }

    pub struct OrgsListPendingInvitationsThen(httpmock::Then);
    impl OrgsListPendingInvitationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCreateInvitationWhen(httpmock::When);
    impl OrgsCreateInvitationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/invitations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsCreateInvitationBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsCreateInvitationThen(httpmock::Then);
    impl OrgsCreateInvitationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::OrganizationInvitation) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCancelInvitationWhen(httpmock::When);
    impl OrgsCancelInvitationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/invitations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/invitations/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/invitations/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsCancelInvitationThen(httpmock::Then);
    impl OrgsCancelInvitationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListInvitationTeamsWhen(httpmock::When);
    impl OrgsListInvitationTeamsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/invitations/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/invitations/.*/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/invitations/{}/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListInvitationTeamsThen(httpmock::Then);
    impl OrgsListInvitationTeamsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListForOrgWhen(httpmock::When);
    impl IssuesListForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/issues$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::IssuesListForOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn filter(self, value: types::IssuesListForOrgFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn labels(self, value: &str) -> Self {
            Self(self.0.query_param("labels", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListForOrgSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::IssuesListForOrgState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct IssuesListForOrgThen(httpmock::Then);
    impl IssuesListForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Issue>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListMembersWhen(httpmock::When);
    impl OrgsListMembersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/members$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/members$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn filter(self, value: types::OrgsListMembersFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn role(self, value: types::OrgsListMembersRole) -> Self {
            Self(self.0.query_param("role", value.to_string()))
        }
    }

    pub struct OrgsListMembersThen(httpmock::Then);
    impl OrgsListMembersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCheckMembershipForUserWhen(httpmock::When);
    impl OrgsCheckMembershipForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/members/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/members/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsCheckMembershipForUserThen(httpmock::Then);
    impl OrgsCheckMembershipForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct OrgsRemoveMemberWhen(httpmock::When);
    impl OrgsRemoveMemberWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/members/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/members/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRemoveMemberThen(httpmock::Then);
    impl OrgsRemoveMemberThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetCodespacesForUserInOrgWhen(httpmock::When);
    impl CodespacesGetCodespacesForUserInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/members/.*/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/members/.*/codespaces$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/members/{}/codespaces$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesGetCodespacesForUserInOrgThen(httpmock::Then);
    impl CodespacesGetCodespacesForUserInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesGetCodespacesForUserInOrgResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesDeleteFromOrganizationWhen(httpmock::When);
    impl CodespacesDeleteFromOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/members/.*/codespaces/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/members/.*/codespaces/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/members/{}/codespaces/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/members/.*/codespaces/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesDeleteFromOrganizationThen(httpmock::Then);
    impl CodespacesDeleteFromOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesStopInOrganizationWhen(httpmock::When);
    impl CodespacesStopInOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/members/.*/codespaces/.*/stop$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/members/.*/codespaces/.*/stop$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/members/{}/codespaces/.*/stop$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/members/.*/codespaces/{}/stop$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesStopInOrganizationThen(httpmock::Then);
    impl CodespacesStopInOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsGetMembershipForUserWhen(httpmock::When);
    impl OrgsGetMembershipForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsGetMembershipForUserThen(httpmock::Then);
    impl OrgsGetMembershipForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsSetMembershipForUserWhen(httpmock::When);
    impl OrgsSetMembershipForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsSetMembershipForUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsSetMembershipForUserThen(httpmock::Then);
    impl OrgsSetMembershipForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsRemoveMembershipForUserWhen(httpmock::When);
    impl OrgsRemoveMembershipForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRemoveMembershipForUserThen(httpmock::Then);
    impl OrgsRemoveMembershipForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsListForOrgWhen(httpmock::When);
    impl MigrationsListForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/migrations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/migrations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn exclude(self, value: &Vec<types::MigrationsListForOrgExcludeItem>) -> Self {
            Self(self.0.query_param("exclude", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct MigrationsListForOrgThen(httpmock::Then);
    impl MigrationsListForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Migration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsStartForOrgWhen(httpmock::When);
    impl MigrationsStartForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/migrations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/migrations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::MigrationsStartForOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsStartForOrgThen(httpmock::Then);
    impl MigrationsStartForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Migration) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetStatusForOrgWhen(httpmock::When);
    impl MigrationsGetStatusForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/migrations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/migrations/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/migrations/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn exclude(self, value: &Vec<types::MigrationsGetStatusForOrgExcludeItem>) -> Self {
            Self(self.0.query_param("exclude", value.to_string()))
        }
    }

    pub struct MigrationsGetStatusForOrgThen(httpmock::Then);
    impl MigrationsGetStatusForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Migration) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsDownloadArchiveForOrgWhen(httpmock::When);
    impl MigrationsDownloadArchiveForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/migrations/.*/archive$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/migrations/.*/archive$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/migrations/{}/archive$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsDownloadArchiveForOrgThen(httpmock::Then);
    impl MigrationsDownloadArchiveForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct MigrationsDeleteArchiveForOrgWhen(httpmock::When);
    impl MigrationsDeleteArchiveForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/migrations/.*/archive$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/migrations/.*/archive$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/migrations/{}/archive$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsDeleteArchiveForOrgThen(httpmock::Then);
    impl MigrationsDeleteArchiveForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsUnlockRepoForOrgWhen(httpmock::When);
    impl MigrationsUnlockRepoForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/migrations/.*/repos/.*/lock$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/migrations/.*/repos/.*/lock$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/migrations/{}/repos/.*/lock$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/migrations/.*/repos/{}/lock$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsUnlockRepoForOrgThen(httpmock::Then);
    impl MigrationsUnlockRepoForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsListReposForOrgWhen(httpmock::When);
    impl MigrationsListReposForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/migrations/.*/repositories$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/migrations/.*/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/migrations/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct MigrationsListReposForOrgThen(httpmock::Then);
    impl MigrationsListReposForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListOutsideCollaboratorsWhen(httpmock::When);
    impl OrgsListOutsideCollaboratorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/outside_collaborators$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/outside_collaborators$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn filter(self, value: types::OrgsListOutsideCollaboratorsFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListOutsideCollaboratorsThen(httpmock::Then);
    impl OrgsListOutsideCollaboratorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsConvertMemberToOutsideCollaboratorWhen(httpmock::When);
    impl OrgsConvertMemberToOutsideCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/orgs/.*/outside_collaborators/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/outside_collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/outside_collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsConvertMemberToOutsideCollaboratorBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsConvertMemberToOutsideCollaboratorThen(httpmock::Then);
    impl OrgsConvertMemberToOutsideCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &types::OrgsConvertMemberToOutsideCollaboratorResponse,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsRemoveOutsideCollaboratorWhen(httpmock::When);
    impl OrgsRemoveOutsideCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/outside_collaborators/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/outside_collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/outside_collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRemoveOutsideCollaboratorThen(httpmock::Then);
    impl OrgsRemoveOutsideCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(
            self,
            value: &types::OrgsRemoveOutsideCollaboratorResponse,
        ) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesListPackagesForOrganizationWhen(httpmock::When);
    impl PackagesListPackagesForOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/packages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/packages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesListPackagesForOrganizationPackageType,
        ) -> Self {
            Self(self.0.query_param("package_type", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn visibility(
            self,
            value: types::PackagesListPackagesForOrganizationVisibility,
        ) -> Self {
            Self(self.0.query_param("visibility", value.to_string()))
        }
    }

    pub struct PackagesListPackagesForOrganizationThen(httpmock::Then);
    impl PackagesListPackagesForOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }
    }

    pub struct PackagesGetPackageForOrganizationWhen(httpmock::When);
    impl PackagesGetPackageForOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/packages/.*/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesGetPackageForOrganizationPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/packages/{}/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/packages/.*/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageForOrganizationThen(httpmock::Then);
    impl PackagesGetPackageForOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Package) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageForOrgWhen(httpmock::When);
    impl PackagesDeletePackageForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/packages/.*/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesDeletePackageForOrgPackageType) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/packages/{}/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/packages/.*/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageForOrgThen(httpmock::Then);
    impl PackagesDeletePackageForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageForOrgWhen(httpmock::When);
    impl PackagesRestorePackageForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/packages/.*/.*/restore$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/packages/.*/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesRestorePackageForOrgPackageType) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/{}/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn token(self, value: &str) -> Self {
            Self(self.0.query_param("token", value.to_string()))
        }
    }

    pub struct PackagesRestorePackageForOrgThen(httpmock::Then);
    impl PackagesRestorePackageForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByOrgWhen(httpmock::When);
    impl PackagesGetAllPackageVersionsForPackageOwnedByOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/packages/.*/.*/versions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/packages/.*/.*/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesGetAllPackageVersionsForPackageOwnedByOrgPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/{}/.*/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/{}/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(
            self,
            value: types::PackagesGetAllPackageVersionsForPackageOwnedByOrgState,
        ) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByOrgThen(httpmock::Then);
    impl PackagesGetAllPackageVersionsForPackageOwnedByOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PackageVersion>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetPackageVersionForOrganizationWhen(httpmock::When);
    impl PackagesGetPackageVersionForOrganizationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/packages/.*/.*/versions/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/packages/.*/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesGetPackageVersionForOrganizationPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageVersionForOrganizationThen(httpmock::Then);
    impl PackagesGetPackageVersionForOrganizationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PackageVersion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageVersionForOrgWhen(httpmock::When);
    impl PackagesDeletePackageVersionForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/packages/.*/.*/versions/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/packages/.*/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesDeletePackageVersionForOrgPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageVersionForOrgThen(httpmock::Then);
    impl PackagesDeletePackageVersionForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageVersionForOrgWhen(httpmock::When);
    impl PackagesRestorePackageVersionForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/packages/.*/.*/versions/.*/restore$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/packages/.*/.*/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesRestorePackageVersionForOrgPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/{}/.*/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/{}/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/packages/.*/.*/versions/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesRestorePackageVersionForOrgThen(httpmock::Then);
    impl PackagesRestorePackageVersionForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsListForOrgWhen(httpmock::When);
    impl ProjectsListForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(self, value: types::ProjectsListForOrgState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct ProjectsListForOrgThen(httpmock::Then);
    impl ProjectsListForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Project>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsCreateForOrgWhen(httpmock::When);
    impl ProjectsCreateForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsCreateForOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsCreateForOrgThen(httpmock::Then);
    impl ProjectsCreateForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Project) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListPublicMembersWhen(httpmock::When);
    impl OrgsListPublicMembersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/public_members$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/public_members$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListPublicMembersThen(httpmock::Then);
    impl OrgsListPublicMembersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsCheckPublicMembershipForUserWhen(httpmock::When);
    impl OrgsCheckPublicMembershipForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/public_members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/public_members/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/public_members/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsCheckPublicMembershipForUserThen(httpmock::Then);
    impl OrgsCheckPublicMembershipForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct OrgsSetPublicMembershipForAuthenticatedUserWhen(httpmock::When);
    impl OrgsSetPublicMembershipForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/public_members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/public_members/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/public_members/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsSetPublicMembershipForAuthenticatedUserThen(httpmock::Then);
    impl OrgsSetPublicMembershipForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsRemovePublicMembershipForAuthenticatedUserWhen(httpmock::When);
    impl OrgsRemovePublicMembershipForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/public_members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/public_members/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/public_members/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRemovePublicMembershipForAuthenticatedUserThen(httpmock::Then);
    impl OrgsRemovePublicMembershipForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListForOrgWhen(httpmock::When);
    impl ReposListForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/repos$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::ReposListForOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::ReposListForOrgSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn type_(self, value: types::ReposListForOrgType) -> Self {
            Self(self.0.query_param("type_", value.to_string()))
        }
    }

    pub struct ReposListForOrgThen(httpmock::Then);
    impl ReposListForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateInOrgWhen(httpmock::When);
    impl ReposCreateInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/repos$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateInOrgThen(httpmock::Then);
    impl ReposCreateInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Repository) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetOrgRulesetsWhen(httpmock::When);
    impl ReposGetOrgRulesetsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/rulesets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetOrgRulesetsThen(httpmock::Then);
    impl ReposGetOrgRulesetsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryRuleset>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateOrgRulesetWhen(httpmock::When);
    impl ReposCreateOrgRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/rulesets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateOrgRulesetBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateOrgRulesetThen(httpmock::Then);
    impl ReposCreateOrgRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetOrgRulesetWhen(httpmock::When);
    impl ReposGetOrgRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/rulesets/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/rulesets/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetOrgRulesetThen(httpmock::Then);
    impl ReposGetOrgRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateOrgRulesetWhen(httpmock::When);
    impl ReposUpdateOrgRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/rulesets/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/rulesets/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateOrgRulesetBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateOrgRulesetThen(httpmock::Then);
    impl ReposUpdateOrgRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteOrgRulesetWhen(httpmock::When);
    impl ReposDeleteOrgRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/{}/rulesets/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/orgs/.*/rulesets/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteOrgRulesetThen(httpmock::Then);
    impl ReposDeleteOrgRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningListAlertsForOrgWhen(httpmock::When);
    impl SecretScanningListAlertsForOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/secret-scanning/alerts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/secret-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::SecretScanningListAlertsForOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn resolution(self, value: &str) -> Self {
            Self(self.0.query_param("resolution", value.to_string()))
        }

        pub fn secret_type(self, value: &str) -> Self {
            Self(self.0.query_param("secret_type", value.to_string()))
        }

        pub fn sort(self, value: types::SecretScanningListAlertsForOrgSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::SecretScanningListAlertsForOrgState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct SecretScanningListAlertsForOrgThen(httpmock::Then);
    impl SecretScanningListAlertsForOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationSecretScanningAlert>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::SecretScanningListAlertsForOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListSecurityManagerTeamsWhen(httpmock::When);
    impl OrgsListSecurityManagerTeamsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/security-managers$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/security-managers$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsListSecurityManagerTeamsThen(httpmock::Then);
    impl OrgsListSecurityManagerTeamsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsAddSecurityManagerTeamWhen(httpmock::When);
    impl OrgsAddSecurityManagerTeamWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/orgs/.*/security-managers/teams/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/security-managers/teams/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/security-managers/teams/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsAddSecurityManagerTeamThen(httpmock::Then);
    impl OrgsAddSecurityManagerTeamThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct OrgsRemoveSecurityManagerTeamWhen(httpmock::When);
    impl OrgsRemoveSecurityManagerTeamWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/orgs/.*/security-managers/teams/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/security-managers/teams/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/security-managers/teams/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsRemoveSecurityManagerTeamThen(httpmock::Then);
    impl OrgsRemoveSecurityManagerTeamThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct BillingGetGithubActionsBillingOrgWhen(httpmock::When);
    impl BillingGetGithubActionsBillingOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/settings/billing/actions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/settings/billing/actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetGithubActionsBillingOrgThen(httpmock::Then);
    impl BillingGetGithubActionsBillingOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct BillingGetGithubPackagesBillingOrgWhen(httpmock::When);
    impl BillingGetGithubPackagesBillingOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/settings/billing/packages$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/settings/billing/packages$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetGithubPackagesBillingOrgThen(httpmock::Then);
    impl BillingGetGithubPackagesBillingOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PackagesBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct BillingGetSharedStorageBillingOrgWhen(httpmock::When);
    impl BillingGetSharedStorageBillingOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/settings/billing/shared-storage$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/settings/billing/shared-storage$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetSharedStorageBillingOrgThen(httpmock::Then);
    impl BillingGetSharedStorageBillingOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CombinedBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListWhen(httpmock::When);
    impl TeamsListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListThen(httpmock::Then);
    impl TeamsListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCreateWhen(httpmock::When);
    impl TeamsCreateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsCreateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsCreateThen(httpmock::Then);
    impl TeamsCreateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetByNameWhen(httpmock::When);
    impl TeamsGetByNameWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetByNameThen(httpmock::Then);
    impl TeamsGetByNameThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteInOrgWhen(httpmock::When);
    impl TeamsDeleteInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteInOrgThen(httpmock::Then);
    impl TeamsDeleteInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsUpdateInOrgWhen(httpmock::When);
    impl TeamsUpdateInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateInOrgThen(httpmock::Then);
    impl TeamsUpdateInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListDiscussionsInOrgWhen(httpmock::When);
    impl TeamsListDiscussionsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/discussions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::TeamsListDiscussionsInOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn pinned(self, value: &str) -> Self {
            Self(self.0.query_param("pinned", value.to_string()))
        }
    }

    pub struct TeamsListDiscussionsInOrgThen(httpmock::Then);
    impl TeamsListDiscussionsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamDiscussion>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCreateDiscussionInOrgWhen(httpmock::When);
    impl TeamsCreateDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/discussions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsCreateDiscussionInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsCreateDiscussionInOrgThen(httpmock::Then);
    impl TeamsCreateDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetDiscussionInOrgWhen(httpmock::When);
    impl TeamsGetDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetDiscussionInOrgThen(httpmock::Then);
    impl TeamsGetDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteDiscussionInOrgWhen(httpmock::When);
    impl TeamsDeleteDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteDiscussionInOrgThen(httpmock::Then);
    impl TeamsDeleteDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsUpdateDiscussionInOrgWhen(httpmock::When);
    impl TeamsUpdateDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateDiscussionInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateDiscussionInOrgThen(httpmock::Then);
    impl TeamsUpdateDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListDiscussionCommentsInOrgWhen(httpmock::When);
    impl TeamsListDiscussionCommentsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::TeamsListDiscussionCommentsInOrgDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListDiscussionCommentsInOrgThen(httpmock::Then);
    impl TeamsListDiscussionCommentsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamDiscussionComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCreateDiscussionCommentInOrgWhen(httpmock::When);
    impl TeamsCreateDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsCreateDiscussionCommentInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsCreateDiscussionCommentInOrgThen(httpmock::Then);
    impl TeamsCreateDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetDiscussionCommentInOrgWhen(httpmock::When);
    impl TeamsGetDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetDiscussionCommentInOrgThen(httpmock::Then);
    impl TeamsGetDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteDiscussionCommentInOrgWhen(httpmock::When);
    impl TeamsDeleteDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteDiscussionCommentInOrgThen(httpmock::Then);
    impl TeamsDeleteDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsUpdateDiscussionCommentInOrgWhen(httpmock::When);
    impl TeamsUpdateDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateDiscussionCommentInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateDiscussionCommentInOrgThen(httpmock::Then);
    impl TeamsUpdateDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForTeamDiscussionCommentInOrgWhen(httpmock::When);
    impl ReactionsListForTeamDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments/.*/reactions$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(
            self,
            value: types::ReactionsListForTeamDiscussionCommentInOrgContent,
        ) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForTeamDiscussionCommentInOrgThen(httpmock::Then);
    impl ReactionsListForTeamDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForTeamDiscussionCommentInOrgWhen(httpmock::When);
    impl ReactionsCreateForTeamDiscussionCommentInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/comments/.*/reactions$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForTeamDiscussionCommentInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForTeamDiscussionCommentInOrgThen(httpmock::Then);
    impl ReactionsCreateForTeamDiscussionCommentInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForTeamDiscussionCommentWhen(httpmock::When);
    impl ReactionsDeleteForTeamDiscussionCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/orgs/.*/teams/.*/discussions/.*/comments/.*/reactions/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/comments/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForTeamDiscussionCommentThen(httpmock::Then);
    impl ReactionsDeleteForTeamDiscussionCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReactionsListForTeamDiscussionInOrgWhen(httpmock::When);
    impl ReactionsListForTeamDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForTeamDiscussionInOrgContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForTeamDiscussionInOrgThen(httpmock::Then);
    impl ReactionsListForTeamDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForTeamDiscussionInOrgWhen(httpmock::When);
    impl ReactionsCreateForTeamDiscussionInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForTeamDiscussionInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForTeamDiscussionInOrgThen(httpmock::Then);
    impl ReactionsCreateForTeamDiscussionInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForTeamDiscussionWhen(httpmock::When);
    impl ReactionsDeleteForTeamDiscussionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/orgs/.*/teams/.*/discussions/.*/reactions/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/discussions/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/discussions/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/discussions/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForTeamDiscussionThen(httpmock::Then);
    impl ReactionsDeleteForTeamDiscussionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsListPendingInvitationsInOrgWhen(httpmock::When);
    impl TeamsListPendingInvitationsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/invitations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/invitations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListPendingInvitationsInOrgThen(httpmock::Then);
    impl TeamsListPendingInvitationsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListMembersInOrgWhen(httpmock::When);
    impl TeamsListMembersInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/members$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*/members$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}/members$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn role(self, value: types::TeamsListMembersInOrgRole) -> Self {
            Self(self.0.query_param("role", value.to_string()))
        }
    }

    pub struct TeamsListMembersInOrgThen(httpmock::Then);
    impl TeamsListMembersInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetMembershipForUserInOrgWhen(httpmock::When);
    impl TeamsGetMembershipForUserInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/memberships/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetMembershipForUserInOrgThen(httpmock::Then);
    impl TeamsGetMembershipForUserInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddOrUpdateMembershipForUserInOrgWhen(httpmock::When);
    impl TeamsAddOrUpdateMembershipForUserInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/memberships/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateMembershipForUserInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateMembershipForUserInOrgThen(httpmock::Then);
    impl TeamsAddOrUpdateMembershipForUserInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct TeamsRemoveMembershipForUserInOrgWhen(httpmock::When);
    impl TeamsRemoveMembershipForUserInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/memberships/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/memberships/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveMembershipForUserInOrgThen(httpmock::Then);
    impl TeamsRemoveMembershipForUserInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }
    }

    pub struct TeamsListProjectsInOrgWhen(httpmock::When);
    impl TeamsListProjectsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*/projects$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}/projects$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListProjectsInOrgThen(httpmock::Then);
    impl TeamsListProjectsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamProject>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCheckPermissionsForProjectInOrgWhen(httpmock::When);
    impl TeamsCheckPermissionsForProjectInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/projects/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsCheckPermissionsForProjectInOrgThen(httpmock::Then);
    impl TeamsCheckPermissionsForProjectInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamProject) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddOrUpdateProjectPermissionsInOrgWhen(httpmock::When);
    impl TeamsAddOrUpdateProjectPermissionsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/projects/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateProjectPermissionsInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateProjectPermissionsInOrgThen(httpmock::Then);
    impl TeamsAddOrUpdateProjectPermissionsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(
            self,
            value: &types::TeamsAddOrUpdateProjectPermissionsInOrgResponse,
        ) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsRemoveProjectInOrgWhen(httpmock::When);
    impl TeamsRemoveProjectInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/projects/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/projects/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveProjectInOrgThen(httpmock::Then);
    impl TeamsRemoveProjectInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsListReposInOrgWhen(httpmock::When);
    impl TeamsListReposInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*/repos$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}/repos$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListReposInOrgThen(httpmock::Then);
    impl TeamsListReposInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCheckPermissionsForRepoInOrgWhen(httpmock::When);
    impl TeamsCheckPermissionsForRepoInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/{}/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/.*/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsCheckPermissionsForRepoInOrgThen(httpmock::Then);
    impl TeamsCheckPermissionsForRepoInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddOrUpdateRepoPermissionsInOrgWhen(httpmock::When);
    impl TeamsAddOrUpdateRepoPermissionsInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/{}/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/.*/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateRepoPermissionsInOrgBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateRepoPermissionsInOrgThen(httpmock::Then);
    impl TeamsAddOrUpdateRepoPermissionsInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsRemoveRepoInOrgWhen(httpmock::When);
    impl TeamsRemoveRepoInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/{}/teams/.*/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/{}/repos/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/{}/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/orgs/.*/teams/.*/repos/.*/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveRepoInOrgThen(httpmock::Then);
    impl TeamsRemoveRepoInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsListChildInOrgWhen(httpmock::When);
    impl TeamsListChildInOrgWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/orgs/.*/teams/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/teams/.*/teams$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn team_slug(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/teams/{}/teams$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListChildInOrgThen(httpmock::Then);
    impl TeamsListChildInOrgThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsEnableOrDisableSecurityProductOnAllOrgReposWhen(httpmock::When);
    impl OrgsEnableOrDisableSecurityProductOnAllOrgReposWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/orgs/.*/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/{}/.*/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn security_product(
            self,
            value: types::OrgsEnableOrDisableSecurityProductOnAllOrgReposSecurityProduct,
        ) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn enablement(
            self,
            value: types::OrgsEnableOrDisableSecurityProductOnAllOrgReposEnablement,
        ) -> Self {
            let re = regex::Regex::new(&format!("^/orgs/.*/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsEnableOrDisableSecurityProductOnAllOrgReposThen(httpmock::Then);
    impl OrgsEnableOrDisableSecurityProductOnAllOrgReposThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct ProjectsGetCardWhen(httpmock::When);
    impl ProjectsGetCardWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/projects/columns/cards/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn card_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/columns/cards/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsGetCardThen(httpmock::Then);
    impl ProjectsGetCardThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProjectCard) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsDeleteCardWhen(httpmock::When);
    impl ProjectsDeleteCardWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/projects/columns/cards/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn card_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/columns/cards/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsDeleteCardThen(httpmock::Then);
    impl ProjectsDeleteCardThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::ProjectsDeleteCardResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsUpdateCardWhen(httpmock::When);
    impl ProjectsUpdateCardWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/projects/columns/cards/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn card_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/columns/cards/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsUpdateCardBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsUpdateCardThen(httpmock::Then);
    impl ProjectsUpdateCardThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProjectCard) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsMoveCardWhen(httpmock::When);
    impl ProjectsMoveCardWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/projects/columns/cards/.*/moves$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn card_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/columns/cards/{}/moves$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsMoveCardBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsMoveCardThen(httpmock::Then);
    impl ProjectsMoveCardThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::ProjectsMoveCardResponse) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::ProjectsMoveCardResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::ProjectsMoveCardResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsGetColumnWhen(httpmock::When);
    impl ProjectsGetColumnWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/projects/columns/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn column_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/projects/columns/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsGetColumnThen(httpmock::Then);
    impl ProjectsGetColumnThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProjectColumn) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsDeleteColumnWhen(httpmock::When);
    impl ProjectsDeleteColumnWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/projects/columns/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn column_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/projects/columns/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsDeleteColumnThen(httpmock::Then);
    impl ProjectsDeleteColumnThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsUpdateColumnWhen(httpmock::When);
    impl ProjectsUpdateColumnWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/projects/columns/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn column_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/projects/columns/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsUpdateColumnBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsUpdateColumnThen(httpmock::Then);
    impl ProjectsUpdateColumnThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProjectColumn) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListSshSigningKeysForUserWhen(httpmock::When);
    impl UsersListSshSigningKeysForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/ssh_signing_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/ssh_signing_keys$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListSshSigningKeysForUserThen(httpmock::Then);
    impl UsersListSshSigningKeysForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SshSigningKey>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsMoveColumnWhen(httpmock::When);
    impl ProjectsMoveColumnWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/projects/columns/.*/moves$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn column_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/columns/{}/moves$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsMoveColumnBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsMoveColumnThen(httpmock::Then);
    impl ProjectsMoveColumnThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::ProjectsMoveColumnResponse) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsGetWhen(httpmock::When);
    impl ProjectsGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsGetThen(httpmock::Then);
    impl ProjectsGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Project) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsDeleteWhen(httpmock::When);
    impl ProjectsDeleteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsDeleteThen(httpmock::Then);
    impl ProjectsDeleteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::ProjectsDeleteResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsUpdateWhen(httpmock::When);
    impl ProjectsUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsUpdateThen(httpmock::Then);
    impl ProjectsUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Project) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::ProjectsUpdateResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsListCollaboratorsWhen(httpmock::When);
    impl ProjectsListCollaboratorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/projects/.*/collaborators$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/projects/{}/collaborators$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn affiliation(self, value: types::ProjectsListCollaboratorsAffiliation) -> Self {
            Self(self.0.query_param("affiliation", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ProjectsListCollaboratorsThen(httpmock::Then);
    impl ProjectsListCollaboratorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsAddCollaboratorWhen(httpmock::When);
    impl ProjectsAddCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/projects/.*/collaborators/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/{}/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/.*/collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsAddCollaboratorBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsAddCollaboratorThen(httpmock::Then);
    impl ProjectsAddCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsRemoveCollaboratorWhen(httpmock::When);
    impl ProjectsRemoveCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/projects/.*/collaborators/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/{}/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/.*/collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsRemoveCollaboratorThen(httpmock::Then);
    impl ProjectsRemoveCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsGetPermissionForUserWhen(httpmock::When);
    impl ProjectsGetPermissionForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/projects/.*/collaborators/.*/permission$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/{}/collaborators/.*/permission$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/projects/.*/collaborators/{}/permission$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ProjectsGetPermissionForUserThen(httpmock::Then);
    impl ProjectsGetPermissionForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProjectCollaboratorPermission) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsListColumnsWhen(httpmock::When);
    impl ProjectsListColumnsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/projects/.*/columns$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/projects/{}/columns$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ProjectsListColumnsThen(httpmock::Then);
    impl ProjectsListColumnsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ProjectColumn>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsCreateColumnWhen(httpmock::When);
    impl ProjectsCreateColumnWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/projects/.*/columns$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn project_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/projects/{}/columns$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsCreateColumnBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsCreateColumnThen(httpmock::Then);
    impl ProjectsCreateColumnThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::ProjectColumn) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct RateLimitGetWhen(httpmock::When);
    impl RateLimitGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/rate_limit$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct RateLimitGetThen(httpmock::Then);
    impl RateLimitGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RateLimitOverview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRepoRequiredWorkflowsWhen(httpmock::When);
    impl ActionsListRepoRequiredWorkflowsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/required_workflows$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/required_workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/required_workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoRequiredWorkflowsThen(httpmock::Then);
    impl ActionsListRepoRequiredWorkflowsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoRequiredWorkflowsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRepoRequiredWorkflowWhen(httpmock::When);
    impl ActionsGetRepoRequiredWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/required_workflows/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/required_workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/required_workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id_for_repo(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/required_workflows/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRepoRequiredWorkflowThen(httpmock::Then);
    impl ActionsGetRepoRequiredWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepoRequiredWorkflow) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRepoRequiredWorkflowUsageWhen(httpmock::When);
    impl ActionsGetRepoRequiredWorkflowUsageWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/required_workflows/.*/timing$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/required_workflows/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/required_workflows/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id_for_repo(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/required_workflows/{}/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRepoRequiredWorkflowUsageThen(httpmock::Then);
    impl ActionsGetRepoRequiredWorkflowUsageThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WorkflowUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetWhen(httpmock::When);
    impl ReposGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetThen(httpmock::Then);
    impl ReposGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::FullRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteWhen(httpmock::When);
    impl ReposDeleteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteThen(httpmock::Then);
    impl ReposDeleteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::ReposDeleteResponse) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn temporary_redirect(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(307u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateWhen(httpmock::When);
    impl ReposUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateThen(httpmock::Then);
    impl ReposUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::FullRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn temporary_redirect(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(307u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListArtifactsForRepoWhen(httpmock::When);
    impl ActionsListArtifactsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/artifacts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/artifacts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/artifacts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            Self(self.0.query_param("name", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListArtifactsForRepoThen(httpmock::Then);
    impl ActionsListArtifactsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListArtifactsForRepoResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetArtifactWhen(httpmock::When);
    impl ActionsGetArtifactWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/artifacts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/artifacts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/artifacts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn artifact_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/artifacts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetArtifactThen(httpmock::Then);
    impl ActionsGetArtifactThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Artifact) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteArtifactWhen(httpmock::When);
    impl ActionsDeleteArtifactWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/artifacts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/artifacts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/artifacts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn artifact_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/artifacts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteArtifactThen(httpmock::Then);
    impl ActionsDeleteArtifactThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsDownloadArtifactWhen(httpmock::When);
    impl ActionsDownloadArtifactWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/artifacts/.*/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/artifacts/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/artifacts/.*/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn artifact_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/artifacts/{}/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn archive_format(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/artifacts/.*/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDownloadArtifactThen(httpmock::Then);
    impl ActionsDownloadArtifactThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ActionsGetActionsCacheUsageWhen(httpmock::When);
    impl ActionsGetActionsCacheUsageWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/cache/usage$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/cache/usage$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/cache/usage$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetActionsCacheUsageThen(httpmock::Then);
    impl ActionsGetActionsCacheUsageThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsCacheUsageByRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetActionsCacheListWhen(httpmock::When);
    impl ActionsGetActionsCacheListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/caches$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/actions/caches$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/actions/caches$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::ActionsGetActionsCacheListDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn key(self, value: &str) -> Self {
            Self(self.0.query_param("key", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }

        pub fn sort(self, value: types::ActionsGetActionsCacheListSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct ActionsGetActionsCacheListThen(httpmock::Then);
    impl ActionsGetActionsCacheListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsCacheList) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteActionsCacheByKeyWhen(httpmock::When);
    impl ActionsDeleteActionsCacheByKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/caches$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/actions/caches$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/actions/caches$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn key(self, value: &str) -> Self {
            Self(self.0.query_param("key", value.to_string()))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct ActionsDeleteActionsCacheByKeyThen(httpmock::Then);
    impl ActionsDeleteActionsCacheByKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsCacheList) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteActionsCacheByIdWhen(httpmock::When);
    impl ActionsDeleteActionsCacheByIdWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/caches/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/caches/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/caches/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn cache_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/caches/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteActionsCacheByIdThen(httpmock::Then);
    impl ActionsDeleteActionsCacheByIdThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetJobForWorkflowRunWhen(httpmock::When);
    impl ActionsGetJobForWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/jobs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/jobs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/jobs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn job_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/jobs/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetJobForWorkflowRunThen(httpmock::Then);
    impl ActionsGetJobForWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Job) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDownloadJobLogsForWorkflowRunWhen(httpmock::When);
    impl ActionsDownloadJobLogsForWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/jobs/.*/logs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/jobs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/jobs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn job_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/jobs/{}/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDownloadJobLogsForWorkflowRunThen(httpmock::Then);
    impl ActionsDownloadJobLogsForWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ActionsReRunJobForWorkflowRunWhen(httpmock::When);
    impl ActionsReRunJobForWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/jobs/.*/rerun$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/jobs/.*/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/jobs/.*/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn job_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/jobs/{}/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsReRunJobForWorkflowRunBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsReRunJobForWorkflowRunThen(httpmock::Then);
    impl ActionsReRunJobForWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetCustomOidcSubClaimForRepoWhen(httpmock::When);
    impl ActionsGetCustomOidcSubClaimForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/oidc/customization/sub$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetCustomOidcSubClaimForRepoThen(httpmock::Then);
    impl ActionsGetCustomOidcSubClaimForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OidcCustomSubRepo) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetCustomOidcSubClaimForRepoWhen(httpmock::When);
    impl ActionsSetCustomOidcSubClaimForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/oidc/customization/sub$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/oidc/customization/sub$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsOidcSubjectCustomizationForARepository) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetCustomOidcSubClaimForRepoThen(httpmock::Then);
    impl ActionsSetCustomOidcSubClaimForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRepoOrganizationSecretsWhen(httpmock::When);
    impl ActionsListRepoOrganizationSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/organization-secrets$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/organization-secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/organization-secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoOrganizationSecretsThen(httpmock::Then);
    impl ActionsListRepoOrganizationSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoOrganizationSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRepoOrganizationVariablesWhen(httpmock::When);
    impl ActionsListRepoOrganizationVariablesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/organization-variables$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/organization-variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/organization-variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoOrganizationVariablesThen(httpmock::Then);
    impl ActionsListRepoOrganizationVariablesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoOrganizationVariablesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetGithubActionsPermissionsRepositoryWhen(httpmock::When);
    impl ActionsGetGithubActionsPermissionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/permissions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetGithubActionsPermissionsRepositoryThen(httpmock::Then);
    impl ActionsGetGithubActionsPermissionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsRepositoryPermissions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetGithubActionsPermissionsRepositoryWhen(httpmock::When);
    impl ActionsSetGithubActionsPermissionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/permissions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetGithubActionsPermissionsRepositoryBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetGithubActionsPermissionsRepositoryThen(httpmock::Then);
    impl ActionsSetGithubActionsPermissionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetWorkflowAccessToRepositoryWhen(httpmock::When);
    impl ActionsGetWorkflowAccessToRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/access$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/access$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/access$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetWorkflowAccessToRepositoryThen(httpmock::Then);
    impl ActionsGetWorkflowAccessToRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsWorkflowAccessToRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetWorkflowAccessToRepositoryWhen(httpmock::When);
    impl ActionsSetWorkflowAccessToRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/access$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/access$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/access$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsWorkflowAccessToRepository) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetWorkflowAccessToRepositoryThen(httpmock::Then);
    impl ActionsSetWorkflowAccessToRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetAllowedActionsRepositoryWhen(httpmock::When);
    impl ActionsGetAllowedActionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/selected-actions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetAllowedActionsRepositoryThen(httpmock::Then);
    impl ActionsGetAllowedActionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SelectedActions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetAllowedActionsRepositoryWhen(httpmock::When);
    impl ActionsSetAllowedActionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/selected-actions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/selected-actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::SelectedActions) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetAllowedActionsRepositoryThen(httpmock::Then);
    impl ActionsSetAllowedActionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWhen(httpmock::When);
    impl ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/workflow$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryThen(httpmock::Then);
    impl ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsGetDefaultWorkflowPermissions) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWhen(httpmock::When);
    impl ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/permissions/workflow$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/permissions/workflow$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsSetDefaultWorkflowPermissions) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryThen(httpmock::Then);
    impl ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ActionsListRequiredWorkflowRunsWhen(httpmock::When);
    impl ActionsListRequiredWorkflowRunsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/required_workflows/.*/runs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/required_workflows/.*/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/required_workflows/.*/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn required_workflow_id_for_repo(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/required_workflows/{}/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn actor(self, value: &str) -> Self {
            Self(self.0.query_param("actor", value.to_string()))
        }

        pub fn branch(self, value: &str) -> Self {
            Self(self.0.query_param("branch", value.to_string()))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            Self(self.0.query_param("check_suite_id", value.to_string()))
        }

        pub fn created(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("created", value.to_string()))
        }

        pub fn event(self, value: &str) -> Self {
            Self(self.0.query_param("event", value.to_string()))
        }

        pub fn exclude_pull_requests(self, value: bool) -> Self {
            Self(
                self.0
                    .query_param("exclude_pull_requests", value.to_string()),
            )
        }

        pub fn head_sha(self, value: &str) -> Self {
            Self(self.0.query_param("head_sha", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn status(self, value: types::ActionsListRequiredWorkflowRunsStatus) -> Self {
            Self(self.0.query_param("status", value.to_string()))
        }
    }

    pub struct ActionsListRequiredWorkflowRunsThen(httpmock::Then);
    impl ActionsListRequiredWorkflowRunsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRequiredWorkflowRunsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListSelfHostedRunnersForRepoWhen(httpmock::When);
    impl ActionsListSelfHostedRunnersForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runners$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListSelfHostedRunnersForRepoThen(httpmock::Then);
    impl ActionsListSelfHostedRunnersForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListSelfHostedRunnersForRepoResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRunnerApplicationsForRepoWhen(httpmock::When);
    impl ActionsListRunnerApplicationsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/downloads$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/downloads$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/downloads$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsListRunnerApplicationsForRepoThen(httpmock::Then);
    impl ActionsListRunnerApplicationsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RunnerApplication>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRegistrationTokenForRepoWhen(httpmock::When);
    impl ActionsCreateRegistrationTokenForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/registration-token$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/registration-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/registration-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsCreateRegistrationTokenForRepoThen(httpmock::Then);
    impl ActionsCreateRegistrationTokenForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::AuthenticationToken) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRemoveTokenForRepoWhen(httpmock::When);
    impl ActionsCreateRemoveTokenForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/remove-token$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/remove-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/remove-token$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsCreateRemoveTokenForRepoThen(httpmock::Then);
    impl ActionsCreateRemoveTokenForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::AuthenticationToken) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsGetSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runners/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsGetSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Runner) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteSelfHostedRunnerFromRepoWhen(httpmock::When);
    impl ActionsDeleteSelfHostedRunnerFromRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runners/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteSelfHostedRunnerFromRepoThen(httpmock::Then);
    impl ActionsDeleteSelfHostedRunnerFromRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListLabelsForSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsListLabelsForSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/.*/labels$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsListLabelsForSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsListLabelsForSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsListLabelsForSelfHostedRunnerForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsSetCustomLabelsForSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsSetCustomLabelsForSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/.*/labels$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsSetCustomLabelsForSelfHostedRunnerForRepoBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsSetCustomLabelsForSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsSetCustomLabelsForSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsAddCustomLabelsToSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsAddCustomLabelsToSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/.*/labels$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ActionsAddCustomLabelsToSelfHostedRunnerForRepoBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsAddCustomLabelsToSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsAddCustomLabelsToSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/.*/labels$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoWhen(httpmock::When);
    impl ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runners/.*/labels/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runners/.*/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runners/.*/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn runner_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/{}/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runners/.*/labels/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoThen(httpmock::Then);
    impl ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListWorkflowRunsForRepoWhen(httpmock::When);
    impl ActionsListWorkflowRunsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/actions/runs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/actions/runs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn actor(self, value: &str) -> Self {
            Self(self.0.query_param("actor", value.to_string()))
        }

        pub fn branch(self, value: &str) -> Self {
            Self(self.0.query_param("branch", value.to_string()))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            Self(self.0.query_param("check_suite_id", value.to_string()))
        }

        pub fn created(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("created", value.to_string()))
        }

        pub fn event(self, value: &str) -> Self {
            Self(self.0.query_param("event", value.to_string()))
        }

        pub fn exclude_pull_requests(self, value: bool) -> Self {
            Self(
                self.0
                    .query_param("exclude_pull_requests", value.to_string()),
            )
        }

        pub fn head_sha(self, value: &str) -> Self {
            Self(self.0.query_param("head_sha", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn status(self, value: types::ActionsListWorkflowRunsForRepoStatus) -> Self {
            Self(self.0.query_param("status", value.to_string()))
        }
    }

    pub struct ActionsListWorkflowRunsForRepoThen(httpmock::Then);
    impl ActionsListWorkflowRunsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListWorkflowRunsForRepoResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetWorkflowRunWhen(httpmock::When);
    impl ActionsGetWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn exclude_pull_requests(self, value: bool) -> Self {
            Self(
                self.0
                    .query_param("exclude_pull_requests", value.to_string()),
            )
        }
    }

    pub struct ActionsGetWorkflowRunThen(httpmock::Then);
    impl ActionsGetWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WorkflowRun) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteWorkflowRunWhen(httpmock::When);
    impl ActionsDeleteWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/runs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteWorkflowRunThen(httpmock::Then);
    impl ActionsDeleteWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsGetReviewsForRunWhen(httpmock::When);
    impl ActionsGetReviewsForRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/approvals$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/approvals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/approvals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/approvals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetReviewsForRunThen(httpmock::Then);
    impl ActionsGetReviewsForRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::EnvironmentApprovals>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsApproveWorkflowRunWhen(httpmock::When);
    impl ActionsApproveWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/approve$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/approve$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/approve$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/approve$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsApproveWorkflowRunThen(httpmock::Then);
    impl ActionsApproveWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListWorkflowRunArtifactsWhen(httpmock::When);
    impl ActionsListWorkflowRunArtifactsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/artifacts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/artifacts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/artifacts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/artifacts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListWorkflowRunArtifactsThen(httpmock::Then);
    impl ActionsListWorkflowRunArtifactsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListWorkflowRunArtifactsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetWorkflowRunAttemptWhen(httpmock::When);
    impl ActionsGetWorkflowRunAttemptWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/attempts/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/attempts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/attempts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/attempts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn attempt_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/.*/attempts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn exclude_pull_requests(self, value: bool) -> Self {
            Self(
                self.0
                    .query_param("exclude_pull_requests", value.to_string()),
            )
        }
    }

    pub struct ActionsGetWorkflowRunAttemptThen(httpmock::Then);
    impl ActionsGetWorkflowRunAttemptThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WorkflowRun) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListJobsForWorkflowRunAttemptWhen(httpmock::When);
    impl ActionsListJobsForWorkflowRunAttemptWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/attempts/.*/jobs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/attempts/.*/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/attempts/.*/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/attempts/.*/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn attempt_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/.*/attempts/{}/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListJobsForWorkflowRunAttemptThen(httpmock::Then);
    impl ActionsListJobsForWorkflowRunAttemptThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListJobsForWorkflowRunAttemptResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDownloadWorkflowRunAttemptLogsWhen(httpmock::When);
    impl ActionsDownloadWorkflowRunAttemptLogsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/attempts/.*/logs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/attempts/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/attempts/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/attempts/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn attempt_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/.*/attempts/{}/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDownloadWorkflowRunAttemptLogsThen(httpmock::Then);
    impl ActionsDownloadWorkflowRunAttemptLogsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ActionsCancelWorkflowRunWhen(httpmock::When);
    impl ActionsCancelWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/cancel$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/cancel$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/cancel$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/cancel$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsCancelWorkflowRunThen(httpmock::Then);
    impl ActionsCancelWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsReviewCustomGatesForRunWhen(httpmock::When);
    impl ActionsReviewCustomGatesForRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/deployment_protection_rule$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/deployment_protection_rule$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/deployment_protection_rule$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/deployment_protection_rule$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsReviewCustomGatesForRunBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsReviewCustomGatesForRunThen(httpmock::Then);
    impl ActionsReviewCustomGatesForRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListJobsForWorkflowRunWhen(httpmock::When);
    impl ActionsListJobsForWorkflowRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/jobs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn filter(self, value: types::ActionsListJobsForWorkflowRunFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListJobsForWorkflowRunThen(httpmock::Then);
    impl ActionsListJobsForWorkflowRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListJobsForWorkflowRunResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDownloadWorkflowRunLogsWhen(httpmock::When);
    impl ActionsDownloadWorkflowRunLogsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/logs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDownloadWorkflowRunLogsThen(httpmock::Then);
    impl ActionsDownloadWorkflowRunLogsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ActionsDeleteWorkflowRunLogsWhen(httpmock::When);
    impl ActionsDeleteWorkflowRunLogsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/logs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/logs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteWorkflowRunLogsThen(httpmock::Then);
    impl ActionsDeleteWorkflowRunLogsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetPendingDeploymentsForRunWhen(httpmock::When);
    impl ActionsGetPendingDeploymentsForRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/pending_deployments$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetPendingDeploymentsForRunThen(httpmock::Then);
    impl ActionsGetPendingDeploymentsForRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PendingDeployment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsReviewPendingDeploymentsForRunWhen(httpmock::When);
    impl ActionsReviewPendingDeploymentsForRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/pending_deployments$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/pending_deployments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsReviewPendingDeploymentsForRunBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsReviewPendingDeploymentsForRunThen(httpmock::Then);
    impl ActionsReviewPendingDeploymentsForRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Deployment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsReRunWorkflowWhen(httpmock::When);
    impl ActionsReRunWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/rerun$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/rerun$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsReRunWorkflowBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsReRunWorkflowThen(httpmock::Then);
    impl ActionsReRunWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsReRunWorkflowFailedJobsWhen(httpmock::When);
    impl ActionsReRunWorkflowFailedJobsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/runs/.*/rerun-failed-jobs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/rerun-failed-jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/rerun-failed-jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/rerun-failed-jobs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsReRunWorkflowFailedJobsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsReRunWorkflowFailedJobsThen(httpmock::Then);
    impl ActionsReRunWorkflowFailedJobsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetWorkflowRunUsageWhen(httpmock::When);
    impl ActionsGetWorkflowRunUsageWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/runs/.*/timing$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/runs/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/runs/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/runs/{}/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetWorkflowRunUsageThen(httpmock::Then);
    impl ActionsGetWorkflowRunUsageThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WorkflowRunUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsListRepoSecretsWhen(httpmock::When);
    impl ActionsListRepoSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoSecretsThen(httpmock::Then);
    impl ActionsListRepoSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRepoPublicKeyWhen(httpmock::When);
    impl ActionsGetRepoPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRepoPublicKeyThen(httpmock::Then);
    impl ActionsGetRepoPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRepoSecretWhen(httpmock::When);
    impl ActionsGetRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRepoSecretThen(httpmock::Then);
    impl ActionsGetRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateOrUpdateRepoSecretWhen(httpmock::When);
    impl ActionsCreateOrUpdateRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateOrUpdateRepoSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateOrUpdateRepoSecretThen(httpmock::Then);
    impl ActionsCreateOrUpdateRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsDeleteRepoSecretWhen(httpmock::When);
    impl ActionsDeleteRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteRepoSecretThen(httpmock::Then);
    impl ActionsDeleteRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListRepoVariablesWhen(httpmock::When);
    impl ActionsListRepoVariablesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/variables$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoVariablesThen(httpmock::Then);
    impl ActionsListRepoVariablesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoVariablesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateRepoVariableWhen(httpmock::When);
    impl ActionsCreateRepoVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/variables$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateRepoVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateRepoVariableThen(httpmock::Then);
    impl ActionsCreateRepoVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetRepoVariableWhen(httpmock::When);
    impl ActionsGetRepoVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/variables/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetRepoVariableThen(httpmock::Then);
    impl ActionsGetRepoVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsVariable) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteRepoVariableWhen(httpmock::When);
    impl ActionsDeleteRepoVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/variables/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteRepoVariableThen(httpmock::Then);
    impl ActionsDeleteRepoVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsUpdateRepoVariableWhen(httpmock::When);
    impl ActionsUpdateRepoVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/variables/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsUpdateRepoVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsUpdateRepoVariableThen(httpmock::Then);
    impl ActionsUpdateRepoVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListRepoWorkflowsWhen(httpmock::When);
    impl ActionsListRepoWorkflowsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/actions/workflows$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListRepoWorkflowsThen(httpmock::Then);
    impl ActionsListRepoWorkflowsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListRepoWorkflowsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetWorkflowWhen(httpmock::When);
    impl ActionsGetWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/actions/workflows/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsGetWorkflowWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetWorkflowThen(httpmock::Then);
    impl ActionsGetWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Workflow) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDisableWorkflowWhen(httpmock::When);
    impl ActionsDisableWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/workflows/.*/disable$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*/disable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*/disable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsDisableWorkflowWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}/disable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDisableWorkflowThen(httpmock::Then);
    impl ActionsDisableWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsCreateWorkflowDispatchWhen(httpmock::When);
    impl ActionsCreateWorkflowDispatchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/workflows/.*/dispatches$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*/dispatches$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*/dispatches$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsCreateWorkflowDispatchWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}/dispatches$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateWorkflowDispatchBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateWorkflowDispatchThen(httpmock::Then);
    impl ActionsCreateWorkflowDispatchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsEnableWorkflowWhen(httpmock::When);
    impl ActionsEnableWorkflowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/workflows/.*/enable$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*/enable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*/enable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsEnableWorkflowWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}/enable$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsEnableWorkflowThen(httpmock::Then);
    impl ActionsEnableWorkflowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListWorkflowRunsWhen(httpmock::When);
    impl ActionsListWorkflowRunsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/workflows/.*/runs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsListWorkflowRunsWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}/runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn actor(self, value: &str) -> Self {
            Self(self.0.query_param("actor", value.to_string()))
        }

        pub fn branch(self, value: &str) -> Self {
            Self(self.0.query_param("branch", value.to_string()))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            Self(self.0.query_param("check_suite_id", value.to_string()))
        }

        pub fn created(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("created", value.to_string()))
        }

        pub fn event(self, value: &str) -> Self {
            Self(self.0.query_param("event", value.to_string()))
        }

        pub fn exclude_pull_requests(self, value: bool) -> Self {
            Self(
                self.0
                    .query_param("exclude_pull_requests", value.to_string()),
            )
        }

        pub fn head_sha(self, value: &str) -> Self {
            Self(self.0.query_param("head_sha", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn status(self, value: types::ActionsListWorkflowRunsStatus) -> Self {
            Self(self.0.query_param("status", value.to_string()))
        }
    }

    pub struct ActionsListWorkflowRunsThen(httpmock::Then);
    impl ActionsListWorkflowRunsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListWorkflowRunsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetWorkflowUsageWhen(httpmock::When);
    impl ActionsGetWorkflowUsageWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/actions/workflows/.*/timing$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/actions/workflows/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/actions/workflows/.*/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn workflow_id(self, value: &types::ActionsGetWorkflowUsageWorkflowId) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/actions/workflows/{}/timing$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetWorkflowUsageThen(httpmock::Then);
    impl ActionsGetWorkflowUsageThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WorkflowUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListAssigneesWhen(httpmock::When);
    impl IssuesListAssigneesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/assignees$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/assignees$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/assignees$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListAssigneesThen(httpmock::Then);
    impl IssuesListAssigneesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCheckUserCanBeAssignedWhen(httpmock::When);
    impl IssuesCheckUserCanBeAssignedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/assignees/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/assignees/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/assignees/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn assignee(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/assignees/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesCheckUserCanBeAssignedThen(httpmock::Then);
    impl IssuesCheckUserCanBeAssignedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListAutolinksWhen(httpmock::When);
    impl ReposListAutolinksWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/autolinks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/autolinks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/autolinks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }
    }

    pub struct ReposListAutolinksThen(httpmock::Then);
    impl ReposListAutolinksThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Autolink>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateAutolinkWhen(httpmock::When);
    impl ReposCreateAutolinkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/autolinks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/autolinks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/autolinks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateAutolinkBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateAutolinkThen(httpmock::Then);
    impl ReposCreateAutolinkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Autolink) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAutolinkWhen(httpmock::When);
    impl ReposGetAutolinkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/autolinks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/autolinks/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/autolinks/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn autolink_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/autolinks/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAutolinkThen(httpmock::Then);
    impl ReposGetAutolinkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Autolink) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteAutolinkWhen(httpmock::When);
    impl ReposDeleteAutolinkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/autolinks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/autolinks/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/autolinks/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn autolink_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/autolinks/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteAutolinkThen(httpmock::Then);
    impl ReposDeleteAutolinkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposEnableAutomatedSecurityFixesWhen(httpmock::When);
    impl ReposEnableAutomatedSecurityFixesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/automated-security-fixes$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/automated-security-fixes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/automated-security-fixes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposEnableAutomatedSecurityFixesThen(httpmock::Then);
    impl ReposEnableAutomatedSecurityFixesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposDisableAutomatedSecurityFixesWhen(httpmock::When);
    impl ReposDisableAutomatedSecurityFixesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/automated-security-fixes$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/automated-security-fixes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/automated-security-fixes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDisableAutomatedSecurityFixesThen(httpmock::Then);
    impl ReposDisableAutomatedSecurityFixesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListBranchesWhen(httpmock::When);
    impl ReposListBranchesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/branches$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/branches$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/branches$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn protected(self, value: bool) -> Self {
            Self(self.0.query_param("protected", value.to_string()))
        }
    }

    pub struct ReposListBranchesThen(httpmock::Then);
    impl ReposListBranchesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ShortBranch>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetBranchWhen(httpmock::When);
    impl ReposGetBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/branches/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/branches/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/branches/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/branches/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetBranchThen(httpmock::Then);
    impl ReposGetBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::BranchWithProtection) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetBranchProtectionWhen(httpmock::When);
    impl ReposGetBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetBranchProtectionThen(httpmock::Then);
    impl ReposGetBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::BranchProtection) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateBranchProtectionWhen(httpmock::When);
    impl ReposUpdateBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateBranchProtectionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateBranchProtectionThen(httpmock::Then);
    impl ReposUpdateBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranch) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteBranchProtectionWhen(httpmock::When);
    impl ReposDeleteBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteBranchProtectionThen(httpmock::Then);
    impl ReposDeleteBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAdminBranchProtectionWhen(httpmock::When);
    impl ReposGetAdminBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/branches/.*/protection/enforce_admins$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAdminBranchProtectionThen(httpmock::Then);
    impl ReposGetAdminBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchAdminEnforced) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposSetAdminBranchProtectionWhen(httpmock::When);
    impl ReposSetAdminBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/branches/.*/protection/enforce_admins$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposSetAdminBranchProtectionThen(httpmock::Then);
    impl ReposSetAdminBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchAdminEnforced) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteAdminBranchProtectionWhen(httpmock::When);
    impl ReposDeleteAdminBranchProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/branches/.*/protection/enforce_admins$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/enforce_admins$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteAdminBranchProtectionThen(httpmock::Then);
    impl ReposDeleteAdminBranchProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetPullRequestReviewProtectionWhen(httpmock::When);
    impl ReposGetPullRequestReviewProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_pull_request_reviews$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetPullRequestReviewProtectionThen(httpmock::Then);
    impl ReposGetPullRequestReviewProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchPullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeletePullRequestReviewProtectionWhen(httpmock::When);
    impl ReposDeletePullRequestReviewProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_pull_request_reviews$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeletePullRequestReviewProtectionThen(httpmock::Then);
    impl ReposDeletePullRequestReviewProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdatePullRequestReviewProtectionWhen(httpmock::When);
    impl ReposUpdatePullRequestReviewProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_pull_request_reviews$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_pull_request_reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdatePullRequestReviewProtectionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdatePullRequestReviewProtectionThen(httpmock::Then);
    impl ReposUpdatePullRequestReviewProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchPullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCommitSignatureProtectionWhen(httpmock::When);
    impl ReposGetCommitSignatureProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/required_signatures$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCommitSignatureProtectionThen(httpmock::Then);
    impl ReposGetCommitSignatureProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchAdminEnforced) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateCommitSignatureProtectionWhen(httpmock::When);
    impl ReposCreateCommitSignatureProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/required_signatures$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposCreateCommitSignatureProtectionThen(httpmock::Then);
    impl ReposCreateCommitSignatureProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ProtectedBranchAdminEnforced) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteCommitSignatureProtectionWhen(httpmock::When);
    impl ReposDeleteCommitSignatureProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/required_signatures$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_signatures$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteCommitSignatureProtectionThen(httpmock::Then);
    impl ReposDeleteCommitSignatureProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetStatusChecksProtectionWhen(httpmock::When);
    impl ReposGetStatusChecksProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetStatusChecksProtectionThen(httpmock::Then);
    impl ReposGetStatusChecksProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::StatusCheckPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveStatusCheckProtectionWhen(httpmock::When);
    impl ReposRemoveStatusCheckProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposRemoveStatusCheckProtectionThen(httpmock::Then);
    impl ReposRemoveStatusCheckProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposUpdateStatusCheckProtectionWhen(httpmock::When);
    impl ReposUpdateStatusCheckProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateStatusCheckProtectionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateStatusCheckProtectionThen(httpmock::Then);
    impl ReposUpdateStatusCheckProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::StatusCheckPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAllStatusCheckContextsWhen(httpmock::When);
    impl ReposGetAllStatusCheckContextsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks/contexts$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAllStatusCheckContextsThen(httpmock::Then);
    impl ReposGetAllStatusCheckContextsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposSetStatusCheckContextsWhen(httpmock::When);
    impl ReposSetStatusCheckContextsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks/contexts$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposSetStatusCheckContextsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposSetStatusCheckContextsThen(httpmock::Then);
    impl ReposSetStatusCheckContextsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposAddStatusCheckContextsWhen(httpmock::When);
    impl ReposAddStatusCheckContextsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks/contexts$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposAddStatusCheckContextsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposAddStatusCheckContextsThen(httpmock::Then);
    impl ReposAddStatusCheckContextsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveStatusCheckContextsWhen(httpmock::When);
    impl ReposRemoveStatusCheckContextsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/branches/.*/protection/required_status_checks/contexts$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/required_status_checks/contexts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposRemoveStatusCheckContextsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposRemoveStatusCheckContextsThen(httpmock::Then);
    impl ReposRemoveStatusCheckContextsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<String>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAccessRestrictionsWhen(httpmock::When);
    impl ReposGetAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAccessRestrictionsThen(httpmock::Then);
    impl ReposGetAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::BranchRestrictionPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteAccessRestrictionsWhen(httpmock::When);
    impl ReposDeleteAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteAccessRestrictionsThen(httpmock::Then);
    impl ReposDeleteAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetAppsWithAccessToProtectedBranchWhen(httpmock::When);
    impl ReposGetAppsWithAccessToProtectedBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/apps$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAppsWithAccessToProtectedBranchThen(httpmock::Then);
    impl ReposGetAppsWithAccessToProtectedBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Integration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposSetAppAccessRestrictionsWhen(httpmock::When);
    impl ReposSetAppAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/apps$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposSetAppAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposSetAppAccessRestrictionsThen(httpmock::Then);
    impl ReposSetAppAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Integration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposAddAppAccessRestrictionsWhen(httpmock::When);
    impl ReposAddAppAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/apps$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposAddAppAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposAddAppAccessRestrictionsThen(httpmock::Then);
    impl ReposAddAppAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Integration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveAppAccessRestrictionsWhen(httpmock::When);
    impl ReposRemoveAppAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/apps$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposRemoveAppAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposRemoveAppAccessRestrictionsThen(httpmock::Then);
    impl ReposRemoveAppAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Integration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetTeamsWithAccessToProtectedBranchWhen(httpmock::When);
    impl ReposGetTeamsWithAccessToProtectedBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/teams$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetTeamsWithAccessToProtectedBranchThen(httpmock::Then);
    impl ReposGetTeamsWithAccessToProtectedBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposSetTeamAccessRestrictionsWhen(httpmock::When);
    impl ReposSetTeamAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/teams$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposSetTeamAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposSetTeamAccessRestrictionsThen(httpmock::Then);
    impl ReposSetTeamAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposAddTeamAccessRestrictionsWhen(httpmock::When);
    impl ReposAddTeamAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/teams$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposAddTeamAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposAddTeamAccessRestrictionsThen(httpmock::Then);
    impl ReposAddTeamAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveTeamAccessRestrictionsWhen(httpmock::When);
    impl ReposRemoveTeamAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/teams$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/teams$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposRemoveTeamAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposRemoveTeamAccessRestrictionsThen(httpmock::Then);
    impl ReposRemoveTeamAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetUsersWithAccessToProtectedBranchWhen(httpmock::When);
    impl ReposGetUsersWithAccessToProtectedBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/users$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetUsersWithAccessToProtectedBranchThen(httpmock::Then);
    impl ReposGetUsersWithAccessToProtectedBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposSetUserAccessRestrictionsWhen(httpmock::When);
    impl ReposSetUserAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/users$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposSetUserAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposSetUserAccessRestrictionsThen(httpmock::Then);
    impl ReposSetUserAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposAddUserAccessRestrictionsWhen(httpmock::When);
    impl ReposAddUserAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/users$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposAddUserAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposAddUserAccessRestrictionsThen(httpmock::Then);
    impl ReposAddUserAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveUserAccessRestrictionsWhen(httpmock::When);
    impl ReposRemoveUserAccessRestrictionsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/branches/.*/protection/restrictions/users$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/protection/restrictions/users$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposRemoveUserAccessRestrictionsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposRemoveUserAccessRestrictionsThen(httpmock::Then);
    impl ReposRemoveUserAccessRestrictionsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRenameBranchWhen(httpmock::When);
    impl ReposRenameBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/branches/.*/rename$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/branches/.*/rename$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/branches/.*/rename$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/branches/{}/rename$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposRenameBranchBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposRenameBranchThen(httpmock::Then);
    impl ReposRenameBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::BranchWithProtection) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksCreateWhen(httpmock::When);
    impl ChecksCreateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/check-runs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/check-runs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/check-runs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ChecksCreateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ChecksCreateThen(httpmock::Then);
    impl ChecksCreateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::CheckRun) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksGetWhen(httpmock::When);
    impl ChecksGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/check-runs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/check-runs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/check-runs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/check-runs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ChecksGetThen(httpmock::Then);
    impl ChecksGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CheckRun) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksUpdateWhen(httpmock::When);
    impl ChecksUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/check-runs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/check-runs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/check-runs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/check-runs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ChecksUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ChecksUpdateThen(httpmock::Then);
    impl ChecksUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CheckRun) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksListAnnotationsWhen(httpmock::When);
    impl ChecksListAnnotationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/check-runs/.*/annotations$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-runs/.*/annotations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-runs/.*/annotations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/check-runs/{}/annotations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ChecksListAnnotationsThen(httpmock::Then);
    impl ChecksListAnnotationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CheckAnnotation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksRerequestRunWhen(httpmock::When);
    impl ChecksRerequestRunWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/check-runs/.*/rerequest$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-runs/.*/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-runs/.*/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_run_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/check-runs/{}/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ChecksRerequestRunThen(httpmock::Then);
    impl ChecksRerequestRunThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksCreateSuiteWhen(httpmock::When);
    impl ChecksCreateSuiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/check-suites$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/check-suites$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/check-suites$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ChecksCreateSuiteBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ChecksCreateSuiteThen(httpmock::Then);
    impl ChecksCreateSuiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CheckSuite) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::CheckSuite) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksSetSuitesPreferencesWhen(httpmock::When);
    impl ChecksSetSuitesPreferencesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/repos/.*/.*/check-suites/preferences$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-suites/preferences$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-suites/preferences$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ChecksSetSuitesPreferencesBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ChecksSetSuitesPreferencesThen(httpmock::Then);
    impl ChecksSetSuitesPreferencesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CheckSuitePreference) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksGetSuiteWhen(httpmock::When);
    impl ChecksGetSuiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/check-suites/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-suites/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-suites/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/check-suites/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ChecksGetSuiteThen(httpmock::Then);
    impl ChecksGetSuiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CheckSuite) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksListForSuiteWhen(httpmock::When);
    impl ChecksListForSuiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/check-suites/.*/check-runs$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-suites/.*/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-suites/.*/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/check-suites/{}/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_name(self, value: &str) -> Self {
            Self(self.0.query_param("check_name", value.to_string()))
        }

        pub fn filter(self, value: types::ChecksListForSuiteFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn status(self, value: types::ChecksListForSuiteStatus) -> Self {
            Self(self.0.query_param("status", value.to_string()))
        }
    }

    pub struct ChecksListForSuiteThen(httpmock::Then);
    impl ChecksListForSuiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ChecksListForSuiteResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksRerequestSuiteWhen(httpmock::When);
    impl ChecksRerequestSuiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/check-suites/.*/rerequest$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/check-suites/.*/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/check-suites/.*/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn check_suite_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/check-suites/{}/rerequest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ChecksRerequestSuiteThen(httpmock::Then);
    impl ChecksRerequestSuiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningListAlertsForRepoWhen(httpmock::When);
    impl CodeScanningListAlertsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::CodeScanningListAlertsForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn ref_(self, value: &types::CodeScanningRef) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }

        pub fn severity(self, value: types::CodeScanningAlertSeverity) -> Self {
            Self(self.0.query_param("severity", value.to_string()))
        }

        pub fn sort(self, value: types::CodeScanningListAlertsForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::CodeScanningAlertState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }

        pub fn tool_guid(self, value: &types::CodeScanningAnalysisToolGuid) -> Self {
            Self(self.0.query_param("tool_guid", value.to_string()))
        }

        pub fn tool_name(self, value: &types::CodeScanningAnalysisToolName) -> Self {
            Self(self.0.query_param("tool_name", value.to_string()))
        }
    }

    pub struct CodeScanningListAlertsForRepoThen(httpmock::Then);
    impl CodeScanningListAlertsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeScanningAlertItems>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningListAlertsForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningGetAlertWhen(httpmock::When);
    impl CodeScanningGetAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/alerts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningGetAlertThen(httpmock::Then);
    impl CodeScanningGetAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::CodeScanningGetAlertResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningUpdateAlertWhen(httpmock::When);
    impl CodeScanningUpdateAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/alerts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodeScanningUpdateAlertBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodeScanningUpdateAlertThen(httpmock::Then);
    impl CodeScanningUpdateAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::CodeScanningUpdateAlertResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningListAlertInstancesWhen(httpmock::When);
    impl CodeScanningListAlertInstancesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/alerts/.*/instances$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/alerts/.*/instances$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/alerts/.*/instances$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/alerts/{}/instances$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn ref_(self, value: &types::CodeScanningRef) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct CodeScanningListAlertInstancesThen(httpmock::Then);
    impl CodeScanningListAlertInstancesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeScanningAlertInstance>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningListAlertInstancesResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningListRecentAnalysesWhen(httpmock::When);
    impl CodeScanningListRecentAnalysesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/analyses$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/analyses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/analyses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::CodeScanningListRecentAnalysesDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn ref_(self, value: &types::CodeScanningRef) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }

        pub fn sarif_id(self, value: &types::CodeScanningAnalysisSarifId) -> Self {
            Self(self.0.query_param("sarif_id", value.to_string()))
        }

        pub fn sort(self, value: types::CodeScanningListRecentAnalysesSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn tool_guid(self, value: &types::CodeScanningAnalysisToolGuid) -> Self {
            Self(self.0.query_param("tool_guid", value.to_string()))
        }

        pub fn tool_name(self, value: &types::CodeScanningAnalysisToolName) -> Self {
            Self(self.0.query_param("tool_name", value.to_string()))
        }
    }

    pub struct CodeScanningListRecentAnalysesThen(httpmock::Then);
    impl CodeScanningListRecentAnalysesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeScanningAnalysis>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningListRecentAnalysesResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningGetAnalysisWhen(httpmock::When);
    impl CodeScanningGetAnalysisWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/analyses/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/analyses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/analyses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn analysis_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/analyses/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningGetAnalysisThen(httpmock::Then);
    impl CodeScanningGetAnalysisThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningAnalysis) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::CodeScanningGetAnalysisResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningDeleteAnalysisWhen(httpmock::When);
    impl CodeScanningDeleteAnalysisWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/analyses/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/analyses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/analyses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn analysis_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/analyses/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn confirm_delete(self, value: &str) -> Self {
            Self(self.0.query_param("confirm_delete", value.to_string()))
        }
    }

    pub struct CodeScanningDeleteAnalysisThen(httpmock::Then);
    impl CodeScanningDeleteAnalysisThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningAnalysisDeletion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningDeleteAnalysisResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningListCodeqlDatabasesWhen(httpmock::When);
    impl CodeScanningListCodeqlDatabasesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/codeql/databases$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/codeql/databases$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/codeql/databases$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningListCodeqlDatabasesThen(httpmock::Then);
    impl CodeScanningListCodeqlDatabasesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeScanningCodeqlDatabase>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningListCodeqlDatabasesResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningGetCodeqlDatabaseWhen(httpmock::When);
    impl CodeScanningGetCodeqlDatabaseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/codeql/databases/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/codeql/databases/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/codeql/databases/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn language(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/codeql/databases/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningGetCodeqlDatabaseThen(httpmock::Then);
    impl CodeScanningGetCodeqlDatabaseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningCodeqlDatabase) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningGetCodeqlDatabaseResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningGetDefaultSetupWhen(httpmock::When);
    impl CodeScanningGetDefaultSetupWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/default-setup$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/default-setup$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/default-setup$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningGetDefaultSetupThen(httpmock::Then);
    impl CodeScanningGetDefaultSetupThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningDefaultSetup) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningGetDefaultSetupResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningUpdateDefaultSetupWhen(httpmock::When);
    impl CodeScanningUpdateDefaultSetupWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/repos/.*/.*/code-scanning/default-setup$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/default-setup$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/default-setup$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodeScanningDefaultSetupUpdate) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodeScanningUpdateDefaultSetupThen(httpmock::Then);
    impl CodeScanningUpdateDefaultSetupThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::CodeScanningDefaultSetupUpdateResponse) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodeScanningUpdateDefaultSetupResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningUploadSarifWhen(httpmock::When);
    impl CodeScanningUploadSarifWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/sarifs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/sarifs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/sarifs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodeScanningUploadSarifBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodeScanningUploadSarifThen(httpmock::Then);
    impl CodeScanningUploadSarifThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::CodeScanningSarifsReceipt) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn payload_too_large(self) -> Self {
            Self(self.0.status(413u16))
        }

        pub fn service_unavailable(self, value: &types::CodeScanningUploadSarifResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodeScanningGetSarifWhen(httpmock::When);
    impl CodeScanningGetSarifWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/code-scanning/sarifs/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/code-scanning/sarifs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/code-scanning/sarifs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn sarif_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/code-scanning/sarifs/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodeScanningGetSarifThen(httpmock::Then);
    impl CodeScanningGetSarifThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeScanningSarifsStatus) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn service_unavailable(self, value: &types::CodeScanningGetSarifResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCodeownersErrorsWhen(httpmock::When);
    impl ReposCodeownersErrorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codeowners/errors$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codeowners/errors$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codeowners/errors$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct ReposCodeownersErrorsThen(httpmock::Then);
    impl ReposCodeownersErrorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodeownersErrors) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct CodespacesListInRepositoryForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesListInRepositoryForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/codespaces$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/codespaces$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListInRepositoryForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesListInRepositoryForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::CodespacesListInRepositoryForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateWithRepoForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesCreateWithRepoForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/codespaces$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/codespaces$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesCreateWithRepoForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateWithRepoForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesCreateWithRepoForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodespacesCreateWithRepoForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/codespaces/devcontainers$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/devcontainers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/devcontainers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesRepoMachinesForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesRepoMachinesForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codespaces/machines$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/machines$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/machines$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn client_ip(self, value: &str) -> Self {
            Self(self.0.query_param("client_ip", value.to_string()))
        }

        pub fn location(self, value: &str) -> Self {
            Self(self.0.query_param("location", value.to_string()))
        }
    }

    pub struct CodespacesRepoMachinesForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesRepoMachinesForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesRepoMachinesForAuthenticatedUserResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesPreFlightWithRepoForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesPreFlightWithRepoForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codespaces/new$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/codespaces/new$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/codespaces/new$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn client_ip(self, value: &str) -> Self {
            Self(self.0.query_param("client_ip", value.to_string()))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct CodespacesPreFlightWithRepoForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesPreFlightWithRepoForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::CodespacesPreFlightWithRepoForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListRepoSecretsWhen(httpmock::When);
    impl CodespacesListRepoSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/codespaces/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListRepoSecretsThen(httpmock::Then);
    impl CodespacesListRepoSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListRepoSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetRepoPublicKeyWhen(httpmock::When);
    impl CodespacesGetRepoPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/codespaces/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetRepoPublicKeyThen(httpmock::Then);
    impl CodespacesGetRepoPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetRepoSecretWhen(httpmock::When);
    impl CodespacesGetRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/codespaces/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetRepoSecretThen(httpmock::Then);
    impl CodespacesGetRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepoCodespacesSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateOrUpdateRepoSecretWhen(httpmock::When);
    impl CodespacesCreateOrUpdateRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/codespaces/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesCreateOrUpdateRepoSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateOrUpdateRepoSecretThen(httpmock::Then);
    impl CodespacesCreateOrUpdateRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct CodespacesDeleteRepoSecretWhen(httpmock::When);
    impl CodespacesDeleteRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/codespaces/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/codespaces/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/codespaces/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesDeleteRepoSecretThen(httpmock::Then);
    impl CodespacesDeleteRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListCollaboratorsWhen(httpmock::When);
    impl ReposListCollaboratorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/collaborators$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/collaborators$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/collaborators$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn affiliation(self, value: types::ReposListCollaboratorsAffiliation) -> Self {
            Self(self.0.query_param("affiliation", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn permission(self, value: types::ReposListCollaboratorsPermission) -> Self {
            Self(self.0.query_param("permission", value.to_string()))
        }
    }

    pub struct ReposListCollaboratorsThen(httpmock::Then);
    impl ReposListCollaboratorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Collaborator>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCheckCollaboratorWhen(httpmock::When);
    impl ReposCheckCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/collaborators/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposCheckCollaboratorThen(httpmock::Then);
    impl ReposCheckCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct ReposAddCollaboratorWhen(httpmock::When);
    impl ReposAddCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/collaborators/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposAddCollaboratorBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposAddCollaboratorThen(httpmock::Then);
    impl ReposAddCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RepositoryInvitation) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRemoveCollaboratorWhen(httpmock::When);
    impl ReposRemoveCollaboratorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/collaborators/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/collaborators/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/collaborators/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposRemoveCollaboratorThen(httpmock::Then);
    impl ReposRemoveCollaboratorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetCollaboratorPermissionLevelWhen(httpmock::When);
    impl ReposGetCollaboratorPermissionLevelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/collaborators/.*/permission$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/collaborators/.*/permission$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/collaborators/.*/permission$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/collaborators/{}/permission$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCollaboratorPermissionLevelThen(httpmock::Then);
    impl ReposGetCollaboratorPermissionLevelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryCollaboratorPermission) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListCommitCommentsForRepoWhen(httpmock::When);
    impl ReposListCommitCommentsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/comments$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/comments$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListCommitCommentsForRepoThen(httpmock::Then);
    impl ReposListCommitCommentsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CommitComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCommitCommentWhen(httpmock::When);
    impl ReposGetCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/comments/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCommitCommentThen(httpmock::Then);
    impl ReposGetCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CommitComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteCommitCommentWhen(httpmock::When);
    impl ReposDeleteCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/comments/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteCommitCommentThen(httpmock::Then);
    impl ReposDeleteCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateCommitCommentWhen(httpmock::When);
    impl ReposUpdateCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/comments/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/comments/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateCommitCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateCommitCommentThen(httpmock::Then);
    impl ReposUpdateCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CommitComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForCommitCommentWhen(httpmock::When);
    impl ReactionsListForCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/comments/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForCommitCommentContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForCommitCommentThen(httpmock::Then);
    impl ReactionsListForCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForCommitCommentWhen(httpmock::When);
    impl ReactionsCreateForCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/comments/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForCommitCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForCommitCommentThen(httpmock::Then);
    impl ReactionsCreateForCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForCommitCommentWhen(httpmock::When);
    impl ReactionsDeleteForCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/comments/.*/reactions/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/comments/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/comments/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForCommitCommentThen(httpmock::Then);
    impl ReactionsDeleteForCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListCommitsWhen(httpmock::When);
    impl ReposListCommitsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/commits$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/commits$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn author(self, value: &str) -> Self {
            Self(self.0.query_param("author", value.to_string()))
        }

        pub fn committer(self, value: &str) -> Self {
            Self(self.0.query_param("committer", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn path(self, value: &str) -> Self {
            Self(self.0.query_param("path", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sha(self, value: &str) -> Self {
            Self(self.0.query_param("sha", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn until(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("until", value.to_string()))
        }
    }

    pub struct ReposListCommitsThen(httpmock::Then);
    impl ReposListCommitsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Commit>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListBranchesForHeadCommitWhen(httpmock::When);
    impl ReposListBranchesForHeadCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/commits/.*/branches-where-head$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/branches-where-head$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/branches-where-head$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn commit_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/{}/branches-where-head$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposListBranchesForHeadCommitThen(httpmock::Then);
    impl ReposListBranchesForHeadCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::BranchShort>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListCommentsForCommitWhen(httpmock::When);
    impl ReposListCommentsForCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn commit_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListCommentsForCommitThen(httpmock::Then);
    impl ReposListCommentsForCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CommitComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateCommitCommentWhen(httpmock::When);
    impl ReposCreateCommitCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn commit_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateCommitCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateCommitCommentThen(httpmock::Then);
    impl ReposCreateCommitCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::CommitComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListPullRequestsAssociatedWithCommitWhen(httpmock::When);
    impl ReposListPullRequestsAssociatedWithCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*/pulls$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/pulls$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/pulls$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn commit_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/{}/pulls$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListPullRequestsAssociatedWithCommitThen(httpmock::Then);
    impl ReposListPullRequestsAssociatedWithCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PullRequestSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCommitWhen(httpmock::When);
    impl ReposGetCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/commits/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/commits/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/commits/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposGetCommitThen(httpmock::Then);
    impl ReposGetCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Commit) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::ReposGetCommitResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksListForRefWhen(httpmock::When);
    impl ChecksListForRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/commits/.*/check-runs$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/.*/check-runs$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn app_id(self, value: i64) -> Self {
            Self(self.0.query_param("app_id", value.to_string()))
        }

        pub fn check_name(self, value: &str) -> Self {
            Self(self.0.query_param("check_name", value.to_string()))
        }

        pub fn filter(self, value: types::ChecksListForRefFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn status(self, value: types::ChecksListForRefStatus) -> Self {
            Self(self.0.query_param("status", value.to_string()))
        }
    }

    pub struct ChecksListForRefThen(httpmock::Then);
    impl ChecksListForRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ChecksListForRefResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ChecksListSuitesForRefWhen(httpmock::When);
    impl ChecksListSuitesForRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/commits/.*/check-suites$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/check-suites$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/check-suites$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/.*/check-suites$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn app_id(self, value: i64) -> Self {
            Self(self.0.query_param("app_id", value.to_string()))
        }

        pub fn check_name(self, value: &str) -> Self {
            Self(self.0.query_param("check_name", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ChecksListSuitesForRefThen(httpmock::Then);
    impl ChecksListSuitesForRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ChecksListSuitesForRefResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCombinedStatusForRefWhen(httpmock::When);
    impl ReposGetCombinedStatusForRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*/status$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/status$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/status$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/.*/status$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposGetCombinedStatusForRefThen(httpmock::Then);
    impl ReposGetCombinedStatusForRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CombinedCommitStatus) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListCommitStatusesForRefWhen(httpmock::When);
    impl ReposListCommitStatusesForRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/commits/.*/statuses$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/commits/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/commits/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/commits/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListCommitStatusesForRefThen(httpmock::Then);
    impl ReposListCommitStatusesForRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Status>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCommunityProfileMetricsWhen(httpmock::When);
    impl ReposGetCommunityProfileMetricsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/community/profile$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/community/profile$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/community/profile$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCommunityProfileMetricsThen(httpmock::Then);
    impl ReposGetCommunityProfileMetricsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CommunityProfile) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCompareCommitsWhen(httpmock::When);
    impl ReposCompareCommitsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/compare/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/compare/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/compare/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn basehead(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/compare/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposCompareCommitsThen(httpmock::Then);
    impl ReposCompareCommitsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CommitComparison) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::ReposCompareCommitsResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetContentWhen(httpmock::When);
    impl ReposGetContentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/contents/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn path(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/contents/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct ReposGetContentThen(httpmock::Then);
    impl ReposGetContentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReposGetContentResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }
    }

    pub struct ReposCreateOrUpdateFileContentsWhen(httpmock::When);
    impl ReposCreateOrUpdateFileContentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/contents/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn path(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/contents/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateOrUpdateFileContentsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateOrUpdateFileContentsThen(httpmock::Then);
    impl ReposCreateOrUpdateFileContentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::FileCommit) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::FileCommit) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteFileWhen(httpmock::When);
    impl ReposDeleteFileWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/contents/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/contents/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn path(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/contents/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposDeleteFileBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposDeleteFileThen(httpmock::Then);
    impl ReposDeleteFileThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::FileCommit) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::ReposDeleteFileResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListContributorsWhen(httpmock::When);
    impl ReposListContributorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/contributors$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/contributors$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/contributors$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn anon(self, value: &str) -> Self {
            Self(self.0.query_param("anon", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListContributorsThen(httpmock::Then);
    impl ReposListContributorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Contributor>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotListAlertsForRepoWhen(httpmock::When);
    impl DependabotListAlertsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/dependabot/alerts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::DependabotListAlertsForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn ecosystem(self, value: &str) -> Self {
            Self(self.0.query_param("ecosystem", value.to_string()))
        }

        pub fn first(self, value: i64) -> Self {
            Self(self.0.query_param("first", value.to_string()))
        }

        pub fn last(self, value: i64) -> Self {
            Self(self.0.query_param("last", value.to_string()))
        }

        pub fn manifest(self, value: &str) -> Self {
            Self(self.0.query_param("manifest", value.to_string()))
        }

        pub fn package(self, value: &str) -> Self {
            Self(self.0.query_param("package", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn scope(self, value: types::DependabotListAlertsForRepoScope) -> Self {
            Self(self.0.query_param("scope", value.to_string()))
        }

        pub fn severity(self, value: &str) -> Self {
            Self(self.0.query_param("severity", value.to_string()))
        }

        pub fn sort(self, value: types::DependabotListAlertsForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: &str) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct DependabotListAlertsForRepoThen(httpmock::Then);
    impl DependabotListAlertsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DependabotAlert>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotGetAlertWhen(httpmock::When);
    impl DependabotGetAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependabot/alerts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependabot/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotGetAlertThen(httpmock::Then);
    impl DependabotGetAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotUpdateAlertWhen(httpmock::When);
    impl DependabotUpdateAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependabot/alerts/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependabot/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DependabotUpdateAlertBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct DependabotUpdateAlertThen(httpmock::Then);
    impl DependabotUpdateAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotListRepoSecretsWhen(httpmock::When);
    impl DependabotListRepoSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/dependabot/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct DependabotListRepoSecretsThen(httpmock::Then);
    impl DependabotListRepoSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotListRepoSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotGetRepoPublicKeyWhen(httpmock::When);
    impl DependabotGetRepoPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/dependabot/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotGetRepoPublicKeyThen(httpmock::Then);
    impl DependabotGetRepoPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotGetRepoSecretWhen(httpmock::When);
    impl DependabotGetRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependabot/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotGetRepoSecretThen(httpmock::Then);
    impl DependabotGetRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependabotSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependabotCreateOrUpdateRepoSecretWhen(httpmock::When);
    impl DependabotCreateOrUpdateRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependabot/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DependabotCreateOrUpdateRepoSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct DependabotCreateOrUpdateRepoSecretThen(httpmock::Then);
    impl DependabotCreateOrUpdateRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct DependabotDeleteRepoSecretWhen(httpmock::When);
    impl DependabotDeleteRepoSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependabot/secrets/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependabot/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependabot/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependabotDeleteRepoSecretThen(httpmock::Then);
    impl DependabotDeleteRepoSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct DependencyGraphDiffRangeWhen(httpmock::When);
    impl DependencyGraphDiffRangeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/dependency-graph/compare/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependency-graph/compare/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependency-graph/compare/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn basehead(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/dependency-graph/compare/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            Self(self.0.query_param("name", value.to_string()))
        }
    }

    pub struct DependencyGraphDiffRangeThen(httpmock::Then);
    impl DependencyGraphDiffRangeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependencyGraphDiff) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependencyGraphExportSbomWhen(httpmock::When);
    impl DependencyGraphExportSbomWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/dependency-graph/sbom$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependency-graph/sbom$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependency-graph/sbom$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct DependencyGraphExportSbomThen(httpmock::Then);
    impl DependencyGraphExportSbomThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DependencyGraphSpdxSbom) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct DependencyGraphCreateRepositorySnapshotWhen(httpmock::When);
    impl DependencyGraphCreateRepositorySnapshotWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/dependency-graph/snapshots$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/dependency-graph/snapshots$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/dependency-graph/snapshots$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::Snapshot) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct DependencyGraphCreateRepositorySnapshotThen(httpmock::Then);
    impl DependencyGraphCreateRepositorySnapshotThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(
            self,
            value: &types::DependencyGraphCreateRepositorySnapshotResponse,
        ) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListDeploymentsWhen(httpmock::When);
    impl ReposListDeploymentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/deployments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/deployments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/deployments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment(self, value: &str) -> Self {
            Self(self.0.query_param("environment", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }

        pub fn sha(self, value: &str) -> Self {
            Self(self.0.query_param("sha", value.to_string()))
        }

        pub fn task(self, value: &str) -> Self {
            Self(self.0.query_param("task", value.to_string()))
        }
    }

    pub struct ReposListDeploymentsThen(httpmock::Then);
    impl ReposListDeploymentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Deployment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDeploymentWhen(httpmock::When);
    impl ReposCreateDeploymentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/deployments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/deployments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/deployments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateDeploymentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDeploymentThen(httpmock::Then);
    impl ReposCreateDeploymentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Deployment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::ReposCreateDeploymentResponse) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetDeploymentWhen(httpmock::When);
    impl ReposGetDeploymentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/deployments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/deployments/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/deployments/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn deployment_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/deployments/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetDeploymentThen(httpmock::Then);
    impl ReposGetDeploymentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Deployment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteDeploymentWhen(httpmock::When);
    impl ReposDeleteDeploymentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/deployments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/deployments/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/deployments/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn deployment_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/deployments/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteDeploymentThen(httpmock::Then);
    impl ReposDeleteDeploymentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListDeploymentStatusesWhen(httpmock::When);
    impl ReposListDeploymentStatusesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/deployments/.*/statuses$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/deployments/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/deployments/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn deployment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/deployments/{}/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListDeploymentStatusesThen(httpmock::Then);
    impl ReposListDeploymentStatusesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DeploymentStatus>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDeploymentStatusWhen(httpmock::When);
    impl ReposCreateDeploymentStatusWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/deployments/.*/statuses$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/deployments/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/deployments/.*/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn deployment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/deployments/{}/statuses$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateDeploymentStatusBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDeploymentStatusThen(httpmock::Then);
    impl ReposCreateDeploymentStatusThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::DeploymentStatus) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetDeploymentStatusWhen(httpmock::When);
    impl ReposGetDeploymentStatusWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/deployments/.*/statuses/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/deployments/.*/statuses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/deployments/.*/statuses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn deployment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/deployments/{}/statuses/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn status_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/deployments/.*/statuses/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetDeploymentStatusThen(httpmock::Then);
    impl ReposGetDeploymentStatusThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeploymentStatus) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDispatchEventWhen(httpmock::When);
    impl ReposCreateDispatchEventWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/dispatches$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/dispatches$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/dispatches$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateDispatchEventBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDispatchEventThen(httpmock::Then);
    impl ReposCreateDispatchEventThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAllEnvironmentsWhen(httpmock::When);
    impl ReposGetAllEnvironmentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/environments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/environments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/environments$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposGetAllEnvironmentsThen(httpmock::Then);
    impl ReposGetAllEnvironmentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReposGetAllEnvironmentsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetEnvironmentWhen(httpmock::When);
    impl ReposGetEnvironmentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/environments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetEnvironmentThen(httpmock::Then);
    impl ReposGetEnvironmentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Environment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateOrUpdateEnvironmentWhen(httpmock::When);
    impl ReposCreateOrUpdateEnvironmentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/environments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateOrUpdateEnvironmentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateOrUpdateEnvironmentThen(httpmock::Then);
    impl ReposCreateOrUpdateEnvironmentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Environment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteAnEnvironmentWhen(httpmock::When);
    impl ReposDeleteAnEnvironmentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/environments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteAnEnvironmentThen(httpmock::Then);
    impl ReposDeleteAnEnvironmentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListDeploymentBranchPoliciesWhen(httpmock::When);
    impl ReposListDeploymentBranchPoliciesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/environments/.*/deployment-branch-policies$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListDeploymentBranchPoliciesThen(httpmock::Then);
    impl ReposListDeploymentBranchPoliciesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReposListDeploymentBranchPoliciesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDeploymentBranchPolicyWhen(httpmock::When);
    impl ReposCreateDeploymentBranchPolicyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/environments/.*/deployment-branch-policies$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment-branch-policies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DeploymentBranchPolicyNamePattern) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDeploymentBranchPolicyThen(httpmock::Then);
    impl ReposCreateDeploymentBranchPolicyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeploymentBranchPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn see_other(self) -> Self {
            Self(self.0.status(303u16))
        }
    }

    pub struct ReposGetDeploymentBranchPolicyWhen(httpmock::When);
    impl ReposGetDeploymentBranchPolicyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment-branch-policies/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch_policy_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/.*/deployment-branch-policies/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetDeploymentBranchPolicyThen(httpmock::Then);
    impl ReposGetDeploymentBranchPolicyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeploymentBranchPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateDeploymentBranchPolicyWhen(httpmock::When);
    impl ReposUpdateDeploymentBranchPolicyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment-branch-policies/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch_policy_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/.*/deployment-branch-policies/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::DeploymentBranchPolicyNamePattern) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateDeploymentBranchPolicyThen(httpmock::Then);
    impl ReposUpdateDeploymentBranchPolicyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeploymentBranchPolicy) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteDeploymentBranchPolicyWhen(httpmock::When);
    impl ReposDeleteDeploymentBranchPolicyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment-branch-policies/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment-branch-policies/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch_policy_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/.*/deployment-branch-policies/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteDeploymentBranchPolicyThen(httpmock::Then);
    impl ReposDeleteDeploymentBranchPolicyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetAllDeploymentProtectionRulesWhen(httpmock::When);
    impl ReposGetAllDeploymentProtectionRulesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/environments/.*/deployment_protection_rules$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetAllDeploymentProtectionRulesThen(httpmock::Then);
    impl ReposGetAllDeploymentProtectionRulesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReposGetAllDeploymentProtectionRulesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDeploymentProtectionRuleWhen(httpmock::When);
    impl ReposCreateDeploymentProtectionRuleWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/environments/.*/deployment_protection_rules$")
                        .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment_protection_rules$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateDeploymentProtectionRuleBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDeploymentProtectionRuleThen(httpmock::Then);
    impl ReposCreateDeploymentProtectionRuleThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::DeploymentProtectionRule) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListCustomDeploymentRuleIntegrationsWhen(httpmock::When);
    impl ReposListCustomDeploymentRuleIntegrationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment_protection_rules/apps$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment_protection_rules/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment_protection_rules/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment_protection_rules/apps$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListCustomDeploymentRuleIntegrationsThen(httpmock::Then);
    impl ReposListCustomDeploymentRuleIntegrationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReposListCustomDeploymentRuleIntegrationsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCustomDeploymentProtectionRuleWhen(httpmock::When);
    impl ReposGetCustomDeploymentProtectionRuleWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment_protection_rules/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn protection_rule_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/.*/deployment_protection_rules/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCustomDeploymentProtectionRuleThen(httpmock::Then);
    impl ReposGetCustomDeploymentProtectionRuleThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeploymentProtectionRule) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDisableDeploymentProtectionRuleWhen(httpmock::When);
    impl ReposDisableDeploymentProtectionRuleWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new(
                        "^/repos/.*/.*/environments/.*/deployment_protection_rules/.*$",
                    )
                    .unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/environments/.*/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/environments/.*/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/{}/deployment_protection_rules/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn protection_rule_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/environments/.*/deployment_protection_rules/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDisableDeploymentProtectionRuleThen(httpmock::Then);
    impl ReposDisableDeploymentProtectionRuleThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActivityListRepoEventsWhen(httpmock::When);
    impl ActivityListRepoEventsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListRepoEventsThen(httpmock::Then);
    impl ActivityListRepoEventsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListForksWhen(httpmock::When);
    impl ReposListForksWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/forks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::ReposListForksSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct ReposListForksThen(httpmock::Then);
    impl ReposListForksThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateForkWhen(httpmock::When);
    impl ReposCreateForkWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/forks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/forks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateForkBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateForkThen(httpmock::Then);
    impl ReposCreateForkThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::FullRepository) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitCreateBlobWhen(httpmock::When);
    impl GitCreateBlobWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/blobs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/git/blobs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/git/blobs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitCreateBlobBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitCreateBlobThen(httpmock::Then);
    impl GitCreateBlobThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::ShortBlob) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitGetBlobWhen(httpmock::When);
    impl GitGetBlobWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/blobs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/blobs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/blobs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn file_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/blobs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitGetBlobThen(httpmock::Then);
    impl GitGetBlobThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Blob) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitCreateCommitWhen(httpmock::When);
    impl GitCreateCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/commits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/commits$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/commits$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitCreateCommitBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitCreateCommitThen(httpmock::Then);
    impl GitCreateCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GitCommit) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitGetCommitWhen(httpmock::When);
    impl GitGetCommitWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/commits/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/git/commits/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/git/commits/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn commit_sha(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/git/commits/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitGetCommitThen(httpmock::Then);
    impl GitGetCommitThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitCommit) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitListMatchingRefsWhen(httpmock::When);
    impl GitListMatchingRefsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/git/matching-refs/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/git/matching-refs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/git/matching-refs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/git/matching-refs/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitListMatchingRefsThen(httpmock::Then);
    impl GitListMatchingRefsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GitRef>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitGetRefWhen(httpmock::When);
    impl GitGetRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/ref/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/ref/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/ref/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/ref/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitGetRefThen(httpmock::Then);
    impl GitGetRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitRef) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitCreateRefWhen(httpmock::When);
    impl GitCreateRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/refs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/git/refs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/git/refs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitCreateRefBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitCreateRefThen(httpmock::Then);
    impl GitCreateRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GitRef) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitDeleteRefWhen(httpmock::When);
    impl GitDeleteRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/refs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitDeleteRefThen(httpmock::Then);
    impl GitDeleteRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitUpdateRefWhen(httpmock::When);
    impl GitUpdateRefWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/refs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/refs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitUpdateRefBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitUpdateRefThen(httpmock::Then);
    impl GitUpdateRefThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitRef) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitCreateTagWhen(httpmock::When);
    impl GitCreateTagWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/tags$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/git/tags$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/git/tags$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitCreateTagBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitCreateTagThen(httpmock::Then);
    impl GitCreateTagThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GitTag) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitGetTagWhen(httpmock::When);
    impl GitGetTagWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/tags/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/tags/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/tags/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn tag_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/tags/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct GitGetTagThen(httpmock::Then);
    impl GitGetTagThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitTag) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitCreateTreeWhen(httpmock::When);
    impl GitCreateTreeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/trees$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/git/trees$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/git/trees$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::GitCreateTreeBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct GitCreateTreeThen(httpmock::Then);
    impl GitCreateTreeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GitTree) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct GitGetTreeWhen(httpmock::When);
    impl GitGetTreeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/git/trees/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/git/trees/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/git/trees/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn tree_sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/git/trees/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn recursive(self, value: &str) -> Self {
            Self(self.0.query_param("recursive", value.to_string()))
        }
    }

    pub struct GitGetTreeThen(httpmock::Then);
    impl GitGetTreeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GitTree) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListWebhooksWhen(httpmock::When);
    impl ReposListWebhooksWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListWebhooksThen(httpmock::Then);
    impl ReposListWebhooksThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Hook>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateWebhookWhen(httpmock::When);
    impl ReposCreateWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateWebhookBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateWebhookThen(httpmock::Then);
    impl ReposCreateWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Hook) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetWebhookWhen(httpmock::When);
    impl ReposGetWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetWebhookThen(httpmock::Then);
    impl ReposGetWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Hook) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteWebhookWhen(httpmock::When);
    impl ReposDeleteWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteWebhookThen(httpmock::Then);
    impl ReposDeleteWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateWebhookWhen(httpmock::When);
    impl ReposUpdateWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/hooks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateWebhookBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateWebhookThen(httpmock::Then);
    impl ReposUpdateWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Hook) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetWebhookConfigForRepoWhen(httpmock::When);
    impl ReposGetWebhookConfigForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/hooks/.*/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/hooks/.*/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/{}/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetWebhookConfigForRepoThen(httpmock::Then);
    impl ReposGetWebhookConfigForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateWebhookConfigForRepoWhen(httpmock::When);
    impl ReposUpdateWebhookConfigForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*/config$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/hooks/.*/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/hooks/.*/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/{}/config$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateWebhookConfigForRepoBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateWebhookConfigForRepoThen(httpmock::Then);
    impl ReposUpdateWebhookConfigForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::WebhookConfig) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListWebhookDeliveriesWhen(httpmock::When);
    impl ReposListWebhookDeliveriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*/deliveries$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/hooks/.*/deliveries$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/hooks/.*/deliveries$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/{}/deliveries$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn cursor(self, value: &str) -> Self {
            Self(self.0.query_param("cursor", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn redelivery(self, value: bool) -> Self {
            Self(self.0.query_param("redelivery", value.to_string()))
        }
    }

    pub struct ReposListWebhookDeliveriesThen(httpmock::Then);
    impl ReposListWebhookDeliveriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::HookDeliveryItem>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetWebhookDeliveryWhen(httpmock::When);
    impl ReposGetWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/hooks/.*/deliveries/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/hooks/.*/deliveries/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/hooks/.*/deliveries/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/{}/deliveries/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/.*/deliveries/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetWebhookDeliveryThen(httpmock::Then);
    impl ReposGetWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::HookDelivery) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRedeliverWebhookDeliveryWhen(httpmock::When);
    impl ReposRedeliverWebhookDeliveryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/hooks/.*/deliveries/.*/attempts$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/hooks/.*/deliveries/.*/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/hooks/.*/deliveries/.*/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/{}/deliveries/.*/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn delivery_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/hooks/.*/deliveries/{}/attempts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposRedeliverWebhookDeliveryThen(httpmock::Then);
    impl ReposRedeliverWebhookDeliveryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposPingWebhookWhen(httpmock::When);
    impl ReposPingWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*/pings$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks/.*/pings$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks/.*/pings$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/hooks/{}/pings$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposPingWebhookThen(httpmock::Then);
    impl ReposPingWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposTestPushWebhookWhen(httpmock::When);
    impl ReposTestPushWebhookWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/hooks/.*/tests$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/hooks/.*/tests$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/hooks/.*/tests$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn hook_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/hooks/{}/tests$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposTestPushWebhookThen(httpmock::Then);
    impl ReposTestPushWebhookThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetImportStatusWhen(httpmock::When);
    impl MigrationsGetImportStatusWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsGetImportStatusThen(httpmock::Then);
    impl MigrationsGetImportStatusThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Import) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsStartImportWhen(httpmock::When);
    impl MigrationsStartImportWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::MigrationsStartImportBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsStartImportThen(httpmock::Then);
    impl MigrationsStartImportThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Import) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsCancelImportWhen(httpmock::When);
    impl MigrationsCancelImportWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsCancelImportThen(httpmock::Then);
    impl MigrationsCancelImportThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsUpdateImportWhen(httpmock::When);
    impl MigrationsUpdateImportWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/import$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::MigrationsUpdateImportBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsUpdateImportThen(httpmock::Then);
    impl MigrationsUpdateImportThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Import) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetCommitAuthorsWhen(httpmock::When);
    impl MigrationsGetCommitAuthorsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import/authors$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/import/authors$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/import/authors$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn since(self, value: i64) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct MigrationsGetCommitAuthorsThen(httpmock::Then);
    impl MigrationsGetCommitAuthorsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PorterAuthor>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsMapCommitAuthorWhen(httpmock::When);
    impl MigrationsMapCommitAuthorWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import/authors/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/import/authors/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/import/authors/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn author_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/import/authors/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::MigrationsMapCommitAuthorBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsMapCommitAuthorThen(httpmock::Then);
    impl MigrationsMapCommitAuthorThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PorterAuthor) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetLargeFilesWhen(httpmock::When);
    impl MigrationsGetLargeFilesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import/large_files$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/import/large_files$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/import/large_files$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsGetLargeFilesThen(httpmock::Then);
    impl MigrationsGetLargeFilesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PorterLargeFile>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsSetLfsPreferenceWhen(httpmock::When);
    impl MigrationsSetLfsPreferenceWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/import/lfs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/import/lfs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/import/lfs$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::MigrationsSetLfsPreferenceBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsSetLfsPreferenceThen(httpmock::Then);
    impl MigrationsSetLfsPreferenceThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Import) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetRepoInstallationWhen(httpmock::When);
    impl AppsGetRepoInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/installation$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/installation$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/installation$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetRepoInstallationThen(httpmock::Then);
    impl AppsGetRepoInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Installation) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsGetRestrictionsForRepoWhen(httpmock::When);
    impl InteractionsGetRestrictionsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct InteractionsGetRestrictionsForRepoThen(httpmock::Then);
    impl InteractionsGetRestrictionsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::InteractionsGetRestrictionsForRepoResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsSetRestrictionsForRepoWhen(httpmock::When);
    impl InteractionsSetRestrictionsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::InteractionLimit) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct InteractionsSetRestrictionsForRepoThen(httpmock::Then);
    impl InteractionsSetRestrictionsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::InteractionLimitResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct InteractionsRemoveRestrictionsForRepoWhen(httpmock::When);
    impl InteractionsRemoveRestrictionsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/interaction-limits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct InteractionsRemoveRestrictionsForRepoThen(httpmock::Then);
    impl InteractionsRemoveRestrictionsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }
    }

    pub struct ReposListInvitationsWhen(httpmock::When);
    impl ReposListInvitationsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/invitations$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/invitations$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListInvitationsThen(httpmock::Then);
    impl ReposListInvitationsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteInvitationWhen(httpmock::When);
    impl ReposDeleteInvitationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/invitations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/invitations/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/invitations/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/invitations/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteInvitationThen(httpmock::Then);
    impl ReposDeleteInvitationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposUpdateInvitationWhen(httpmock::When);
    impl ReposUpdateInvitationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/invitations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/invitations/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/invitations/.*$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/invitations/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateInvitationBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateInvitationThen(httpmock::Then);
    impl ReposUpdateInvitationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryInvitation) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListForRepoWhen(httpmock::When);
    impl IssuesListForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn assignee(self, value: &str) -> Self {
            Self(self.0.query_param("assignee", value.to_string()))
        }

        pub fn creator(self, value: &str) -> Self {
            Self(self.0.query_param("creator", value.to_string()))
        }

        pub fn direction(self, value: types::IssuesListForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn labels(self, value: &str) -> Self {
            Self(self.0.query_param("labels", value.to_string()))
        }

        pub fn mentioned(self, value: &str) -> Self {
            Self(self.0.query_param("mentioned", value.to_string()))
        }

        pub fn milestone(self, value: &str) -> Self {
            Self(self.0.query_param("milestone", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::IssuesListForRepoState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct IssuesListForRepoThen(httpmock::Then);
    impl IssuesListForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Issue>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCreateWhen(httpmock::When);
    impl IssuesCreateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesCreateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesCreateThen(httpmock::Then);
    impl IssuesCreateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Issue) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::IssuesCreateResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListCommentsForRepoWhen(httpmock::When);
    impl IssuesListCommentsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::IssuesListCommentsForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListCommentsForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct IssuesListCommentsForRepoThen(httpmock::Then);
    impl IssuesListCommentsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::IssueComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesGetCommentWhen(httpmock::When);
    impl IssuesGetCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesGetCommentThen(httpmock::Then);
    impl IssuesGetCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::IssueComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesDeleteCommentWhen(httpmock::When);
    impl IssuesDeleteCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesDeleteCommentThen(httpmock::Then);
    impl IssuesDeleteCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesUpdateCommentWhen(httpmock::When);
    impl IssuesUpdateCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesUpdateCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesUpdateCommentThen(httpmock::Then);
    impl IssuesUpdateCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::IssueComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForIssueCommentWhen(httpmock::When);
    impl ReactionsListForIssueCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/issues/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForIssueCommentContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForIssueCommentThen(httpmock::Then);
    impl ReactionsListForIssueCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForIssueCommentWhen(httpmock::When);
    impl ReactionsCreateForIssueCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/issues/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForIssueCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForIssueCommentThen(httpmock::Then);
    impl ReactionsCreateForIssueCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForIssueCommentWhen(httpmock::When);
    impl ReactionsDeleteForIssueCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/issues/comments/.*/reactions/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/comments/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForIssueCommentThen(httpmock::Then);
    impl ReactionsDeleteForIssueCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesListEventsForRepoWhen(httpmock::When);
    impl IssuesListEventsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/issues/events$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/issues/events$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListEventsForRepoThen(httpmock::Then);
    impl IssuesListEventsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::IssueEvent>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesGetEventWhen(httpmock::When);
    impl IssuesGetEventWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/events/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/events/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/events/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn event_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/events/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesGetEventThen(httpmock::Then);
    impl IssuesGetEventThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::IssueEvent) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesGetWhen(httpmock::When);
    impl IssuesGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/issues/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesGetThen(httpmock::Then);
    impl IssuesGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Issue) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct IssuesUpdateWhen(httpmock::When);
    impl IssuesUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/issues/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesUpdateThen(httpmock::Then);
    impl IssuesUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Issue) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::IssuesUpdateResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesAddAssigneesWhen(httpmock::When);
    impl IssuesAddAssigneesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/assignees$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesAddAssigneesBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesAddAssigneesThen(httpmock::Then);
    impl IssuesAddAssigneesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Issue) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesRemoveAssigneesWhen(httpmock::When);
    impl IssuesRemoveAssigneesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/assignees$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/assignees$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesRemoveAssigneesBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesRemoveAssigneesThen(httpmock::Then);
    impl IssuesRemoveAssigneesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Issue) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCheckUserCanBeAssignedToIssueWhen(httpmock::When);
    impl IssuesCheckUserCanBeAssignedToIssueWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/issues/.*/assignees/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/assignees/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/assignees/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/assignees/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn assignee(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/.*/assignees/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesCheckUserCanBeAssignedToIssueThen(httpmock::Then);
    impl IssuesCheckUserCanBeAssignedToIssueThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListCommentsWhen(httpmock::When);
    impl IssuesListCommentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct IssuesListCommentsThen(httpmock::Then);
    impl IssuesListCommentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::IssueComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCreateCommentWhen(httpmock::When);
    impl IssuesCreateCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesCreateCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesCreateCommentThen(httpmock::Then);
    impl IssuesCreateCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::IssueComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListEventsWhen(httpmock::When);
    impl IssuesListEventsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListEventsThen(httpmock::Then);
    impl IssuesListEventsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::IssueEventForIssue>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListLabelsOnIssueWhen(httpmock::When);
    impl IssuesListLabelsOnIssueWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListLabelsOnIssueThen(httpmock::Then);
    impl IssuesListLabelsOnIssueThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesSetLabelsWhen(httpmock::When);
    impl IssuesSetLabelsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesSetLabelsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesSetLabelsThen(httpmock::Then);
    impl IssuesSetLabelsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesAddLabelsWhen(httpmock::When);
    impl IssuesAddLabelsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesAddLabelsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesAddLabelsThen(httpmock::Then);
    impl IssuesAddLabelsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesRemoveAllLabelsWhen(httpmock::When);
    impl IssuesRemoveAllLabelsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesRemoveAllLabelsThen(httpmock::Then);
    impl IssuesRemoveAllLabelsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesRemoveLabelWhen(httpmock::When);
    impl IssuesRemoveLabelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/labels/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/labels/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/.*/labels/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesRemoveLabelThen(httpmock::Then);
    impl IssuesRemoveLabelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn moved_permanently(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(301u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesLockWhen(httpmock::When);
    impl IssuesLockWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/lock$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues/.*/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues/.*/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/issues/{}/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesLockBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesLockThen(httpmock::Then);
    impl IssuesLockThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesUnlockWhen(httpmock::When);
    impl IssuesUnlockWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/lock$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/issues/.*/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/issues/.*/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/issues/{}/lock$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesUnlockThen(httpmock::Then);
    impl IssuesUnlockThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForIssueWhen(httpmock::When);
    impl ReactionsListForIssueWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/reactions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForIssueContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForIssueThen(httpmock::Then);
    impl ReactionsListForIssueThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForIssueWhen(httpmock::When);
    impl ReactionsCreateForIssueWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/reactions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForIssueBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForIssueThen(httpmock::Then);
    impl ReactionsCreateForIssueThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForIssueWhen(httpmock::When);
    impl ReactionsDeleteForIssueWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/issues/.*/reactions/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForIssueThen(httpmock::Then);
    impl ReactionsDeleteForIssueThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesListEventsForTimelineWhen(httpmock::When);
    impl IssuesListEventsForTimelineWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/issues/.*/timeline$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/issues/.*/timeline$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/issues/.*/timeline$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn issue_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/issues/{}/timeline$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListEventsForTimelineThen(httpmock::Then);
    impl IssuesListEventsForTimelineThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TimelineIssueEvents>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListDeployKeysWhen(httpmock::When);
    impl ReposListDeployKeysWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListDeployKeysThen(httpmock::Then);
    impl ReposListDeployKeysThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DeployKey>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateDeployKeyWhen(httpmock::When);
    impl ReposCreateDeployKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateDeployKeyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateDeployKeyThen(httpmock::Then);
    impl ReposCreateDeployKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::DeployKey) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetDeployKeyWhen(httpmock::When);
    impl ReposGetDeployKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/keys/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/keys/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn key_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetDeployKeyThen(httpmock::Then);
    impl ReposGetDeployKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::DeployKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteDeployKeyWhen(httpmock::When);
    impl ReposDeleteDeployKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/keys/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/keys/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn key_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteDeployKeyThen(httpmock::Then);
    impl ReposDeleteDeployKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesListLabelsForRepoWhen(httpmock::When);
    impl IssuesListLabelsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/labels$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/labels$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListLabelsForRepoThen(httpmock::Then);
    impl IssuesListLabelsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCreateLabelWhen(httpmock::When);
    impl IssuesCreateLabelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/labels$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/labels$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesCreateLabelBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesCreateLabelThen(httpmock::Then);
    impl IssuesCreateLabelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Label) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesGetLabelWhen(httpmock::When);
    impl IssuesGetLabelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/labels/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/labels/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesGetLabelThen(httpmock::Then);
    impl IssuesGetLabelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Label) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesDeleteLabelWhen(httpmock::When);
    impl IssuesDeleteLabelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/labels/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/labels/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesDeleteLabelThen(httpmock::Then);
    impl IssuesDeleteLabelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesUpdateLabelWhen(httpmock::When);
    impl IssuesUpdateLabelWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/labels/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/labels/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/labels/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesUpdateLabelBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesUpdateLabelThen(httpmock::Then);
    impl IssuesUpdateLabelThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Label) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListLanguagesWhen(httpmock::When);
    impl ReposListLanguagesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/languages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/languages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/languages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposListLanguagesThen(httpmock::Then);
    impl ReposListLanguagesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Language) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposEnableLfsForRepoWhen(httpmock::When);
    impl ReposEnableLfsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/lfs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/lfs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/lfs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposEnableLfsForRepoThen(httpmock::Then);
    impl ReposEnableLfsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }
    }

    pub struct ReposDisableLfsForRepoWhen(httpmock::When);
    impl ReposDisableLfsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/lfs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/lfs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/lfs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDisableLfsForRepoThen(httpmock::Then);
    impl ReposDisableLfsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct LicensesGetForRepoWhen(httpmock::When);
    impl LicensesGetForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/license$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/license$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/license$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct LicensesGetForRepoThen(httpmock::Then);
    impl LicensesGetForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::LicenseContent) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposMergeUpstreamWhen(httpmock::When);
    impl ReposMergeUpstreamWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/merge-upstream$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/merge-upstream$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/merge-upstream$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposMergeUpstreamBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposMergeUpstreamThen(httpmock::Then);
    impl ReposMergeUpstreamThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::MergedUpstream) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct ReposMergeWhen(httpmock::When);
    impl ReposMergeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/merges$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/merges$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/merges$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposMergeBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposMergeThen(httpmock::Then);
    impl ReposMergeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Commit) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn conflict(self) -> Self {
            Self(self.0.status(409u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListMilestonesWhen(httpmock::When);
    impl IssuesListMilestonesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/milestones$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/milestones$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/milestones$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::IssuesListMilestonesDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListMilestonesSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::IssuesListMilestonesState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct IssuesListMilestonesThen(httpmock::Then);
    impl IssuesListMilestonesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Milestone>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesCreateMilestoneWhen(httpmock::When);
    impl IssuesCreateMilestoneWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/milestones$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/milestones$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/milestones$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesCreateMilestoneBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesCreateMilestoneThen(httpmock::Then);
    impl IssuesCreateMilestoneThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Milestone) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesGetMilestoneWhen(httpmock::When);
    impl IssuesGetMilestoneWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/milestones/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn milestone_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/milestones/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesGetMilestoneThen(httpmock::Then);
    impl IssuesGetMilestoneThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Milestone) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesDeleteMilestoneWhen(httpmock::When);
    impl IssuesDeleteMilestoneWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/milestones/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn milestone_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/milestones/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct IssuesDeleteMilestoneThen(httpmock::Then);
    impl IssuesDeleteMilestoneThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesUpdateMilestoneWhen(httpmock::When);
    impl IssuesUpdateMilestoneWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/milestones/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/milestones/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn milestone_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/milestones/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::IssuesUpdateMilestoneBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct IssuesUpdateMilestoneThen(httpmock::Then);
    impl IssuesUpdateMilestoneThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Milestone) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct IssuesListLabelsForMilestoneWhen(httpmock::When);
    impl IssuesListLabelsForMilestoneWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/milestones/.*/labels$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/milestones/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/milestones/.*/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn milestone_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/milestones/{}/labels$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct IssuesListLabelsForMilestoneThen(httpmock::Then);
    impl IssuesListLabelsForMilestoneThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Label>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListRepoNotificationsForAuthenticatedUserWhen(httpmock::When);
    impl ActivityListRepoNotificationsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/notifications$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/notifications$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/notifications$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn all(self, value: bool) -> Self {
            Self(self.0.query_param("all", value.to_string()))
        }

        pub fn before(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn participating(self, value: bool) -> Self {
            Self(self.0.query_param("participating", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct ActivityListRepoNotificationsForAuthenticatedUserThen(httpmock::Then);
    impl ActivityListRepoNotificationsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Thread>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityMarkRepoNotificationsAsReadWhen(httpmock::When);
    impl ActivityMarkRepoNotificationsAsReadWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/notifications$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/notifications$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/notifications$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActivityMarkRepoNotificationsAsReadBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActivityMarkRepoNotificationsAsReadThen(httpmock::Then);
    impl ActivityMarkRepoNotificationsAsReadThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::ActivityMarkRepoNotificationsAsReadResponse) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn reset_content(self) -> Self {
            Self(self.0.status(205u16))
        }
    }

    pub struct ReposGetPagesWhen(httpmock::When);
    impl ReposGetPagesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetPagesThen(httpmock::Then);
    impl ReposGetPagesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Page) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateInformationAboutPagesSiteWhen(httpmock::When);
    impl ReposUpdateInformationAboutPagesSiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateInformationAboutPagesSiteBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateInformationAboutPagesSiteThen(httpmock::Then);
    impl ReposUpdateInformationAboutPagesSiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreatePagesSiteWhen(httpmock::When);
    impl ReposCreatePagesSiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreatePagesSiteBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreatePagesSiteThen(httpmock::Then);
    impl ReposCreatePagesSiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Page) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeletePagesSiteWhen(httpmock::When);
    impl ReposDeletePagesSiteWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeletePagesSiteThen(httpmock::Then);
    impl ReposDeletePagesSiteThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListPagesBuildsWhen(httpmock::When);
    impl ReposListPagesBuildsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/builds$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/pages/builds$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/pages/builds$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListPagesBuildsThen(httpmock::Then);
    impl ReposListPagesBuildsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PageBuild>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposRequestPagesBuildWhen(httpmock::When);
    impl ReposRequestPagesBuildWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/builds$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/pages/builds$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/pages/builds$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposRequestPagesBuildThen(httpmock::Then);
    impl ReposRequestPagesBuildThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::PageBuildStatus) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetLatestPagesBuildWhen(httpmock::When);
    impl ReposGetLatestPagesBuildWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/builds/latest$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pages/builds/latest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pages/builds/latest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetLatestPagesBuildThen(httpmock::Then);
    impl ReposGetLatestPagesBuildThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PageBuild) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetPagesBuildWhen(httpmock::When);
    impl ReposGetPagesBuildWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/builds/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pages/builds/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pages/builds/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn build_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pages/builds/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetPagesBuildThen(httpmock::Then);
    impl ReposGetPagesBuildThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PageBuild) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreatePagesDeploymentWhen(httpmock::When);
    impl ReposCreatePagesDeploymentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/deployment$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pages/deployment$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pages/deployment$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreatePagesDeploymentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreatePagesDeploymentThen(httpmock::Then);
    impl ReposCreatePagesDeploymentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PageDeployment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetPagesHealthCheckWhen(httpmock::When);
    impl ReposGetPagesHealthCheckWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pages/health$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/pages/health$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/pages/health$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetPagesHealthCheckThen(httpmock::Then);
    impl ReposGetPagesHealthCheckThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PagesHealthCheck) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsListForRepoWhen(httpmock::When);
    impl ProjectsListForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(self, value: types::ProjectsListForRepoState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct ProjectsListForRepoThen(httpmock::Then);
    impl ProjectsListForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Project>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsCreateForRepoWhen(httpmock::When);
    impl ProjectsCreateForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ProjectsCreateForRepoBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsCreateForRepoThen(httpmock::Then);
    impl ProjectsCreateForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Project) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn gone(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(410u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListWhen(httpmock::When);
    impl PullsListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn base(self, value: &str) -> Self {
            Self(self.0.query_param("base", value.to_string()))
        }

        pub fn direction(self, value: types::PullsListDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn head(self, value: &str) -> Self {
            Self(self.0.query_param("head", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::PullsListSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::PullsListState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct PullsListThen(httpmock::Then);
    impl PullsListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PullRequestSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsCreateWhen(httpmock::When);
    impl PullsCreateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsCreateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsCreateThen(httpmock::Then);
    impl PullsCreateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::PullRequest) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListReviewCommentsForRepoWhen(httpmock::When);
    impl PullsListReviewCommentsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/comments$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/comments$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::PullsListReviewCommentsForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::PullsListReviewCommentsForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct PullsListReviewCommentsForRepoThen(httpmock::Then);
    impl PullsListReviewCommentsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PullRequestReviewComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsGetReviewCommentWhen(httpmock::When);
    impl PullsGetReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsGetReviewCommentThen(httpmock::Then);
    impl PullsGetReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReviewComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsDeleteReviewCommentWhen(httpmock::When);
    impl PullsDeleteReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsDeleteReviewCommentThen(httpmock::Then);
    impl PullsDeleteReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsUpdateReviewCommentWhen(httpmock::When);
    impl PullsUpdateReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/comments/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsUpdateReviewCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsUpdateReviewCommentThen(httpmock::Then);
    impl PullsUpdateReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReviewComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForPullRequestReviewCommentWhen(httpmock::When);
    impl ReactionsListForPullRequestReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(
            self,
            value: types::ReactionsListForPullRequestReviewCommentContent,
        ) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForPullRequestReviewCommentThen(httpmock::Then);
    impl ReactionsListForPullRequestReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForPullRequestReviewCommentWhen(httpmock::When);
    impl ReactionsCreateForPullRequestReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForPullRequestReviewCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForPullRequestReviewCommentThen(httpmock::Then);
    impl ReactionsCreateForPullRequestReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForPullRequestCommentWhen(httpmock::When);
    impl ReactionsDeleteForPullRequestCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/comments/.*/reactions/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/comments/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/comments/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForPullRequestCommentThen(httpmock::Then);
    impl ReactionsDeleteForPullRequestCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct PullsGetWhen(httpmock::When);
    impl PullsGetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/pulls/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsGetThen(httpmock::Then);
    impl PullsGetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequest) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::PullsGetResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsUpdateWhen(httpmock::When);
    impl PullsUpdateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/pulls/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsUpdateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsUpdateThen(httpmock::Then);
    impl PullsUpdateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequest) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateWithPrForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesCreateWithPrForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/codespaces$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/codespaces$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/codespaces$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesCreateWithPrForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateWithPrForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesCreateWithPrForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodespacesCreateWithPrForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListReviewCommentsWhen(httpmock::When);
    impl PullsListReviewCommentsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::PullsListReviewCommentsDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::PullsListReviewCommentsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct PullsListReviewCommentsThen(httpmock::Then);
    impl PullsListReviewCommentsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PullRequestReviewComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsCreateReviewCommentWhen(httpmock::When);
    impl PullsCreateReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/comments$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsCreateReviewCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsCreateReviewCommentThen(httpmock::Then);
    impl PullsCreateReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::PullRequestReviewComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsCreateReplyForReviewCommentWhen(httpmock::When);
    impl PullsCreateReplyForReviewCommentWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/comments/.*/replies$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/comments/.*/replies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/comments/.*/replies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/comments/.*/replies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/comments/{}/replies$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsCreateReplyForReviewCommentBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsCreateReplyForReviewCommentThen(httpmock::Then);
    impl PullsCreateReplyForReviewCommentThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::PullRequestReviewComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListCommitsWhen(httpmock::When);
    impl PullsListCommitsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/commits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/commits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/commits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/commits$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct PullsListCommitsThen(httpmock::Then);
    impl PullsListCommitsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Commit>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListFilesWhen(httpmock::When);
    impl PullsListFilesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/files$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/.*/files$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/.*/files$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/pulls/{}/files$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct PullsListFilesThen(httpmock::Then);
    impl PullsListFilesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::DiffEntry>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::PullsListFilesResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsCheckIfMergedWhen(httpmock::When);
    impl PullsCheckIfMergedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/merge$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/.*/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/.*/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/pulls/{}/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsCheckIfMergedThen(httpmock::Then);
    impl PullsCheckIfMergedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct PullsMergeWhen(httpmock::When);
    impl PullsMergeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/merge$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/pulls/.*/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/pulls/.*/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/pulls/{}/merge$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsMergeBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsMergeThen(httpmock::Then);
    impl PullsMergeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestMergeResult) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn method_not_allowed(self, value: &types::PullsMergeResponse) -> Self {
            Self(
                self.0
                    .status(405u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::PullsMergeResponse) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListRequestedReviewersWhen(httpmock::When);
    impl PullsListRequestedReviewersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/requested_reviewers$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsListRequestedReviewersThen(httpmock::Then);
    impl PullsListRequestedReviewersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReviewRequest) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsRequestReviewersWhen(httpmock::When);
    impl PullsRequestReviewersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/requested_reviewers$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsRequestReviewersBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsRequestReviewersThen(httpmock::Then);
    impl PullsRequestReviewersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::PullRequestSimple) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsRemoveRequestedReviewersWhen(httpmock::When);
    impl PullsRemoveRequestedReviewersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/requested_reviewers$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/requested_reviewers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsRemoveRequestedReviewersBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsRemoveRequestedReviewersThen(httpmock::Then);
    impl PullsRemoveRequestedReviewersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestSimple) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListReviewsWhen(httpmock::When);
    impl PullsListReviewsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct PullsListReviewsThen(httpmock::Then);
    impl PullsListReviewsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PullRequestReview>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsCreateReviewWhen(httpmock::When);
    impl PullsCreateReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsCreateReviewBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsCreateReviewThen(httpmock::Then);
    impl PullsCreateReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsGetReviewWhen(httpmock::When);
    impl PullsGetReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsGetReviewThen(httpmock::Then);
    impl PullsGetReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsUpdateReviewWhen(httpmock::When);
    impl PullsUpdateReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsUpdateReviewBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsUpdateReviewThen(httpmock::Then);
    impl PullsUpdateReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsDeletePendingReviewWhen(httpmock::When);
    impl PullsDeletePendingReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PullsDeletePendingReviewThen(httpmock::Then);
    impl PullsDeletePendingReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsListCommentsForReviewWhen(httpmock::When);
    impl PullsListCommentsForReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*/comments$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct PullsListCommentsForReviewThen(httpmock::Then);
    impl PullsListCommentsForReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ReviewComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsDismissReviewWhen(httpmock::When);
    impl PullsDismissReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*/dismissals$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*/dismissals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*/dismissals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*/dismissals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}/dismissals$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsDismissReviewBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsDismissReviewThen(httpmock::Then);
    impl PullsDismissReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsSubmitReviewWhen(httpmock::When);
    impl PullsSubmitReviewWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/pulls/.*/reviews/.*/events$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/reviews/.*/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/reviews/.*/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/reviews/.*/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn review_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/.*/reviews/{}/events$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsSubmitReviewBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsSubmitReviewThen(httpmock::Then);
    impl PullsSubmitReviewThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PullRequestReview) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PullsUpdateBranchWhen(httpmock::When);
    impl PullsUpdateBranchWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/pulls/.*/update-branch$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/pulls/.*/update-branch$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/pulls/.*/update-branch$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn pull_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/pulls/{}/update-branch$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PullsUpdateBranchBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct PullsUpdateBranchThen(httpmock::Then);
    impl PullsUpdateBranchThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::PullsUpdateBranchResponse) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetReadmeWhen(httpmock::When);
    impl ReposGetReadmeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/readme$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/readme$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/readme$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct ReposGetReadmeThen(httpmock::Then);
    impl ReposGetReadmeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ContentFile) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetReadmeInDirectoryWhen(httpmock::When);
    impl ReposGetReadmeInDirectoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/readme/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/readme/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/readme/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn dir(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/.*/readme/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            Self(self.0.query_param("ref_", value.to_string()))
        }
    }

    pub struct ReposGetReadmeInDirectoryThen(httpmock::Then);
    impl ReposGetReadmeInDirectoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ContentFile) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListReposWatchedByUserWhen(httpmock::When);
    impl ActivityListReposWatchedByUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/subscriptions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/subscriptions$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListReposWatchedByUserThen(httpmock::Then);
    impl ActivityListReposWatchedByUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetReleaseAssetWhen(httpmock::When);
    impl ReposGetReleaseAssetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/assets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn asset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/assets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetReleaseAssetThen(httpmock::Then);
    impl ReposGetReleaseAssetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReleaseAsset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }
    }

    pub struct ReposDeleteReleaseAssetWhen(httpmock::When);
    impl ReposDeleteReleaseAssetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/assets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn asset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/assets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteReleaseAssetThen(httpmock::Then);
    impl ReposDeleteReleaseAssetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposUpdateReleaseAssetWhen(httpmock::When);
    impl ReposUpdateReleaseAssetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/assets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/assets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn asset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/assets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateReleaseAssetBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateReleaseAssetThen(httpmock::Then);
    impl ReposUpdateReleaseAssetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReleaseAsset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGenerateReleaseNotesWhen(httpmock::When);
    impl ReposGenerateReleaseNotesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/releases/generate-notes$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/generate-notes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/generate-notes$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposGenerateReleaseNotesBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposGenerateReleaseNotesThen(httpmock::Then);
    impl ReposGenerateReleaseNotesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ReleaseNotesContent) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetLatestReleaseWhen(httpmock::When);
    impl ReposGetLatestReleaseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/latest$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/latest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/latest$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetLatestReleaseThen(httpmock::Then);
    impl ReposGetLatestReleaseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Release) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetReleaseByTagWhen(httpmock::When);
    impl ReposGetReleaseByTagWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/tags/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/tags/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/tags/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn tag(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/tags/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetReleaseByTagThen(httpmock::Then);
    impl ReposGetReleaseByTagThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Release) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListReposStarredByUserWhen(httpmock::When);
    impl ActivityListReposStarredByUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/starred$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/starred$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::ActivityListReposStarredByUserDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::ActivityListReposStarredByUserSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct ActivityListReposStarredByUserThen(httpmock::Then);
    impl ActivityListReposStarredByUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActivityListReposStarredByUserResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListReleaseAssetsWhen(httpmock::When);
    impl ReposListReleaseAssetsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/.*/assets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/.*/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/.*/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn release_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/{}/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListReleaseAssetsThen(httpmock::Then);
    impl ReposListReleaseAssetsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ReleaseAsset>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUploadReleaseAssetWhen(httpmock::When);
    impl ReposUploadReleaseAssetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/releases/.*/assets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/.*/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/.*/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn release_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/{}/assets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn label(self, value: &str) -> Self {
            Self(self.0.query_param("label", value.to_string()))
        }

        pub fn name(self, value: &str) -> Self {
            Self(self.0.query_param("name", value.to_string()))
        }

        pub fn body(self, value: serde_json::Value) -> Self {
            Self(self.0.json_body(value))
        }
    }

    pub struct ReposUploadReleaseAssetThen(httpmock::Then);
    impl ReposUploadReleaseAssetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::ReleaseAsset) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }
    }

    pub struct ReactionsListForReleaseWhen(httpmock::When);
    impl ReactionsListForReleaseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/releases/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn release_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForReleaseContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForReleaseThen(httpmock::Then);
    impl ReactionsListForReleaseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForReleaseWhen(httpmock::When);
    impl ReactionsCreateForReleaseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/repos/.*/.*/releases/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn release_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForReleaseBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForReleaseThen(httpmock::Then);
    impl ReactionsCreateForReleaseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsDeleteForReleaseWhen(httpmock::When);
    impl ReactionsDeleteForReleaseWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repos/.*/.*/releases/.*/reactions/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/releases/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/releases/.*/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn release_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/{}/reactions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn reaction_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/releases/.*/reactions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReactionsDeleteForReleaseThen(httpmock::Then);
    impl ReactionsDeleteForReleaseThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetBranchRulesWhen(httpmock::When);
    impl ReposGetBranchRulesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rules/branches/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/rules/branches/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/rules/branches/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn branch(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/rules/branches/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetBranchRulesThen(httpmock::Then);
    impl ReposGetBranchRulesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryRule>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetRepoRulesetsWhen(httpmock::When);
    impl ReposGetRepoRulesetsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rulesets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn includes_parents(self, value: bool) -> Self {
            Self(self.0.query_param("includes_parents", value.to_string()))
        }
    }

    pub struct ReposGetRepoRulesetsThen(httpmock::Then);
    impl ReposGetRepoRulesetsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryRuleset>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateRepoRulesetWhen(httpmock::When);
    impl ReposCreateRepoRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rulesets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/rulesets$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateRepoRulesetBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateRepoRulesetThen(httpmock::Then);
    impl ReposCreateRepoRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetRepoRulesetWhen(httpmock::When);
    impl ReposGetRepoRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/rulesets/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn includes_parents(self, value: bool) -> Self {
            Self(self.0.query_param("includes_parents", value.to_string()))
        }
    }

    pub struct ReposGetRepoRulesetThen(httpmock::Then);
    impl ReposGetRepoRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposUpdateRepoRulesetWhen(httpmock::When);
    impl ReposUpdateRepoRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/rulesets/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposUpdateRepoRulesetBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposUpdateRepoRulesetThen(httpmock::Then);
    impl ReposUpdateRepoRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryRuleset) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteRepoRulesetWhen(httpmock::When);
    impl ReposDeleteRepoRulesetWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/rulesets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/rulesets/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ruleset_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/rulesets/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteRepoRulesetThen(httpmock::Then);
    impl ReposDeleteRepoRulesetThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningListAlertsForRepoWhen(httpmock::When);
    impl SecretScanningListAlertsForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/secret-scanning/alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/secret-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/secret-scanning/alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::SecretScanningListAlertsForRepoDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn resolution(self, value: &str) -> Self {
            Self(self.0.query_param("resolution", value.to_string()))
        }

        pub fn secret_type(self, value: &str) -> Self {
            Self(self.0.query_param("secret_type", value.to_string()))
        }

        pub fn sort(self, value: types::SecretScanningListAlertsForRepoSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::SecretScanningListAlertsForRepoState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct SecretScanningListAlertsForRepoThen(httpmock::Then);
    impl SecretScanningListAlertsForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SecretScanningAlert>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn service_unavailable(
            self,
            value: &types::SecretScanningListAlertsForRepoResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningGetAlertWhen(httpmock::When);
    impl SecretScanningGetAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/secret-scanning/alerts/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/secret-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/secret-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/secret-scanning/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct SecretScanningGetAlertThen(httpmock::Then);
    impl SecretScanningGetAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SecretScanningAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn service_unavailable(self, value: &types::SecretScanningGetAlertResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningUpdateAlertWhen(httpmock::When);
    impl SecretScanningUpdateAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/repos/.*/.*/secret-scanning/alerts/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/secret-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/secret-scanning/alerts/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/secret-scanning/alerts/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::SecretScanningUpdateAlertBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct SecretScanningUpdateAlertThen(httpmock::Then);
    impl SecretScanningUpdateAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SecretScanningAlert) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }

        pub fn service_unavailable(self, value: &types::SecretScanningUpdateAlertResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecretScanningListLocationsForAlertWhen(httpmock::When);
    impl SecretScanningListLocationsForAlertWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/secret-scanning/alerts/.*/locations$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/secret-scanning/alerts/.*/locations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/secret-scanning/alerts/.*/locations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn alert_number(self, value: &types::AlertNumber) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/secret-scanning/alerts/{}/locations$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct SecretScanningListLocationsForAlertThen(httpmock::Then);
    impl SecretScanningListLocationsForAlertThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SecretScanningLocation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn service_unavailable(
            self,
            value: &types::SecretScanningListLocationsForAlertResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecurityAdvisoriesListRepositoryAdvisoriesWhen(httpmock::When);
    impl SecurityAdvisoriesListRepositoryAdvisoriesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/security-advisories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/security-advisories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/security-advisories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn after(self, value: &str) -> Self {
            Self(self.0.query_param("after", value.to_string()))
        }

        pub fn before(self, value: &str) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(
            self,
            value: types::SecurityAdvisoriesListRepositoryAdvisoriesDirection,
        ) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::SecurityAdvisoriesListRepositoryAdvisoriesSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::SecurityAdvisoriesListRepositoryAdvisoriesState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct SecurityAdvisoriesListRepositoryAdvisoriesThen(httpmock::Then);
    impl SecurityAdvisoriesListRepositoryAdvisoriesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryAdvisory>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecurityAdvisoriesCreateRepositoryAdvisoryWhen(httpmock::When);
    impl SecurityAdvisoriesCreateRepositoryAdvisoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/security-advisories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/security-advisories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/security-advisories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::RepositoryAdvisoryCreate) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct SecurityAdvisoriesCreateRepositoryAdvisoryThen(httpmock::Then);
    impl SecurityAdvisoriesCreateRepositoryAdvisoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RepositoryAdvisory) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecurityAdvisoriesCreatePrivateVulnerabilityReportWhen(httpmock::When);
    impl SecurityAdvisoriesCreatePrivateVulnerabilityReportWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repos/.*/.*/security-advisories/reports$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/security-advisories/reports$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/security-advisories/reports$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::PrivateVulnerabilityReportCreate) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct SecurityAdvisoriesCreatePrivateVulnerabilityReportThen(httpmock::Then);
    impl SecurityAdvisoriesCreatePrivateVulnerabilityReportThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::RepositoryAdvisory) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecurityAdvisoriesGetRepositoryAdvisoryWhen(httpmock::When);
    impl SecurityAdvisoriesGetRepositoryAdvisoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/security-advisories/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/security-advisories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/security-advisories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ghsa_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/security-advisories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct SecurityAdvisoriesGetRepositoryAdvisoryThen(httpmock::Then);
    impl SecurityAdvisoriesGetRepositoryAdvisoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryAdvisory) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SecurityAdvisoriesUpdateRepositoryAdvisoryWhen(httpmock::When);
    impl SecurityAdvisoriesUpdateRepositoryAdvisoryWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new("^/repos/.*/.*/security-advisories/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/security-advisories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/security-advisories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ghsa_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/security-advisories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::RepositoryAdvisoryUpdate) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct SecurityAdvisoriesUpdateRepositoryAdvisoryThen(httpmock::Then);
    impl SecurityAdvisoriesUpdateRepositoryAdvisoryThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositoryAdvisory) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListStargazersForRepoWhen(httpmock::When);
    impl ActivityListStargazersForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/stargazers$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/stargazers$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/stargazers$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListStargazersForRepoThen(httpmock::Then);
    impl ActivityListStargazersForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActivityListStargazersForRepoResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetCodeFrequencyStatsWhen(httpmock::When);
    impl ReposGetCodeFrequencyStatsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/stats/code_frequency$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/stats/code_frequency$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/stats/code_frequency$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCodeFrequencyStatsThen(httpmock::Then);
    impl ReposGetCodeFrequencyStatsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeFrequencyStat>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetCommitActivityStatsWhen(httpmock::When);
    impl ReposGetCommitActivityStatsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/stats/commit_activity$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/stats/commit_activity$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/stats/commit_activity$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetCommitActivityStatsThen(httpmock::Then);
    impl ReposGetCommitActivityStatsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CommitActivity>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetContributorsStatsWhen(httpmock::When);
    impl ReposGetContributorsStatsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/stats/contributors$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/stats/contributors$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/stats/contributors$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetContributorsStatsThen(httpmock::Then);
    impl ReposGetContributorsStatsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ContributorActivity>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposGetParticipationStatsWhen(httpmock::When);
    impl ReposGetParticipationStatsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/stats/participation$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/stats/participation$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/stats/participation$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetParticipationStatsThen(httpmock::Then);
    impl ReposGetParticipationStatsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ParticipationStats) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetPunchCardStatsWhen(httpmock::When);
    impl ReposGetPunchCardStatsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/stats/punch_card$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/stats/punch_card$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/stats/punch_card$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetPunchCardStatsThen(httpmock::Then);
    impl ReposGetPunchCardStatsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::CodeFrequencyStat>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposCreateCommitStatusWhen(httpmock::When);
    impl ReposCreateCommitStatusWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/statuses/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/statuses/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/statuses/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn sha(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/statuses/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateCommitStatusBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateCommitStatusThen(httpmock::Then);
    impl ReposCreateCommitStatusThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Status) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListWatchersForRepoWhen(httpmock::When);
    impl ActivityListWatchersForRepoWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/subscribers$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/subscribers$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/subscribers$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListWatchersForRepoThen(httpmock::Then);
    impl ActivityListWatchersForRepoThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityGetRepoSubscriptionWhen(httpmock::When);
    impl ActivityGetRepoSubscriptionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/subscription$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityGetRepoSubscriptionThen(httpmock::Then);
    impl ActivityGetRepoSubscriptionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositorySubscription) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivitySetRepoSubscriptionWhen(httpmock::When);
    impl ActivitySetRepoSubscriptionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/subscription$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActivitySetRepoSubscriptionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActivitySetRepoSubscriptionThen(httpmock::Then);
    impl ActivitySetRepoSubscriptionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::RepositorySubscription) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityDeleteRepoSubscriptionWhen(httpmock::When);
    impl ActivityDeleteRepoSubscriptionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/subscription$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/subscription$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityDeleteRepoSubscriptionThen(httpmock::Then);
    impl ActivityDeleteRepoSubscriptionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposListTagsWhen(httpmock::When);
    impl ReposListTagsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/tags$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/tags$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/tags$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListTagsThen(httpmock::Then);
    impl ReposListTagsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Tag>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListTagProtectionWhen(httpmock::When);
    impl ReposListTagProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/tags/protection$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/tags/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/tags/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposListTagProtectionThen(httpmock::Then);
    impl ReposListTagProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TagProtection>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateTagProtectionWhen(httpmock::When);
    impl ReposCreateTagProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/tags/protection$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/tags/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/tags/protection$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateTagProtectionBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateTagProtectionThen(httpmock::Then);
    impl ReposCreateTagProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TagProtection) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeleteTagProtectionWhen(httpmock::When);
    impl ReposDeleteTagProtectionWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/tags/protection/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/tags/protection/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/tags/protection/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn tag_protection_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/.*/tags/protection/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeleteTagProtectionThen(httpmock::Then);
    impl ReposDeleteTagProtectionThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDownloadTarballArchiveWhen(httpmock::When);
    impl ReposDownloadTarballArchiveWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/tarball/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/tarball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/tarball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/tarball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDownloadTarballArchiveThen(httpmock::Then);
    impl ReposDownloadTarballArchiveThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ReposListTeamsWhen(httpmock::When);
    impl ReposListTeamsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/teams$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/teams$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListTeamsThen(httpmock::Then);
    impl ReposListTeamsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetAllTopicsWhen(httpmock::When);
    impl ReposGetAllTopicsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/topics$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/topics$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/topics$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposGetAllTopicsThen(httpmock::Then);
    impl ReposGetAllTopicsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Topic) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposReplaceAllTopicsWhen(httpmock::When);
    impl ReposReplaceAllTopicsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/topics$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/topics$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/topics$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposReplaceAllTopicsBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposReplaceAllTopicsThen(httpmock::Then);
    impl ReposReplaceAllTopicsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Topic) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetClonesWhen(httpmock::When);
    impl ReposGetClonesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/traffic/clones$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/traffic/clones$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/traffic/clones$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn per(self, value: types::ReposGetClonesPer) -> Self {
            Self(self.0.query_param("per", value.to_string()))
        }
    }

    pub struct ReposGetClonesThen(httpmock::Then);
    impl ReposGetClonesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CloneTraffic) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetTopPathsWhen(httpmock::When);
    impl ReposGetTopPathsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/traffic/popular/paths$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/traffic/popular/paths$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/traffic/popular/paths$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetTopPathsThen(httpmock::Then);
    impl ReposGetTopPathsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ContentTraffic>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetTopReferrersWhen(httpmock::When);
    impl ReposGetTopReferrersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repos/.*/.*/traffic/popular/referrers$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/traffic/popular/referrers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/traffic/popular/referrers$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposGetTopReferrersThen(httpmock::Then);
    impl ReposGetTopReferrersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::ReferrerTraffic>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposGetViewsWhen(httpmock::When);
    impl ReposGetViewsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/traffic/views$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/traffic/views$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/traffic/views$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn per(self, value: types::ReposGetViewsPer) -> Self {
            Self(self.0.query_param("per", value.to_string()))
        }
    }

    pub struct ReposGetViewsThen(httpmock::Then);
    impl ReposGetViewsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ViewTraffic) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposTransferWhen(httpmock::When);
    impl ReposTransferWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/transfer$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/transfer$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/transfer$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposTransferBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposTransferThen(httpmock::Then);
    impl ReposTransferThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::MinimalRepository) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCheckVulnerabilityAlertsWhen(httpmock::When);
    impl ReposCheckVulnerabilityAlertsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/repos/.*/.*/vulnerability-alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposCheckVulnerabilityAlertsThen(httpmock::Then);
    impl ReposCheckVulnerabilityAlertsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct ReposEnableVulnerabilityAlertsWhen(httpmock::When);
    impl ReposEnableVulnerabilityAlertsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PUT).path_matches(
                    regex::Regex::new("^/repos/.*/.*/vulnerability-alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposEnableVulnerabilityAlertsThen(httpmock::Then);
    impl ReposEnableVulnerabilityAlertsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposDisableVulnerabilityAlertsWhen(httpmock::When);
    impl ReposDisableVulnerabilityAlertsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/repos/.*/.*/vulnerability-alerts$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/{}/.*/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repos/.*/{}/vulnerability-alerts$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDisableVulnerabilityAlertsThen(httpmock::Then);
    impl ReposDisableVulnerabilityAlertsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ReposDownloadZipballArchiveWhen(httpmock::When);
    impl ReposDownloadZipballArchiveWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/zipball/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/{}/.*/zipball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/{}/zipball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn ref_(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/repos/.*/.*/zipball/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDownloadZipballArchiveThen(httpmock::Then);
    impl ReposDownloadZipballArchiveThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct ReposCreateUsingTemplateWhen(httpmock::When);
    impl ReposCreateUsingTemplateWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/repos/.*/.*/generate$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn template_owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/{}/.*/generate$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn template_repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/repos/.*/{}/generate$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReposCreateUsingTemplateBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateUsingTemplateThen(httpmock::Then);
    impl ReposCreateUsingTemplateThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Repository) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListPublicWhen(httpmock::When);
    impl ReposListPublicWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/repositories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn since(self, value: i64) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct ReposListPublicThen(httpmock::Then);
    impl ReposListPublicThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct ActionsListEnvironmentSecretsWhen(httpmock::When);
    impl ActionsListEnvironmentSecretsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/secrets$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/secrets$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListEnvironmentSecretsThen(httpmock::Then);
    impl ActionsListEnvironmentSecretsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListEnvironmentSecretsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetEnvironmentPublicKeyWhen(httpmock::When);
    impl ActionsGetEnvironmentPublicKeyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/secrets/public-key$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/secrets/public-key$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetEnvironmentPublicKeyThen(httpmock::Then);
    impl ActionsGetEnvironmentPublicKeyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetEnvironmentSecretWhen(httpmock::When);
    impl ActionsGetEnvironmentSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/secrets/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetEnvironmentSecretThen(httpmock::Then);
    impl ActionsGetEnvironmentSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateOrUpdateEnvironmentSecretWhen(httpmock::When);
    impl ActionsCreateOrUpdateEnvironmentSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/secrets/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateOrUpdateEnvironmentSecretBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateOrUpdateEnvironmentSecretThen(httpmock::Then);
    impl ActionsCreateOrUpdateEnvironmentSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsDeleteEnvironmentSecretWhen(httpmock::When);
    impl ActionsDeleteEnvironmentSecretWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/secrets/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/secrets/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/secrets/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteEnvironmentSecretThen(httpmock::Then);
    impl ActionsDeleteEnvironmentSecretThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsListEnvironmentVariablesWhen(httpmock::When);
    impl ActionsListEnvironmentVariablesWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/variables$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActionsListEnvironmentVariablesThen(httpmock::Then);
    impl ActionsListEnvironmentVariablesThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsListEnvironmentVariablesResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsCreateEnvironmentVariableWhen(httpmock::When);
    impl ActionsCreateEnvironmentVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/variables$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/variables$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsCreateEnvironmentVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsCreateEnvironmentVariableThen(httpmock::Then);
    impl ActionsCreateEnvironmentVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsGetEnvironmentVariableWhen(httpmock::When);
    impl ActionsGetEnvironmentVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/variables/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsGetEnvironmentVariableThen(httpmock::Then);
    impl ActionsGetEnvironmentVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsVariable) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActionsDeleteEnvironmentVariableWhen(httpmock::When);
    impl ActionsDeleteEnvironmentVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/variables/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActionsDeleteEnvironmentVariableThen(httpmock::Then);
    impl ActionsDeleteEnvironmentVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct ActionsUpdateEnvironmentVariableWhen(httpmock::When);
    impl ActionsUpdateEnvironmentVariableWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PATCH).path_matches(
                regex::Regex::new("^/repositories/.*/environments/.*/variables/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/{}/environments/.*/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn environment_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/{}/variables/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/repositories/.*/environments/.*/variables/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ActionsUpdateEnvironmentVariableBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ActionsUpdateEnvironmentVariableThen(httpmock::Then);
    impl ActionsUpdateEnvironmentVariableThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct SearchCodeWhen(httpmock::When);
    impl SearchCodeWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/code$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchCodeOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn sort(self, value: types::SearchCodeSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchCodeThen(httpmock::Then);
    impl SearchCodeThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchCodeResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn service_unavailable(self, value: &types::SearchCodeResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SearchCommitsWhen(httpmock::When);
    impl SearchCommitsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/commits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchCommitsOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn sort(self, value: types::SearchCommitsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchCommitsThen(httpmock::Then);
    impl SearchCommitsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchCommitsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct SearchIssuesAndPullRequestsWhen(httpmock::When);
    impl SearchIssuesAndPullRequestsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchIssuesAndPullRequestsOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn sort(self, value: types::SearchIssuesAndPullRequestsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchIssuesAndPullRequestsThen(httpmock::Then);
    impl SearchIssuesAndPullRequestsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchIssuesAndPullRequestsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::SearchIssuesAndPullRequestsResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SearchLabelsWhen(httpmock::When);
    impl SearchLabelsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/labels$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchLabelsOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn repository_id(self, value: i64) -> Self {
            Self(self.0.query_param("repository_id", value.to_string()))
        }

        pub fn sort(self, value: types::SearchLabelsSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchLabelsThen(httpmock::Then);
    impl SearchLabelsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchLabelsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct SearchReposWhen(httpmock::When);
    impl SearchReposWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/repositories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchReposOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn sort(self, value: types::SearchReposSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchReposThen(httpmock::Then);
    impl SearchReposThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchReposResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(self, value: &types::SearchReposResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct SearchTopicsWhen(httpmock::When);
    impl SearchTopicsWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/topics$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }
    }

    pub struct SearchTopicsThen(httpmock::Then);
    impl SearchTopicsThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchTopicsResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct SearchUsersWhen(httpmock::When);
    impl SearchUsersWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/search/users$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn order(self, value: types::SearchUsersOrder) -> Self {
            Self(self.0.query_param("order", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn q(self, value: &str) -> Self {
            Self(self.0.query_param("q", value.to_string()))
        }

        pub fn sort(self, value: types::SearchUsersSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct SearchUsersThen(httpmock::Then);
    impl SearchUsersThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SearchUsersResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn service_unavailable(self, value: &types::SearchUsersResponse) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetLegacyWhen(httpmock::When);
    impl TeamsGetLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetLegacyThen(httpmock::Then);
    impl TeamsGetLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteLegacyWhen(httpmock::When);
    impl TeamsDeleteLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteLegacyThen(httpmock::Then);
    impl TeamsDeleteLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsUpdateLegacyWhen(httpmock::When);
    impl TeamsUpdateLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/teams/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateLegacyThen(httpmock::Then);
    impl TeamsUpdateLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn created(self, value: &types::TeamFull) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListDiscussionsLegacyWhen(httpmock::When);
    impl TeamsListDiscussionsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/discussions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/discussions$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::TeamsListDiscussionsLegacyDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListDiscussionsLegacyThen(httpmock::Then);
    impl TeamsListDiscussionsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamDiscussion>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCreateDiscussionLegacyWhen(httpmock::When);
    impl TeamsCreateDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/teams/.*/discussions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/discussions$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsCreateDiscussionLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsCreateDiscussionLegacyThen(httpmock::Then);
    impl TeamsCreateDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetDiscussionLegacyWhen(httpmock::When);
    impl TeamsGetDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/discussions/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/discussions/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetDiscussionLegacyThen(httpmock::Then);
    impl TeamsGetDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteDiscussionLegacyWhen(httpmock::When);
    impl TeamsDeleteDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/discussions/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/discussions/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteDiscussionLegacyThen(httpmock::Then);
    impl TeamsDeleteDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsUpdateDiscussionLegacyWhen(httpmock::When);
    impl TeamsUpdateDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/teams/.*/discussions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/discussions/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/discussions/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateDiscussionLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateDiscussionLegacyThen(httpmock::Then);
    impl TeamsUpdateDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListDiscussionCommentsLegacyWhen(httpmock::When);
    impl TeamsListDiscussionCommentsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/comments$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::TeamsListDiscussionCommentsLegacyDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListDiscussionCommentsLegacyThen(httpmock::Then);
    impl TeamsListDiscussionCommentsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamDiscussionComment>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCreateDiscussionCommentLegacyWhen(httpmock::When);
    impl TeamsCreateDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/comments$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsCreateDiscussionCommentLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsCreateDiscussionCommentLegacyThen(httpmock::Then);
    impl TeamsCreateDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetDiscussionCommentLegacyWhen(httpmock::When);
    impl TeamsGetDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/comments/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetDiscussionCommentLegacyThen(httpmock::Then);
    impl TeamsGetDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsDeleteDiscussionCommentLegacyWhen(httpmock::When);
    impl TeamsDeleteDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/comments/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsDeleteDiscussionCommentLegacyThen(httpmock::Then);
    impl TeamsDeleteDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsUpdateDiscussionCommentLegacyWhen(httpmock::When);
    impl TeamsUpdateDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::PATCH).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/comments/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/.*/comments/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsUpdateDiscussionCommentLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsUpdateDiscussionCommentLegacyThen(httpmock::Then);
    impl TeamsUpdateDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamDiscussionComment) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForTeamDiscussionCommentLegacyWhen(httpmock::When);
    impl ReactionsListForTeamDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/teams/.*/discussions/.*/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(
            self,
            value: types::ReactionsListForTeamDiscussionCommentLegacyContent,
        ) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForTeamDiscussionCommentLegacyThen(httpmock::Then);
    impl ReactionsListForTeamDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForTeamDiscussionCommentLegacyWhen(httpmock::When);
    impl ReactionsCreateForTeamDiscussionCommentLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/teams/.*/discussions/.*/comments/.*/reactions$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/comments/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn comment_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/.*/comments/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::ReactionsCreateForTeamDiscussionCommentLegacyBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForTeamDiscussionCommentLegacyThen(httpmock::Then);
    impl ReactionsCreateForTeamDiscussionCommentLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsListForTeamDiscussionLegacyWhen(httpmock::When);
    impl ReactionsListForTeamDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn content(self, value: types::ReactionsListForTeamDiscussionLegacyContent) -> Self {
            Self(self.0.query_param("content", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReactionsListForTeamDiscussionLegacyThen(httpmock::Then);
    impl ReactionsListForTeamDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Reaction>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReactionsCreateForTeamDiscussionLegacyWhen(httpmock::When);
    impl ReactionsCreateForTeamDiscussionLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::POST).path_matches(
                    regex::Regex::new("^/teams/.*/discussions/.*/reactions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/{}/discussions/.*/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn discussion_number(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/teams/.*/discussions/{}/reactions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::ReactionsCreateForTeamDiscussionLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReactionsCreateForTeamDiscussionLegacyThen(httpmock::Then);
    impl ReactionsCreateForTeamDiscussionLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Reaction) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListPendingInvitationsLegacyWhen(httpmock::When);
    impl TeamsListPendingInvitationsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/invitations$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListPendingInvitationsLegacyThen(httpmock::Then);
    impl TeamsListPendingInvitationsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListMembersLegacyWhen(httpmock::When);
    impl TeamsListMembersLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/members$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/members$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn role(self, value: types::TeamsListMembersLegacyRole) -> Self {
            Self(self.0.query_param("role", value.to_string()))
        }
    }

    pub struct TeamsListMembersLegacyThen(httpmock::Then);
    impl TeamsListMembersLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsGetMemberLegacyWhen(httpmock::When);
    impl TeamsGetMemberLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/members/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/members/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetMemberLegacyThen(httpmock::Then);
    impl TeamsGetMemberLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddMemberLegacyWhen(httpmock::When);
    impl TeamsAddMemberLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/teams/.*/members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/members/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/members/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsAddMemberLegacyThen(httpmock::Then);
    impl TeamsAddMemberLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsRemoveMemberLegacyWhen(httpmock::When);
    impl TeamsRemoveMemberLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*/members/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/members/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/members/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveMemberLegacyThen(httpmock::Then);
    impl TeamsRemoveMemberLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsGetMembershipForUserLegacyWhen(httpmock::When);
    impl TeamsGetMembershipForUserLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsGetMembershipForUserLegacyThen(httpmock::Then);
    impl TeamsGetMembershipForUserLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsAddOrUpdateMembershipForUserLegacyWhen(httpmock::When);
    impl TeamsAddOrUpdateMembershipForUserLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateMembershipForUserLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateMembershipForUserLegacyThen(httpmock::Then);
    impl TeamsAddOrUpdateMembershipForUserLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }

        pub fn unprocessable_entity(self) -> Self {
            Self(self.0.status(422u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsRemoveMembershipForUserLegacyWhen(httpmock::When);
    impl TeamsRemoveMembershipForUserLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*/memberships/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/memberships/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/teams/.*/memberships/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveMembershipForUserLegacyThen(httpmock::Then);
    impl TeamsRemoveMembershipForUserLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self) -> Self {
            Self(self.0.status(403u16))
        }
    }

    pub struct TeamsListProjectsLegacyWhen(httpmock::When);
    impl TeamsListProjectsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListProjectsLegacyThen(httpmock::Then);
    impl TeamsListProjectsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamProject>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCheckPermissionsForProjectLegacyWhen(httpmock::When);
    impl TeamsCheckPermissionsForProjectLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/projects/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsCheckPermissionsForProjectLegacyThen(httpmock::Then);
    impl TeamsCheckPermissionsForProjectLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamProject) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddOrUpdateProjectPermissionsLegacyWhen(httpmock::When);
    impl TeamsAddOrUpdateProjectPermissionsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/projects/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateProjectPermissionsLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateProjectPermissionsLegacyThen(httpmock::Then);
    impl TeamsAddOrUpdateProjectPermissionsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(
            self,
            value: &types::TeamsAddOrUpdateProjectPermissionsLegacyResponse,
        ) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsRemoveProjectLegacyWhen(httpmock::When);
    impl TeamsRemoveProjectLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*/projects/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/projects/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn project_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/projects/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveProjectLegacyThen(httpmock::Then);
    impl TeamsRemoveProjectLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListReposLegacyWhen(httpmock::When);
    impl TeamsListReposLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/repos$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListReposLegacyThen(httpmock::Then);
    impl TeamsListReposLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsCheckPermissionsForRepoLegacyWhen(httpmock::When);
    impl TeamsCheckPermissionsForRepoLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/repos/.*/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsCheckPermissionsForRepoLegacyThen(httpmock::Then);
    impl TeamsCheckPermissionsForRepoLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::TeamRepository) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct TeamsAddOrUpdateRepoPermissionsLegacyWhen(httpmock::When);
    impl TeamsAddOrUpdateRepoPermissionsLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/repos/.*/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::TeamsAddOrUpdateRepoPermissionsLegacyBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct TeamsAddOrUpdateRepoPermissionsLegacyThen(httpmock::Then);
    impl TeamsAddOrUpdateRepoPermissionsLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsRemoveRepoLegacyWhen(httpmock::When);
    impl TeamsRemoveRepoLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/teams/.*/repos/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/{}/repos/.*/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/teams/.*/repos/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct TeamsRemoveRepoLegacyThen(httpmock::Then);
    impl TeamsRemoveRepoLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct TeamsListChildLegacyWhen(httpmock::When);
    impl TeamsListChildLegacyWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/teams/.*/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn team_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/teams/{}/teams$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListChildLegacyThen(httpmock::Then);
    impl TeamsListChildLegacyThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Team>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersGetAuthenticatedWhen(httpmock::When);
    impl UsersGetAuthenticatedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct UsersGetAuthenticatedThen(httpmock::Then);
    impl UsersGetAuthenticatedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::UsersGetAuthenticatedResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersUpdateAuthenticatedWhen(httpmock::When);
    impl UsersUpdateAuthenticatedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/user$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersUpdateAuthenticatedBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersUpdateAuthenticatedThen(httpmock::Then);
    impl UsersUpdateAuthenticatedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PrivateUser) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListBlockedByAuthenticatedUserWhen(httpmock::When);
    impl UsersListBlockedByAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/blocks$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListBlockedByAuthenticatedUserThen(httpmock::Then);
    impl UsersListBlockedByAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCheckBlockedWhen(httpmock::When);
    impl UsersCheckBlockedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersCheckBlockedThen(httpmock::Then);
    impl UsersCheckBlockedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersBlockWhen(httpmock::When);
    impl UsersBlockWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/user/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersBlockThen(httpmock::Then);
    impl UsersBlockThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersUnblockWhen(httpmock::When);
    impl UsersUnblockWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/blocks/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/blocks/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersUnblockThen(httpmock::Then);
    impl UsersUnblockThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn repository_id(self, value: i64) -> Self {
            Self(self.0.query_param("repository_id", value.to_string()))
        }
    }

    pub struct CodespacesListForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListForAuthenticatedUserResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesCreateForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/codespaces$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::CodespacesCreateForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesCreateForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn accepted(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn service_unavailable(
            self,
            value: &types::CodespacesCreateForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(503u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesListSecretsForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesListSecretsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces/secrets$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct CodespacesListSecretsForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesListSecretsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesListSecretsForAuthenticatedUserResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetPublicKeyForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesGetPublicKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/user/codespaces/secrets/public-key$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct CodespacesGetPublicKeyForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesGetPublicKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesUserPublicKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesGetSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesGetSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespacesSecret) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCreateOrUpdateSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesCreateOrUpdateSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/user/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::CodespacesCreateOrUpdateSecretForAuthenticatedUserBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesCreateOrUpdateSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesCreateOrUpdateSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::EmptyObject) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesDeleteSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesDeleteSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/codespaces/secrets/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/secrets/{}$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesDeleteSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesDeleteSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct CodespacesListRepositoriesForSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesListRepositoriesForSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/user/codespaces/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesListRepositoriesForSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesListRepositoriesForSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::CodespacesListRepositoriesForSecretForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesSetRepositoriesForSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesSetRepositoriesForSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/user/codespaces/secrets/.*/repositories$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(
            self,
            value: &types::CodespacesSetRepositoriesForSecretForAuthenticatedUserBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesSetRepositoriesForSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesSetRepositoriesForSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesAddRepositoryForSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesAddRepositoryForSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/user/codespaces/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesAddRepositoryForSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesAddRepositoryForSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesRemoveRepositoryForSecretForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesRemoveRepositoryForSecretForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/user/codespaces/secrets/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn secret_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/secrets/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesRemoveRepositoryForSecretForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesRemoveRepositoryForSecretForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesGetForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesGetForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesDeleteForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesDeleteForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesDeleteForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesDeleteForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(
            self,
            value: &std::collections::HashMap<String, serde_json::Value>,
        ) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesUpdateForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesUpdateForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesUpdateForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesUpdateForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesUpdateForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesExportForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesExportForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/exports$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/{}/exports$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesExportForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesExportForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn accepted(self, value: &types::CodespaceExportDetails) -> Self {
            Self(
                self.0
                    .status(202u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesGetExportDetailsForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesGetExportDetailsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/exports/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/{}/exports/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn export_id(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/.*/exports/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesGetExportDetailsForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesGetExportDetailsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CodespaceExportDetails) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesCodespaceMachinesForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesCodespaceMachinesForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/machines$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/codespaces/{}/machines$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesCodespaceMachinesForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesCodespaceMachinesForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::CodespacesCodespaceMachinesForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesPublishForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesPublishForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/publish$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/codespaces/{}/publish$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::CodespacesPublishForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct CodespacesPublishForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesPublishForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::CodespaceWithFullRepository) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesStartForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesStartForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/start$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/codespaces/{}/start$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesStartForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesStartForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn payment_required(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(402u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct CodespacesStopForAuthenticatedUserWhen(httpmock::When);
    impl CodespacesStopForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/codespaces/.*/stop$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn codespace_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/codespaces/{}/stop$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct CodespacesStopForAuthenticatedUserThen(httpmock::Then);
    impl CodespacesStopForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Codespace) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn internal_server_error(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(500u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserWhen(
        httpmock::When,
    );
    impl PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/docker/conflicts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserThen(
        httpmock::Then,
    );
    impl PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersSetPrimaryEmailVisibilityForAuthenticatedUserWhen(httpmock::When);
    impl UsersSetPrimaryEmailVisibilityForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/user/email/visibility$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(
            self,
            value: &types::UsersSetPrimaryEmailVisibilityForAuthenticatedUserBody,
        ) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersSetPrimaryEmailVisibilityForAuthenticatedUserThen(httpmock::Then);
    impl UsersSetPrimaryEmailVisibilityForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Email>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListEmailsForAuthenticatedUserWhen(httpmock::When);
    impl UsersListEmailsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/emails$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListEmailsForAuthenticatedUserThen(httpmock::Then);
    impl UsersListEmailsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Email>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersAddEmailForAuthenticatedUserWhen(httpmock::When);
    impl UsersAddEmailForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/emails$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersAddEmailForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersAddEmailForAuthenticatedUserThen(httpmock::Then);
    impl UsersAddEmailForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &Vec<types::Email>) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersDeleteEmailForAuthenticatedUserWhen(httpmock::When);
    impl UsersDeleteEmailForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/emails$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersDeleteEmailForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersDeleteEmailForAuthenticatedUserThen(httpmock::Then);
    impl UsersDeleteEmailForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListFollowersForAuthenticatedUserWhen(httpmock::When);
    impl UsersListFollowersForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/followers$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListFollowersForAuthenticatedUserThen(httpmock::Then);
    impl UsersListFollowersForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListFollowedByAuthenticatedUserWhen(httpmock::When);
    impl UsersListFollowedByAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/following$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListFollowedByAuthenticatedUserThen(httpmock::Then);
    impl UsersListFollowedByAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCheckPersonIsFollowedByAuthenticatedWhen(httpmock::When);
    impl UsersCheckPersonIsFollowedByAuthenticatedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/following/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/following/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersCheckPersonIsFollowedByAuthenticatedThen(httpmock::Then);
    impl UsersCheckPersonIsFollowedByAuthenticatedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersFollowWhen(httpmock::When);
    impl UsersFollowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/user/following/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/following/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersFollowThen(httpmock::Then);
    impl UsersFollowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersUnfollowWhen(httpmock::When);
    impl UsersUnfollowWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/following/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/following/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersUnfollowThen(httpmock::Then);
    impl UsersUnfollowThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListGpgKeysForAuthenticatedUserWhen(httpmock::When);
    impl UsersListGpgKeysForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/gpg_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListGpgKeysForAuthenticatedUserThen(httpmock::Then);
    impl UsersListGpgKeysForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GpgKey>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCreateGpgKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersCreateGpgKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/gpg_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersCreateGpgKeyForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersCreateGpgKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersCreateGpgKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::GpgKey) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersGetGpgKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersGetGpgKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/gpg_keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gpg_key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/gpg_keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersGetGpgKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersGetGpgKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::GpgKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersDeleteGpgKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersDeleteGpgKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/gpg_keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn gpg_key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/gpg_keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersDeleteGpgKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersDeleteGpgKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListInstallationsForAuthenticatedUserWhen(httpmock::When);
    impl AppsListInstallationsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/installations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListInstallationsForAuthenticatedUserThen(httpmock::Then);
    impl AppsListInstallationsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::AppsListInstallationsForAuthenticatedUserResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListInstallationReposForAuthenticatedUserWhen(httpmock::When);
    impl AppsListInstallationReposForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/user/installations/.*/repositories$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/installations/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListInstallationReposForAuthenticatedUserThen(httpmock::Then);
    impl AppsListInstallationReposForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::AppsListInstallationReposForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct AppsAddRepoToInstallationForAuthenticatedUserWhen(httpmock::When);
    impl AppsAddRepoToInstallationForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::PUT).path_matches(
                regex::Regex::new("^/user/installations/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/installations/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/installations/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsAddRepoToInstallationForAuthenticatedUserThen(httpmock::Then);
    impl AppsAddRepoToInstallationForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsRemoveRepoFromInstallationForAuthenticatedUserWhen(httpmock::When);
    impl AppsRemoveRepoFromInstallationForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::DELETE).path_matches(
                regex::Regex::new("^/user/installations/.*/repositories/.*$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn installation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/installations/{}/repositories/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repository_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/installations/.*/repositories/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsRemoveRepoFromInstallationForAuthenticatedUserThen(httpmock::Then);
    impl AppsRemoveRepoFromInstallationForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsGetRestrictionsForAuthenticatedUserWhen(httpmock::When);
    impl InteractionsGetRestrictionsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct InteractionsGetRestrictionsForAuthenticatedUserThen(httpmock::Then);
    impl InteractionsGetRestrictionsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(
            self,
            value: &types::InteractionsGetRestrictionsForAuthenticatedUserResponse,
        ) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct InteractionsSetRestrictionsForAuthenticatedUserWhen(httpmock::When);
    impl InteractionsSetRestrictionsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/user/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::InteractionLimit) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct InteractionsSetRestrictionsForAuthenticatedUserThen(httpmock::Then);
    impl InteractionsSetRestrictionsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::InteractionLimitResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct InteractionsRemoveRestrictionsForAuthenticatedUserWhen(httpmock::When);
    impl InteractionsRemoveRestrictionsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/interaction-limits$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }
    }

    pub struct InteractionsRemoveRestrictionsForAuthenticatedUserThen(httpmock::Then);
    impl InteractionsRemoveRestrictionsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }
    }

    pub struct IssuesListForAuthenticatedUserWhen(httpmock::When);
    impl IssuesListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/issues$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn direction(self, value: types::IssuesListForAuthenticatedUserDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn filter(self, value: types::IssuesListForAuthenticatedUserFilter) -> Self {
            Self(self.0.query_param("filter", value.to_string()))
        }

        pub fn labels(self, value: &str) -> Self {
            Self(self.0.query_param("labels", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::IssuesListForAuthenticatedUserSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn state(self, value: types::IssuesListForAuthenticatedUserState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct IssuesListForAuthenticatedUserThen(httpmock::Then);
    impl IssuesListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Issue>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct UsersListPublicSshKeysForAuthenticatedUserWhen(httpmock::When);
    impl UsersListPublicSshKeysForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListPublicSshKeysForAuthenticatedUserThen(httpmock::Then);
    impl UsersListPublicSshKeysForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Key>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCreatePublicSshKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersCreatePublicSshKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersCreatePublicSshKeyForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersCreatePublicSshKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersCreatePublicSshKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Key) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersGetPublicSshKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersGetPublicSshKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersGetPublicSshKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersGetPublicSshKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Key) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersDeletePublicSshKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersDeletePublicSshKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/keys/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersDeletePublicSshKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersDeletePublicSshKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListSubscriptionsForAuthenticatedUserWhen(httpmock::When);
    impl AppsListSubscriptionsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/marketplace_purchases$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListSubscriptionsForAuthenticatedUserThen(httpmock::Then);
    impl AppsListSubscriptionsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::UserMarketplacePurchase>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsListSubscriptionsForAuthenticatedUserStubbedWhen(httpmock::When);
    impl AppsListSubscriptionsForAuthenticatedUserStubbedWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/user/marketplace_purchases/stubbed$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct AppsListSubscriptionsForAuthenticatedUserStubbedThen(httpmock::Then);
    impl AppsListSubscriptionsForAuthenticatedUserStubbedThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::UserMarketplacePurchase>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListMembershipsForAuthenticatedUserWhen(httpmock::When);
    impl OrgsListMembershipsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/memberships/orgs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(self, value: types::OrgsListMembershipsForAuthenticatedUserState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct OrgsListMembershipsForAuthenticatedUserThen(httpmock::Then);
    impl OrgsListMembershipsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrgMembership>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsGetMembershipForAuthenticatedUserWhen(httpmock::When);
    impl OrgsGetMembershipForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/memberships/orgs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/memberships/orgs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct OrgsGetMembershipForAuthenticatedUserThen(httpmock::Then);
    impl OrgsGetMembershipForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsUpdateMembershipForAuthenticatedUserWhen(httpmock::When);
    impl OrgsUpdateMembershipForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/user/memberships/orgs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/user/memberships/orgs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn body(self, value: &types::OrgsUpdateMembershipForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct OrgsUpdateMembershipForAuthenticatedUserThen(httpmock::Then);
    impl OrgsUpdateMembershipForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::OrgMembership) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsListForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/migrations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct MigrationsListForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Migration>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsStartForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsStartForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/migrations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::MigrationsStartForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct MigrationsStartForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsStartForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Migration) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetStatusForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsGetStatusForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/migrations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/migrations/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn exclude(self, value: &Vec<String>) -> Self {
            Self(self.0.query_param("exclude", value.to_string()))
        }
    }

    pub struct MigrationsGetStatusForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsGetStatusForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Migration) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsGetArchiveForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsGetArchiveForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/migrations/.*/archive$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/migrations/{}/archive$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsGetArchiveForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsGetArchiveForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn found(self) -> Self {
            Self(self.0.status(302u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn success(self, status: u16, value: serde_json::Value) -> Self {
            assert_eq!(status / 100u16, 2u16);
            Self(
                self.0
                    .status(status)
                    .header("content-type", "application/json")
                    .json_body(value),
            )
        }
    }

    pub struct MigrationsDeleteArchiveForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsDeleteArchiveForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/migrations/.*/archive$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/migrations/{}/archive$", value.to_string()))
                    .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsDeleteArchiveForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsDeleteArchiveForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsUnlockRepoForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsUnlockRepoForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/user/migrations/.*/repos/.*/lock$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/migrations/{}/repos/.*/lock$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/migrations/.*/repos/{}/lock$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct MigrationsUnlockRepoForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsUnlockRepoForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct MigrationsListReposForAuthenticatedUserWhen(httpmock::When);
    impl MigrationsListReposForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/migrations/.*/repositories$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn migration_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/migrations/{}/repositories$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct MigrationsListReposForAuthenticatedUserThen(httpmock::Then);
    impl MigrationsListReposForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListForAuthenticatedUserWhen(httpmock::When);
    impl OrgsListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/orgs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListForAuthenticatedUserThen(httpmock::Then);
    impl OrgsListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesListPackagesForAuthenticatedUserWhen(httpmock::When);
    impl PackagesListPackagesForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/packages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesListPackagesForAuthenticatedUserPackageType,
        ) -> Self {
            Self(self.0.query_param("package_type", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn visibility(
            self,
            value: types::PackagesListPackagesForAuthenticatedUserVisibility,
        ) -> Self {
            Self(self.0.query_param("visibility", value.to_string()))
        }
    }

    pub struct PackagesListPackagesForAuthenticatedUserThen(httpmock::Then);
    impl PackagesListPackagesForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }
    }

    pub struct PackagesGetPackageForAuthenticatedUserWhen(httpmock::When);
    impl PackagesGetPackageForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesGetPackageForAuthenticatedUserPackageType,
        ) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/packages/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/packages/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageForAuthenticatedUserThen(httpmock::Then);
    impl PackagesGetPackageForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Package) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageForAuthenticatedUserWhen(httpmock::When);
    impl PackagesDeletePackageForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesDeletePackageForAuthenticatedUserPackageType,
        ) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/packages/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/packages/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageForAuthenticatedUserThen(httpmock::Then);
    impl PackagesDeletePackageForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageForAuthenticatedUserWhen(httpmock::When);
    impl PackagesRestorePackageForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*/restore$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesRestorePackageForAuthenticatedUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/{}/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn token(self, value: &str) -> Self {
            Self(self.0.query_param("token", value.to_string()))
        }
    }

    pub struct PackagesRestorePackageForAuthenticatedUserThen(httpmock::Then);
    impl PackagesRestorePackageForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWhen(httpmock::When);
    impl PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*/versions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value : types :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/{}/.*/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/{}/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(
            self,
            value: types::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserState,
        ) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserThen(httpmock::Then);
    impl PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PackageVersion>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetPackageVersionForAuthenticatedUserWhen(httpmock::When);
    impl PackagesGetPackageVersionForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*/versions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesGetPackageVersionForAuthenticatedUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageVersionForAuthenticatedUserThen(httpmock::Then);
    impl PackagesGetPackageVersionForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PackageVersion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageVersionForAuthenticatedUserWhen(httpmock::When);
    impl PackagesDeletePackageVersionForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/packages/.*/.*/versions/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesDeletePackageVersionForAuthenticatedUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageVersionForAuthenticatedUserThen(httpmock::Then);
    impl PackagesDeletePackageVersionForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageVersionForAuthenticatedUserWhen(httpmock::When);
    impl PackagesRestorePackageVersionForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/user/packages/.*/.*/versions/.*/restore$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn package_type(
            self,
            value: types::PackagesRestorePackageVersionForAuthenticatedUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/{}/.*/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/{}/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/packages/.*/.*/versions/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesRestorePackageVersionForAuthenticatedUserThen(httpmock::Then);
    impl PackagesRestorePackageVersionForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsCreateForAuthenticatedUserWhen(httpmock::When);
    impl ProjectsCreateForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::ProjectsCreateForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ProjectsCreateForAuthenticatedUserThen(httpmock::Then);
    impl ProjectsCreateForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Project) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationErrorSimple) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListPublicEmailsForAuthenticatedUserWhen(httpmock::When);
    impl UsersListPublicEmailsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/public_emails$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListPublicEmailsForAuthenticatedUserThen(httpmock::Then);
    impl UsersListPublicEmailsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Email>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListForAuthenticatedUserWhen(httpmock::When);
    impl ReposListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn affiliation(self, value: &str) -> Self {
            Self(self.0.query_param("affiliation", value.to_string()))
        }

        pub fn before(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("before", value.to_string()))
        }

        pub fn direction(self, value: types::ReposListForAuthenticatedUserDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }

        pub fn sort(self, value: types::ReposListForAuthenticatedUserSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn type_(self, value: types::ReposListForAuthenticatedUserType) -> Self {
            Self(self.0.query_param("type_", value.to_string()))
        }

        pub fn visibility(self, value: types::ReposListForAuthenticatedUserVisibility) -> Self {
            Self(self.0.query_param("visibility", value.to_string()))
        }
    }

    pub struct ReposListForAuthenticatedUserThen(httpmock::Then);
    impl ReposListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Repository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposCreateForAuthenticatedUserWhen(httpmock::When);
    impl ReposCreateForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::ReposCreateForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct ReposCreateForAuthenticatedUserThen(httpmock::Then);
    impl ReposCreateForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::Repository) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(400u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListInvitationsForAuthenticatedUserWhen(httpmock::When);
    impl ReposListInvitationsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/repository_invitations$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ReposListInvitationsForAuthenticatedUserThen(httpmock::Then);
    impl ReposListInvitationsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::RepositoryInvitation>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposDeclineInvitationForAuthenticatedUserWhen(httpmock::When);
    impl ReposDeclineInvitationForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/repository_invitations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/repository_invitations/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposDeclineInvitationForAuthenticatedUserThen(httpmock::Then);
    impl ReposDeclineInvitationForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposAcceptInvitationForAuthenticatedUserWhen(httpmock::When);
    impl ReposAcceptInvitationForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PATCH)
                    .path_matches(regex::Regex::new("^/user/repository_invitations/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn invitation_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/user/repository_invitations/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ReposAcceptInvitationForAuthenticatedUserThen(httpmock::Then);
    impl ReposAcceptInvitationForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn conflict(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(409u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct UsersListSocialAccountsForAuthenticatedUserWhen(httpmock::When);
    impl UsersListSocialAccountsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/social_accounts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListSocialAccountsForAuthenticatedUserThen(httpmock::Then);
    impl UsersListSocialAccountsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SocialAccount>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersAddSocialAccountForAuthenticatedUserWhen(httpmock::When);
    impl UsersAddSocialAccountForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/social_accounts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersAddSocialAccountForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersAddSocialAccountForAuthenticatedUserThen(httpmock::Then);
    impl UsersAddSocialAccountForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &Vec<types::SocialAccount>) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersDeleteSocialAccountForAuthenticatedUserWhen(httpmock::When);
    impl UsersDeleteSocialAccountForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/social_accounts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersDeleteSocialAccountForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersDeleteSocialAccountForAuthenticatedUserThen(httpmock::Then);
    impl UsersDeleteSocialAccountForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListSshSigningKeysForAuthenticatedUserWhen(httpmock::When);
    impl UsersListSshSigningKeysForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/ssh_signing_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListSshSigningKeysForAuthenticatedUserThen(httpmock::Then);
    impl UsersListSshSigningKeysForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SshSigningKey>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCreateSshSigningKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersCreateSshSigningKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/user/ssh_signing_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn body(self, value: &types::UsersCreateSshSigningKeyForAuthenticatedUserBody) -> Self {
            Self(self.0.json_body_obj(value))
        }
    }

    pub struct UsersCreateSshSigningKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersCreateSshSigningKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn created(self, value: &types::SshSigningKey) -> Self {
            Self(
                self.0
                    .status(201u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersGetSshSigningKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersGetSshSigningKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/ssh_signing_keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn ssh_signing_key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/ssh_signing_keys/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersGetSshSigningKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersGetSshSigningKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::SshSigningKey) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersDeleteSshSigningKeyForAuthenticatedUserWhen(httpmock::When);
    impl UsersDeleteSshSigningKeyForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/ssh_signing_keys/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn ssh_signing_key_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!("^/user/ssh_signing_keys/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersDeleteSshSigningKeyForAuthenticatedUserThen(httpmock::Then);
    impl UsersDeleteSshSigningKeyForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListReposStarredByAuthenticatedUserWhen(httpmock::When);
    impl ActivityListReposStarredByAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/starred$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn direction(
            self,
            value: types::ActivityListReposStarredByAuthenticatedUserDirection,
        ) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::ActivityListReposStarredByAuthenticatedUserSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }
    }

    pub struct ActivityListReposStarredByAuthenticatedUserThen(httpmock::Then);
    impl ActivityListReposStarredByAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Repository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityCheckRepoIsStarredByAuthenticatedUserWhen(httpmock::When);
    impl ActivityCheckRepoIsStarredByAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/starred/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityCheckRepoIsStarredByAuthenticatedUserThen(httpmock::Then);
    impl ActivityCheckRepoIsStarredByAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityStarRepoForAuthenticatedUserWhen(httpmock::When);
    impl ActivityStarRepoForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::PUT)
                    .path_matches(regex::Regex::new("^/user/starred/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityStarRepoForAuthenticatedUserThen(httpmock::Then);
    impl ActivityStarRepoForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct ActivityUnstarRepoForAuthenticatedUserWhen(httpmock::When);
    impl ActivityUnstarRepoForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/user/starred/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn owner(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/{}/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn repo(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/user/starred/.*/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct ActivityUnstarRepoForAuthenticatedUserThen(httpmock::Then);
    impl ActivityUnstarRepoForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListWatchedReposForAuthenticatedUserWhen(httpmock::When);
    impl ActivityListWatchedReposForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/subscriptions$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListWatchedReposForAuthenticatedUserThen(httpmock::Then);
    impl ActivityListWatchedReposForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct TeamsListForAuthenticatedUserWhen(httpmock::When);
    impl TeamsListForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/user/teams$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct TeamsListForAuthenticatedUserThen(httpmock::Then);
    impl TeamsListForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::TeamFull>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListWhen(httpmock::When);
    impl UsersListWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: i64) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct UsersListThen(httpmock::Then);
    impl UsersListThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_modified(self) -> Self {
            Self(self.0.status(304u16))
        }
    }

    pub struct UsersGetByUsernameWhen(httpmock::When);
    impl UsersGetByUsernameWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersGetByUsernameThen(httpmock::Then);
    impl UsersGetByUsernameThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::UsersGetByUsernameResponse) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForUserWhen(httpmock::When);
    impl PackagesListDockerMigrationConflictingPackagesForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/docker/conflicts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/docker/conflicts$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesListDockerMigrationConflictingPackagesForUserThen(httpmock::Then);
    impl PackagesListDockerMigrationConflictingPackagesForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListEventsForAuthenticatedUserWhen(httpmock::When);
    impl ActivityListEventsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/events$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListEventsForAuthenticatedUserThen(httpmock::Then);
    impl ActivityListEventsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListOrgEventsForAuthenticatedUserWhen(httpmock::When);
    impl ActivityListOrgEventsForAuthenticatedUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/events/orgs/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/events/orgs/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn org(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/.*/events/orgs/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListOrgEventsForAuthenticatedUserThen(httpmock::Then);
    impl ActivityListOrgEventsForAuthenticatedUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListPublicEventsForUserWhen(httpmock::When);
    impl ActivityListPublicEventsForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/events/public$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/events/public$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListPublicEventsForUserThen(httpmock::Then);
    impl ActivityListPublicEventsForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListFollowersForUserWhen(httpmock::When);
    impl UsersListFollowersForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/followers$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/followers$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListFollowersForUserThen(httpmock::Then);
    impl UsersListFollowersForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListFollowingForUserWhen(httpmock::When);
    impl UsersListFollowingForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/following$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/following$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListFollowingForUserThen(httpmock::Then);
    impl UsersListFollowingForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SimpleUser>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersCheckFollowingForUserWhen(httpmock::When);
    impl UsersCheckFollowingForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/following/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/following/.*$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn target_user(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/.*/following/{}$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct UsersCheckFollowingForUserThen(httpmock::Then);
    impl UsersCheckFollowingForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self) -> Self {
            Self(self.0.status(404u16))
        }
    }

    pub struct GistsListForUserWhen(httpmock::When);
    impl GistsListForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/gists$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/gists$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn since(self, value: &chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(self.0.query_param("since", value.to_string()))
        }
    }

    pub struct GistsListForUserThen(httpmock::Then);
    impl GistsListForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::BaseGist>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListGpgKeysForUserWhen(httpmock::When);
    impl UsersListGpgKeysForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/gpg_keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/gpg_keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListGpgKeysForUserThen(httpmock::Then);
    impl UsersListGpgKeysForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::GpgKey>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersGetContextForUserWhen(httpmock::When);
    impl UsersGetContextForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/hovercard$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/hovercard$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn subject_id(self, value: &str) -> Self {
            Self(self.0.query_param("subject_id", value.to_string()))
        }

        pub fn subject_type(self, value: types::UsersGetContextForUserSubjectType) -> Self {
            Self(self.0.query_param("subject_type", value.to_string()))
        }
    }

    pub struct UsersGetContextForUserThen(httpmock::Then);
    impl UsersGetContextForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Hovercard) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct AppsGetUserInstallationWhen(httpmock::When);
    impl AppsGetUserInstallationWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/installation$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/installation$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct AppsGetUserInstallationThen(httpmock::Then);
    impl AppsGetUserInstallationThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Installation) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListPublicKeysForUserWhen(httpmock::When);
    impl UsersListPublicKeysForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/keys$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/keys$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListPublicKeysForUserThen(httpmock::Then);
    impl UsersListPublicKeysForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::KeySimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct OrgsListForUserWhen(httpmock::When);
    impl OrgsListForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/orgs$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/orgs$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct OrgsListForUserThen(httpmock::Then);
    impl OrgsListForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::OrganizationSimple>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesListPackagesForUserWhen(httpmock::When);
    impl PackagesListPackagesForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/packages$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/packages$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesListPackagesForUserPackageType) -> Self {
            Self(self.0.query_param("package_type", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn visibility(self, value: types::PackagesListPackagesForUserVisibility) -> Self {
            Self(self.0.query_param("visibility", value.to_string()))
        }
    }

    pub struct PackagesListPackagesForUserThen(httpmock::Then);
    impl PackagesListPackagesForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Package>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn bad_request(self) -> Self {
            Self(self.0.status(400u16))
        }
    }

    pub struct PackagesGetPackageForUserWhen(httpmock::When);
    impl PackagesGetPackageForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/packages/.*/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesGetPackageForUserPackageType) -> Self {
            let re = regex::Regex::new(&format!("^/users/.*/packages/{}/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/.*/packages/.*/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageForUserThen(httpmock::Then);
    impl PackagesGetPackageForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::Package) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageForUserWhen(httpmock::When);
    impl PackagesDeletePackageForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::DELETE)
                    .path_matches(regex::Regex::new("^/users/.*/packages/.*/.*$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/packages/.*/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesDeletePackageForUserPackageType) -> Self {
            let re = regex::Regex::new(&format!("^/users/.*/packages/{}/.*$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/.*/packages/.*/{}$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageForUserThen(httpmock::Then);
    impl PackagesDeletePackageForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageForUserWhen(httpmock::When);
    impl PackagesRestorePackageForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::POST)
                    .path_matches(regex::Regex::new("^/users/.*/packages/.*/.*/restore$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/packages/.*/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(self, value: types::PackagesRestorePackageForUserPackageType) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/{}/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn token(self, value: &str) -> Self {
            Self(self.0.query_param("token", value.to_string()))
        }
    }

    pub struct PackagesRestorePackageForUserThen(httpmock::Then);
    impl PackagesRestorePackageForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByUserWhen(httpmock::When);
    impl PackagesGetAllPackageVersionsForPackageOwnedByUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/users/.*/packages/.*/.*/versions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/packages/.*/.*/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesGetAllPackageVersionsForPackageOwnedByUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/{}/.*/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/{}/versions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetAllPackageVersionsForPackageOwnedByUserThen(httpmock::Then);
    impl PackagesGetAllPackageVersionsForPackageOwnedByUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::PackageVersion>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesGetPackageVersionForUserWhen(httpmock::When);
    impl PackagesGetPackageVersionForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/users/.*/packages/.*/.*/versions/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/packages/.*/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesGetPackageVersionForUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesGetPackageVersionForUserThen(httpmock::Then);
    impl PackagesGetPackageVersionForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PackageVersion) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesDeletePackageVersionForUserWhen(httpmock::When);
    impl PackagesDeletePackageVersionForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::DELETE).path_matches(
                    regex::Regex::new("^/users/.*/packages/.*/.*/versions/.*$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/packages/.*/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesDeletePackageVersionForUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/{}/.*/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/{}/versions/.*$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/.*/versions/{}$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesDeletePackageVersionForUserThen(httpmock::Then);
    impl PackagesDeletePackageVersionForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct PackagesRestorePackageVersionForUserWhen(httpmock::When);
    impl PackagesRestorePackageVersionForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::POST).path_matches(
                regex::Regex::new("^/users/.*/packages/.*/.*/versions/.*/restore$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/packages/.*/.*/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_type(
            self,
            value: types::PackagesRestorePackageVersionForUserPackageType,
        ) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/{}/.*/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_name(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/{}/versions/.*/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn package_version_id(self, value: i64) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/.*/packages/.*/.*/versions/{}/restore$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct PackagesRestorePackageVersionForUserThen(httpmock::Then);
    impl PackagesRestorePackageVersionForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn no_content(self) -> Self {
            Self(self.0.status(204u16))
        }

        pub fn not_found(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(404u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn forbidden(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(403u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unauthorized(self, value: &types::BasicError) -> Self {
            Self(
                self.0
                    .status(401u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ProjectsListForUserWhen(httpmock::When);
    impl ProjectsListForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/projects$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re =
                regex::Regex::new(&format!("^/users/{}/projects$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn state(self, value: types::ProjectsListForUserState) -> Self {
            Self(self.0.query_param("state", value.to_string()))
        }
    }

    pub struct ProjectsListForUserThen(httpmock::Then);
    impl ProjectsListForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Project>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }

        pub fn unprocessable_entity(self, value: &types::ValidationError) -> Self {
            Self(
                self.0
                    .status(422u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListReceivedEventsForUserWhen(httpmock::When);
    impl ActivityListReceivedEventsForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/received_events$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/received_events$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListReceivedEventsForUserThen(httpmock::Then);
    impl ActivityListReceivedEventsForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ActivityListReceivedPublicEventsForUserWhen(httpmock::When);
    impl ActivityListReceivedPublicEventsForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/received_events/public$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/received_events/public$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct ActivityListReceivedPublicEventsForUserThen(httpmock::Then);
    impl ActivityListReceivedPublicEventsForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::Event>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct ReposListForUserWhen(httpmock::When);
    impl ReposListForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/repos$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/repos$", value.to_string())).unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn direction(self, value: types::ReposListForUserDirection) -> Self {
            Self(self.0.query_param("direction", value.to_string()))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }

        pub fn sort(self, value: types::ReposListForUserSort) -> Self {
            Self(self.0.query_param("sort", value.to_string()))
        }

        pub fn type_(self, value: types::ReposListForUserType) -> Self {
            Self(self.0.query_param("type_", value.to_string()))
        }
    }

    pub struct ReposListForUserThen(httpmock::Then);
    impl ReposListForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::MinimalRepository>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct BillingGetGithubActionsBillingUserWhen(httpmock::When);
    impl BillingGetGithubActionsBillingUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/users/.*/settings/billing/actions$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/settings/billing/actions$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetGithubActionsBillingUserThen(httpmock::Then);
    impl BillingGetGithubActionsBillingUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::ActionsBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct BillingGetGithubPackagesBillingUserWhen(httpmock::When);
    impl BillingGetGithubPackagesBillingUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner.method(httpmock::Method::GET).path_matches(
                    regex::Regex::new("^/users/.*/settings/billing/packages$").unwrap(),
                ),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/settings/billing/packages$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetGithubPackagesBillingUserThen(httpmock::Then);
    impl BillingGetGithubPackagesBillingUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::PackagesBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct BillingGetSharedStorageBillingUserWhen(httpmock::When);
    impl BillingGetSharedStorageBillingUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(inner.method(httpmock::Method::GET).path_matches(
                regex::Regex::new("^/users/.*/settings/billing/shared-storage$").unwrap(),
            ))
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!(
                "^/users/{}/settings/billing/shared-storage$",
                value.to_string()
            ))
            .unwrap();
            Self(self.0.path_matches(re))
        }
    }

    pub struct BillingGetSharedStorageBillingUserThen(httpmock::Then);
    impl BillingGetSharedStorageBillingUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &types::CombinedBillingUsage) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }

    pub struct UsersListSocialAccountsForUserWhen(httpmock::When);
    impl UsersListSocialAccountsForUserWhen {
        pub fn new(inner: httpmock::When) -> Self {
            Self(
                inner
                    .method(httpmock::Method::GET)
                    .path_matches(regex::Regex::new("^/users/.*/social_accounts$").unwrap()),
            )
        }

        pub fn into_inner(self) -> httpmock::When {
            self.0
        }

        pub fn username(self, value: &str) -> Self {
            let re = regex::Regex::new(&format!("^/users/{}/social_accounts$", value.to_string()))
                .unwrap();
            Self(self.0.path_matches(re))
        }

        pub fn page(self, value: i64) -> Self {
            Self(self.0.query_param("page", value.to_string()))
        }

        pub fn per_page(self, value: i64) -> Self {
            Self(self.0.query_param("per_page", value.to_string()))
        }
    }

    pub struct UsersListSocialAccountsForUserThen(httpmock::Then);
    impl UsersListSocialAccountsForUserThen {
        pub fn new(inner: httpmock::Then) -> Self {
            Self(inner)
        }

        pub fn into_inner(self) -> httpmock::Then {
            self.0
        }

        pub fn ok(self, value: &Vec<types::SocialAccount>) -> Self {
            Self(
                self.0
                    .status(200u16)
                    .header("content-type", "application/json")
                    .json_body_obj(value),
            )
        }
    }
}

#[doc = r" An extension trait for [`MockServer`](httpmock::MockServer) that"]
#[doc = r" adds a method for each operation. These are the equivalent of"]
#[doc = r" type-checked [`mock()`](httpmock::MockServer::mock) calls."]
pub trait MockServerExt {
    fn meta_root<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaRootWhen, operations::MetaRootThen);
    fn apps_get_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetAuthenticatedWhen, operations::AppsGetAuthenticatedThen);
    fn apps_create_from_manifest<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsCreateFromManifestWhen, operations::AppsCreateFromManifestThen);
    fn apps_get_webhook_config_for_app<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetWebhookConfigForAppWhen,
            operations::AppsGetWebhookConfigForAppThen,
        );
    fn apps_update_webhook_config_for_app<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsUpdateWebhookConfigForAppWhen,
            operations::AppsUpdateWebhookConfigForAppThen,
        );
    fn apps_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListWebhookDeliveriesWhen,
            operations::AppsListWebhookDeliveriesThen,
        );
    fn apps_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetWebhookDeliveryWhen, operations::AppsGetWebhookDeliveryThen);
    fn apps_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRedeliverWebhookDeliveryWhen,
            operations::AppsRedeliverWebhookDeliveryThen,
        );
    fn apps_list_installation_requests_for_authenticated_app<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationRequestsForAuthenticatedAppWhen,
            operations::AppsListInstallationRequestsForAuthenticatedAppThen,
        );
    fn apps_list_installations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListInstallationsWhen, operations::AppsListInstallationsThen);
    fn apps_get_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetInstallationWhen, operations::AppsGetInstallationThen);
    fn apps_delete_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteInstallationWhen, operations::AppsDeleteInstallationThen);
    fn apps_create_installation_access_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsCreateInstallationAccessTokenWhen,
            operations::AppsCreateInstallationAccessTokenThen,
        );
    fn apps_suspend_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsSuspendInstallationWhen, operations::AppsSuspendInstallationThen);
    fn apps_unsuspend_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsUnsuspendInstallationWhen,
            operations::AppsUnsuspendInstallationThen,
        );
    fn apps_delete_authorization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteAuthorizationWhen, operations::AppsDeleteAuthorizationThen);
    fn apps_check_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsCheckTokenWhen, operations::AppsCheckTokenThen);
    fn apps_delete_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteTokenWhen, operations::AppsDeleteTokenThen);
    fn apps_reset_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsResetTokenWhen, operations::AppsResetTokenThen);
    fn apps_scope_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsScopeTokenWhen, operations::AppsScopeTokenThen);
    fn apps_get_by_slug<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetBySlugWhen, operations::AppsGetBySlugThen);
    fn codes_of_conduct_get_all_codes_of_conduct<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodesOfConductGetAllCodesOfConductWhen,
            operations::CodesOfConductGetAllCodesOfConductThen,
        );
    fn codes_of_conduct_get_conduct_code<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodesOfConductGetConductCodeWhen,
            operations::CodesOfConductGetConductCodeThen,
        );
    fn emojis_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::EmojisGetWhen, operations::EmojisGetThen);
    fn dependabot_list_alerts_for_enterprise<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForEnterpriseWhen,
            operations::DependabotListAlertsForEnterpriseThen,
        );
    fn secret_scanning_list_alerts_for_enterprise<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForEnterpriseWhen,
            operations::SecretScanningListAlertsForEnterpriseThen,
        );
    fn activity_list_public_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsWhen,
            operations::ActivityListPublicEventsThen,
        );
    fn activity_get_feeds<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityGetFeedsWhen, operations::ActivityGetFeedsThen);
    fn gists_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListWhen, operations::GistsListThen);
    fn gists_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCreateWhen, operations::GistsCreateThen);
    fn gists_list_public<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListPublicWhen, operations::GistsListPublicThen);
    fn gists_list_starred<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListStarredWhen, operations::GistsListStarredThen);
    fn gists_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetWhen, operations::GistsGetThen);
    fn gists_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsDeleteWhen, operations::GistsDeleteThen);
    fn gists_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUpdateWhen, operations::GistsUpdateThen);
    fn gists_list_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListCommentsWhen, operations::GistsListCommentsThen);
    fn gists_create_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCreateCommentWhen, operations::GistsCreateCommentThen);
    fn gists_get_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetCommentWhen, operations::GistsGetCommentThen);
    fn gists_delete_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsDeleteCommentWhen, operations::GistsDeleteCommentThen);
    fn gists_update_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUpdateCommentWhen, operations::GistsUpdateCommentThen);
    fn gists_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListCommitsWhen, operations::GistsListCommitsThen);
    fn gists_list_forks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListForksWhen, operations::GistsListForksThen);
    fn gists_fork<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsForkWhen, operations::GistsForkThen);
    fn gists_check_is_starred<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCheckIsStarredWhen, operations::GistsCheckIsStarredThen);
    fn gists_star<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsStarWhen, operations::GistsStarThen);
    fn gists_unstar<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUnstarWhen, operations::GistsUnstarThen);
    fn gists_get_revision<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetRevisionWhen, operations::GistsGetRevisionThen);
    fn gitignore_get_all_templates<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::GitignoreGetAllTemplatesWhen,
            operations::GitignoreGetAllTemplatesThen,
        );
    fn gitignore_get_template<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitignoreGetTemplateWhen, operations::GitignoreGetTemplateThen);
    fn apps_list_repos_accessible_to_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListReposAccessibleToInstallationWhen,
            operations::AppsListReposAccessibleToInstallationThen,
        );
    fn apps_revoke_installation_access_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRevokeInstallationAccessTokenWhen,
            operations::AppsRevokeInstallationAccessTokenThen,
        );
    fn issues_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListWhen, operations::IssuesListThen);
    fn licenses_get_all_commonly_used<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::LicensesGetAllCommonlyUsedWhen,
            operations::LicensesGetAllCommonlyUsedThen,
        );
    fn licenses_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::LicensesGetWhen, operations::LicensesGetThen);
    fn markdown_render<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MarkdownRenderWhen, operations::MarkdownRenderThen);
    fn meta_get_all_versions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetAllVersionsWhen, operations::MetaGetAllVersionsThen);
    fn apps_get_subscription_plan_for_account<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetSubscriptionPlanForAccountWhen,
            operations::AppsGetSubscriptionPlanForAccountThen,
        );
    fn apps_list_plans<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListPlansWhen, operations::AppsListPlansThen);
    fn apps_list_accounts_for_plan<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListAccountsForPlanWhen, operations::AppsListAccountsForPlanThen);
    fn apps_get_subscription_plan_for_account_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetSubscriptionPlanForAccountStubbedWhen,
            operations::AppsGetSubscriptionPlanForAccountStubbedThen,
        );
    fn apps_list_plans_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListPlansStubbedWhen, operations::AppsListPlansStubbedThen);
    fn apps_list_accounts_for_plan_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListAccountsForPlanStubbedWhen,
            operations::AppsListAccountsForPlanStubbedThen,
        );
    fn meta_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetWhen, operations::MetaGetThen);
    fn activity_list_public_events_for_repo_network<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsForRepoNetworkWhen,
            operations::ActivityListPublicEventsForRepoNetworkThen,
        );
    fn activity_list_notifications_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListNotificationsForAuthenticatedUserWhen,
            operations::ActivityListNotificationsForAuthenticatedUserThen,
        );
    fn activity_mark_notifications_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkNotificationsAsReadWhen,
            operations::ActivityMarkNotificationsAsReadThen,
        );
    fn activity_get_thread<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityGetThreadWhen, operations::ActivityGetThreadThen);
    fn activity_mark_thread_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkThreadAsReadWhen,
            operations::ActivityMarkThreadAsReadThen,
        );
    fn activity_get_thread_subscription_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityGetThreadSubscriptionForAuthenticatedUserWhen,
            operations::ActivityGetThreadSubscriptionForAuthenticatedUserThen,
        );
    fn activity_set_thread_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivitySetThreadSubscriptionWhen,
            operations::ActivitySetThreadSubscriptionThen,
        );
    fn activity_delete_thread_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityDeleteThreadSubscriptionWhen,
            operations::ActivityDeleteThreadSubscriptionThen,
        );
    fn meta_get_octocat<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetOctocatWhen, operations::MetaGetOctocatThen);
    fn orgs_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListWhen, operations::OrgsListThen);
    fn orgs_list_pat_grant_requests<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRequestsWhen,
            operations::OrgsListPatGrantRequestsThen,
        );
    fn orgs_review_pat_grant_requests_in_bulk<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsReviewPatGrantRequestsInBulkWhen,
            operations::OrgsReviewPatGrantRequestsInBulkThen,
        );
    fn orgs_review_pat_grant_request<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsReviewPatGrantRequestWhen,
            operations::OrgsReviewPatGrantRequestThen,
        );
    fn orgs_list_pat_grant_request_repositories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRequestRepositoriesWhen,
            operations::OrgsListPatGrantRequestRepositoriesThen,
        );
    fn orgs_list_pat_grants<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListPatGrantsWhen, operations::OrgsListPatGrantsThen);
    fn orgs_update_pat_accesses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdatePatAccessesWhen, operations::OrgsUpdatePatAccessesThen);
    fn orgs_update_pat_access<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdatePatAccessWhen, operations::OrgsUpdatePatAccessThen);
    fn orgs_list_pat_grant_repositories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRepositoriesWhen,
            operations::OrgsListPatGrantRepositoriesThen,
        );
    fn meta_get_zen<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetZenWhen, operations::MetaGetZenThen);
    fn actions_get_actions_cache_usage_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageForOrgWhen,
            operations::ActionsGetActionsCacheUsageForOrgThen,
        );
    fn actions_get_actions_cache_usage_by_repo_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageByRepoForOrgWhen,
            operations::ActionsGetActionsCacheUsageByRepoForOrgThen,
        );
    fn oidc_get_oidc_custom_sub_template_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OidcGetOidcCustomSubTemplateForOrgWhen,
            operations::OidcGetOidcCustomSubTemplateForOrgThen,
        );
    fn oidc_update_oidc_custom_sub_template_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OidcUpdateOidcCustomSubTemplateForOrgWhen,
            operations::OidcUpdateOidcCustomSubTemplateForOrgThen,
        );
    fn actions_get_github_actions_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsPermissionsOrganizationWhen,
            operations::ActionsGetGithubActionsPermissionsOrganizationThen,
        );
    fn actions_set_github_actions_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsPermissionsOrganizationWhen,
            operations::ActionsSetGithubActionsPermissionsOrganizationThen,
        );
    fn actions_list_selected_repositories_enabled_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationWhen,
            operations::ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationThen,
        );
    fn actions_set_selected_repositories_enabled_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWhen,
            operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationThen,
        );
    fn actions_enable_selected_repository_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationWhen,
            operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationThen,
        );
    fn actions_disable_selected_repository_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationWhen,
            operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationThen,
        );
    fn actions_get_allowed_actions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetAllowedActionsOrganizationWhen,
            operations::ActionsGetAllowedActionsOrganizationThen,
        );
    fn actions_set_allowed_actions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetAllowedActionsOrganizationWhen,
            operations::ActionsSetAllowedActionsOrganizationThen,
        );
    fn actions_get_github_actions_default_workflow_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWhen,
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationThen,
        );
    fn actions_set_github_actions_default_workflow_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWhen,
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationThen,
        );
    fn actions_list_required_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRequiredWorkflowsWhen,
            operations::ActionsListRequiredWorkflowsThen,
        );
    fn actions_create_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRequiredWorkflowWhen,
            operations::ActionsCreateRequiredWorkflowThen,
        );
    fn actions_get_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRequiredWorkflowWhen,
            operations::ActionsGetRequiredWorkflowThen,
        );
    fn actions_delete_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteRequiredWorkflowWhen,
            operations::ActionsDeleteRequiredWorkflowThen,
        );
    fn actions_update_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateRequiredWorkflowWhen,
            operations::ActionsUpdateRequiredWorkflowThen,
        );
    fn actions_list_selected_repositories_required_workflow<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedRepositoriesRequiredWorkflowWhen,
            operations::ActionsListSelectedRepositoriesRequiredWorkflowThen,
        );
    fn actions_set_selected_repos_to_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposToRequiredWorkflowWhen,
            operations::ActionsSetSelectedReposToRequiredWorkflowThen,
        );
    fn actions_add_selected_repo_to_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToRequiredWorkflowWhen,
            operations::ActionsAddSelectedRepoToRequiredWorkflowThen,
        );
    fn actions_remove_selected_repo_from_required_workflow<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromRequiredWorkflowWhen,
            operations::ActionsRemoveSelectedRepoFromRequiredWorkflowThen,
        );
    fn actions_list_self_hosted_runners_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelfHostedRunnersForOrgWhen,
            operations::ActionsListSelfHostedRunnersForOrgThen,
        );
    fn actions_list_runner_applications_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRunnerApplicationsForOrgWhen,
            operations::ActionsListRunnerApplicationsForOrgThen,
        );
    fn actions_create_registration_token_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRegistrationTokenForOrgWhen,
            operations::ActionsCreateRegistrationTokenForOrgThen,
        );
    fn actions_create_remove_token_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRemoveTokenForOrgWhen,
            operations::ActionsCreateRemoveTokenForOrgThen,
        );
    fn actions_get_self_hosted_runner_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetSelfHostedRunnerForOrgWhen,
            operations::ActionsGetSelfHostedRunnerForOrgThen,
        );
    fn actions_delete_self_hosted_runner_from_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteSelfHostedRunnerFromOrgWhen,
            operations::ActionsDeleteSelfHostedRunnerFromOrgThen,
        );
    fn actions_list_labels_for_self_hosted_runner_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListLabelsForSelfHostedRunnerForOrgWhen,
            operations::ActionsListLabelsForSelfHostedRunnerForOrgThen,
        );
    fn actions_set_custom_labels_for_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgWhen,
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgThen,
        );
    fn actions_add_custom_labels_to_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgWhen,
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgThen,
        );
    fn actions_remove_all_custom_labels_from_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWhen,
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgThen,
        );
    fn actions_remove_custom_label_from_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgWhen,
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgThen,
        );
    fn actions_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListOrgSecretsWhen, operations::ActionsListOrgSecretsThen);
    fn actions_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgPublicKeyWhen, operations::ActionsGetOrgPublicKeyThen);
    fn actions_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgSecretWhen, operations::ActionsGetOrgSecretThen);
    fn actions_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateOrgSecretWhen,
            operations::ActionsCreateOrUpdateOrgSecretThen,
        );
    fn actions_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteOrgSecretWhen, operations::ActionsDeleteOrgSecretThen);
    fn actions_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedReposForOrgSecretWhen,
            operations::ActionsListSelectedReposForOrgSecretThen,
        );
    fn actions_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposForOrgSecretWhen,
            operations::ActionsSetSelectedReposForOrgSecretThen,
        );
    fn actions_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToOrgSecretWhen,
            operations::ActionsAddSelectedRepoToOrgSecretThen,
        );
    fn actions_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromOrgSecretWhen,
            operations::ActionsRemoveSelectedRepoFromOrgSecretThen,
        );
    fn actions_list_org_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListOrgVariablesWhen, operations::ActionsListOrgVariablesThen);
    fn actions_create_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrgVariableWhen,
            operations::ActionsCreateOrgVariableThen,
        );
    fn actions_get_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgVariableWhen, operations::ActionsGetOrgVariableThen);
    fn actions_delete_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteOrgVariableWhen,
            operations::ActionsDeleteOrgVariableThen,
        );
    fn actions_update_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateOrgVariableWhen,
            operations::ActionsUpdateOrgVariableThen,
        );
    fn actions_list_selected_repos_for_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedReposForOrgVariableWhen,
            operations::ActionsListSelectedReposForOrgVariableThen,
        );
    fn actions_set_selected_repos_for_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposForOrgVariableWhen,
            operations::ActionsSetSelectedReposForOrgVariableThen,
        );
    fn actions_add_selected_repo_to_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToOrgVariableWhen,
            operations::ActionsAddSelectedRepoToOrgVariableThen,
        );
    fn actions_remove_selected_repo_from_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromOrgVariableWhen,
            operations::ActionsRemoveSelectedRepoFromOrgVariableThen,
        );
    fn orgs_list_blocked_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListBlockedUsersWhen, operations::OrgsListBlockedUsersThen);
    fn orgs_check_blocked_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCheckBlockedUserWhen, operations::OrgsCheckBlockedUserThen);
    fn orgs_block_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsBlockUserWhen, operations::OrgsBlockUserThen);
    fn orgs_unblock_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUnblockUserWhen, operations::OrgsUnblockUserThen);
    fn code_scanning_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertsForOrgWhen,
            operations::CodeScanningListAlertsForOrgThen,
        );
    fn codespaces_list_in_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListInOrganizationWhen,
            operations::CodespacesListInOrganizationThen,
        );
    fn codespaces_set_codespaces_billing<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetCodespacesBillingWhen,
            operations::CodespacesSetCodespacesBillingThen,
        );
    fn codespaces_set_codespaces_billing_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetCodespacesBillingUsersWhen,
            operations::CodespacesSetCodespacesBillingUsersThen,
        );
    fn codespaces_delete_codespaces_billing_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteCodespacesBillingUsersWhen,
            operations::CodespacesDeleteCodespacesBillingUsersThen,
        );
    fn codespaces_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListOrgSecretsWhen,
            operations::CodespacesListOrgSecretsThen,
        );
    fn codespaces_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetOrgPublicKeyWhen,
            operations::CodespacesGetOrgPublicKeyThen,
        );
    fn codespaces_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodespacesGetOrgSecretWhen, operations::CodespacesGetOrgSecretThen);
    fn codespaces_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateOrgSecretWhen,
            operations::CodespacesCreateOrUpdateOrgSecretThen,
        );
    fn codespaces_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteOrgSecretWhen,
            operations::CodespacesDeleteOrgSecretThen,
        );
    fn codespaces_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListSelectedReposForOrgSecretWhen,
            operations::CodespacesListSelectedReposForOrgSecretThen,
        );
    fn codespaces_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetSelectedReposForOrgSecretWhen,
            operations::CodespacesSetSelectedReposForOrgSecretThen,
        );
    fn codespaces_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesAddSelectedRepoToOrgSecretWhen,
            operations::CodespacesAddSelectedRepoToOrgSecretThen,
        );
    fn codespaces_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRemoveSelectedRepoFromOrgSecretWhen,
            operations::CodespacesRemoveSelectedRepoFromOrgSecretThen,
        );
    fn dependabot_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForOrgWhen,
            operations::DependabotListAlertsForOrgThen,
        );
    fn dependabot_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListOrgSecretsWhen,
            operations::DependabotListOrgSecretsThen,
        );
    fn dependabot_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotGetOrgPublicKeyWhen,
            operations::DependabotGetOrgPublicKeyThen,
        );
    fn dependabot_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetOrgSecretWhen, operations::DependabotGetOrgSecretThen);
    fn dependabot_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotCreateOrUpdateOrgSecretWhen,
            operations::DependabotCreateOrUpdateOrgSecretThen,
        );
    fn dependabot_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotDeleteOrgSecretWhen,
            operations::DependabotDeleteOrgSecretThen,
        );
    fn dependabot_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListSelectedReposForOrgSecretWhen,
            operations::DependabotListSelectedReposForOrgSecretThen,
        );
    fn dependabot_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotSetSelectedReposForOrgSecretWhen,
            operations::DependabotSetSelectedReposForOrgSecretThen,
        );
    fn dependabot_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotAddSelectedRepoToOrgSecretWhen,
            operations::DependabotAddSelectedRepoToOrgSecretThen,
        );
    fn dependabot_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotRemoveSelectedRepoFromOrgSecretWhen,
            operations::DependabotRemoveSelectedRepoFromOrgSecretThen,
        );
    fn packages_list_docker_migration_conflicting_packages_for_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForOrganizationWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForOrganizationThen,
        );
    fn activity_list_public_org_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicOrgEventsWhen,
            operations::ActivityListPublicOrgEventsThen,
        );
    fn orgs_list_failed_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListFailedInvitationsWhen,
            operations::OrgsListFailedInvitationsThen,
        );
    fn orgs_list_webhooks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListWebhooksWhen, operations::OrgsListWebhooksThen);
    fn orgs_create_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCreateWebhookWhen, operations::OrgsCreateWebhookThen);
    fn orgs_get_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsGetWebhookWhen, operations::OrgsGetWebhookThen);
    fn orgs_delete_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsDeleteWebhookWhen, operations::OrgsDeleteWebhookThen);
    fn orgs_update_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdateWebhookWhen, operations::OrgsUpdateWebhookThen);
    fn orgs_get_webhook_config_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetWebhookConfigForOrgWhen,
            operations::OrgsGetWebhookConfigForOrgThen,
        );
    fn orgs_update_webhook_config_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsUpdateWebhookConfigForOrgWhen,
            operations::OrgsUpdateWebhookConfigForOrgThen,
        );
    fn orgs_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListWebhookDeliveriesWhen,
            operations::OrgsListWebhookDeliveriesThen,
        );
    fn orgs_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsGetWebhookDeliveryWhen, operations::OrgsGetWebhookDeliveryThen);
    fn orgs_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRedeliverWebhookDeliveryWhen,
            operations::OrgsRedeliverWebhookDeliveryThen,
        );
    fn orgs_ping_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsPingWebhookWhen, operations::OrgsPingWebhookThen);
    fn apps_get_org_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetOrgInstallationWhen, operations::AppsGetOrgInstallationThen);
    fn orgs_list_app_installations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListAppInstallationsWhen,
            operations::OrgsListAppInstallationsThen,
        );
    fn interactions_get_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForOrgWhen,
            operations::InteractionsGetRestrictionsForOrgThen,
        );
    fn interactions_set_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForOrgWhen,
            operations::InteractionsSetRestrictionsForOrgThen,
        );
    fn interactions_remove_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForOrgWhen,
            operations::InteractionsRemoveRestrictionsForOrgThen,
        );
    fn orgs_list_pending_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPendingInvitationsWhen,
            operations::OrgsListPendingInvitationsThen,
        );
    fn orgs_create_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCreateInvitationWhen, operations::OrgsCreateInvitationThen);
    fn orgs_cancel_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCancelInvitationWhen, operations::OrgsCancelInvitationThen);
    fn orgs_list_invitation_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListInvitationTeamsWhen, operations::OrgsListInvitationTeamsThen);
    fn issues_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListForOrgWhen, operations::IssuesListForOrgThen);
    fn orgs_list_members<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListMembersWhen, operations::OrgsListMembersThen);
    fn orgs_check_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsCheckMembershipForUserWhen,
            operations::OrgsCheckMembershipForUserThen,
        );
    fn orgs_remove_member<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsRemoveMemberWhen, operations::OrgsRemoveMemberThen);
    fn codespaces_get_codespaces_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetCodespacesForUserInOrgWhen,
            operations::CodespacesGetCodespacesForUserInOrgThen,
        );
    fn codespaces_delete_from_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteFromOrganizationWhen,
            operations::CodespacesDeleteFromOrganizationThen,
        );
    fn codespaces_stop_in_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStopInOrganizationWhen,
            operations::CodespacesStopInOrganizationThen,
        );
    fn orgs_get_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetMembershipForUserWhen,
            operations::OrgsGetMembershipForUserThen,
        );
    fn orgs_set_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsSetMembershipForUserWhen,
            operations::OrgsSetMembershipForUserThen,
        );
    fn orgs_remove_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveMembershipForUserWhen,
            operations::OrgsRemoveMembershipForUserThen,
        );
    fn migrations_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsListForOrgWhen, operations::MigrationsListForOrgThen);
    fn migrations_start_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsStartForOrgWhen, operations::MigrationsStartForOrgThen);
    fn migrations_get_status_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetStatusForOrgWhen,
            operations::MigrationsGetStatusForOrgThen,
        );
    fn migrations_download_archive_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDownloadArchiveForOrgWhen,
            operations::MigrationsDownloadArchiveForOrgThen,
        );
    fn migrations_delete_archive_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDeleteArchiveForOrgWhen,
            operations::MigrationsDeleteArchiveForOrgThen,
        );
    fn migrations_unlock_repo_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsUnlockRepoForOrgWhen,
            operations::MigrationsUnlockRepoForOrgThen,
        );
    fn migrations_list_repos_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListReposForOrgWhen,
            operations::MigrationsListReposForOrgThen,
        );
    fn orgs_list_outside_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListOutsideCollaboratorsWhen,
            operations::OrgsListOutsideCollaboratorsThen,
        );
    fn orgs_convert_member_to_outside_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsConvertMemberToOutsideCollaboratorWhen,
            operations::OrgsConvertMemberToOutsideCollaboratorThen,
        );
    fn orgs_remove_outside_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveOutsideCollaboratorWhen,
            operations::OrgsRemoveOutsideCollaboratorThen,
        );
    fn packages_list_packages_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForOrganizationWhen,
            operations::PackagesListPackagesForOrganizationThen,
        );
    fn packages_get_package_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForOrganizationWhen,
            operations::PackagesGetPackageForOrganizationThen,
        );
    fn packages_delete_package_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForOrgWhen,
            operations::PackagesDeletePackageForOrgThen,
        );
    fn packages_restore_package_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForOrgWhen,
            operations::PackagesRestorePackageForOrgThen,
        );
    fn packages_get_all_package_versions_for_package_owned_by_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgThen,
        );
    fn packages_get_package_version_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForOrganizationWhen,
            operations::PackagesGetPackageVersionForOrganizationThen,
        );
    fn packages_delete_package_version_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForOrgWhen,
            operations::PackagesDeletePackageVersionForOrgThen,
        );
    fn packages_restore_package_version_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForOrgWhen,
            operations::PackagesRestorePackageVersionForOrgThen,
        );
    fn projects_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForOrgWhen, operations::ProjectsListForOrgThen);
    fn projects_create_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateForOrgWhen, operations::ProjectsCreateForOrgThen);
    fn orgs_list_public_members<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListPublicMembersWhen, operations::OrgsListPublicMembersThen);
    fn orgs_check_public_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsCheckPublicMembershipForUserWhen,
            operations::OrgsCheckPublicMembershipForUserThen,
        );
    fn orgs_set_public_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsSetPublicMembershipForAuthenticatedUserWhen,
            operations::OrgsSetPublicMembershipForAuthenticatedUserThen,
        );
    fn orgs_remove_public_membership_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemovePublicMembershipForAuthenticatedUserWhen,
            operations::OrgsRemovePublicMembershipForAuthenticatedUserThen,
        );
    fn repos_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForOrgWhen, operations::ReposListForOrgThen);
    fn repos_create_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateInOrgWhen, operations::ReposCreateInOrgThen);
    fn repos_get_org_rulesets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetOrgRulesetsWhen, operations::ReposGetOrgRulesetsThen);
    fn repos_create_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateOrgRulesetWhen, operations::ReposCreateOrgRulesetThen);
    fn repos_get_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetOrgRulesetWhen, operations::ReposGetOrgRulesetThen);
    fn repos_update_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateOrgRulesetWhen, operations::ReposUpdateOrgRulesetThen);
    fn repos_delete_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteOrgRulesetWhen, operations::ReposDeleteOrgRulesetThen);
    fn secret_scanning_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForOrgWhen,
            operations::SecretScanningListAlertsForOrgThen,
        );
    fn orgs_list_security_manager_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListSecurityManagerTeamsWhen,
            operations::OrgsListSecurityManagerTeamsThen,
        );
    fn orgs_add_security_manager_team<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsAddSecurityManagerTeamWhen,
            operations::OrgsAddSecurityManagerTeamThen,
        );
    fn orgs_remove_security_manager_team<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveSecurityManagerTeamWhen,
            operations::OrgsRemoveSecurityManagerTeamThen,
        );
    fn billing_get_github_actions_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubActionsBillingOrgWhen,
            operations::BillingGetGithubActionsBillingOrgThen,
        );
    fn billing_get_github_packages_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubPackagesBillingOrgWhen,
            operations::BillingGetGithubPackagesBillingOrgThen,
        );
    fn billing_get_shared_storage_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetSharedStorageBillingOrgWhen,
            operations::BillingGetSharedStorageBillingOrgThen,
        );
    fn teams_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListWhen, operations::TeamsListThen);
    fn teams_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsCreateWhen, operations::TeamsCreateThen);
    fn teams_get_by_name<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetByNameWhen, operations::TeamsGetByNameThen);
    fn teams_delete_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsDeleteInOrgWhen, operations::TeamsDeleteInOrgThen);
    fn teams_update_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsUpdateInOrgWhen, operations::TeamsUpdateInOrgThen);
    fn teams_list_discussions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionsInOrgWhen,
            operations::TeamsListDiscussionsInOrgThen,
        );
    fn teams_create_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionInOrgWhen,
            operations::TeamsCreateDiscussionInOrgThen,
        );
    fn teams_get_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetDiscussionInOrgWhen, operations::TeamsGetDiscussionInOrgThen);
    fn teams_delete_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionInOrgWhen,
            operations::TeamsDeleteDiscussionInOrgThen,
        );
    fn teams_update_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionInOrgWhen,
            operations::TeamsUpdateDiscussionInOrgThen,
        );
    fn teams_list_discussion_comments_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionCommentsInOrgWhen,
            operations::TeamsListDiscussionCommentsInOrgThen,
        );
    fn teams_create_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionCommentInOrgWhen,
            operations::TeamsCreateDiscussionCommentInOrgThen,
        );
    fn teams_get_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionCommentInOrgWhen,
            operations::TeamsGetDiscussionCommentInOrgThen,
        );
    fn teams_delete_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionCommentInOrgWhen,
            operations::TeamsDeleteDiscussionCommentInOrgThen,
        );
    fn teams_update_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionCommentInOrgWhen,
            operations::TeamsUpdateDiscussionCommentInOrgThen,
        );
    fn reactions_list_for_team_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionCommentInOrgWhen,
            operations::ReactionsListForTeamDiscussionCommentInOrgThen,
        );
    fn reactions_create_for_team_discussion_comment_in_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionCommentInOrgWhen,
            operations::ReactionsCreateForTeamDiscussionCommentInOrgThen,
        );
    fn reactions_delete_for_team_discussion_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForTeamDiscussionCommentWhen,
            operations::ReactionsDeleteForTeamDiscussionCommentThen,
        );
    fn reactions_list_for_team_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionInOrgWhen,
            operations::ReactionsListForTeamDiscussionInOrgThen,
        );
    fn reactions_create_for_team_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionInOrgWhen,
            operations::ReactionsCreateForTeamDiscussionInOrgThen,
        );
    fn reactions_delete_for_team_discussion<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForTeamDiscussionWhen,
            operations::ReactionsDeleteForTeamDiscussionThen,
        );
    fn teams_list_pending_invitations_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListPendingInvitationsInOrgWhen,
            operations::TeamsListPendingInvitationsInOrgThen,
        );
    fn teams_list_members_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListMembersInOrgWhen, operations::TeamsListMembersInOrgThen);
    fn teams_get_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetMembershipForUserInOrgWhen,
            operations::TeamsGetMembershipForUserInOrgThen,
        );
    fn teams_add_or_update_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateMembershipForUserInOrgWhen,
            operations::TeamsAddOrUpdateMembershipForUserInOrgThen,
        );
    fn teams_remove_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveMembershipForUserInOrgWhen,
            operations::TeamsRemoveMembershipForUserInOrgThen,
        );
    fn teams_list_projects_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListProjectsInOrgWhen, operations::TeamsListProjectsInOrgThen);
    fn teams_check_permissions_for_project_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForProjectInOrgWhen,
            operations::TeamsCheckPermissionsForProjectInOrgThen,
        );
    fn teams_add_or_update_project_permissions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateProjectPermissionsInOrgWhen,
            operations::TeamsAddOrUpdateProjectPermissionsInOrgThen,
        );
    fn teams_remove_project_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveProjectInOrgWhen, operations::TeamsRemoveProjectInOrgThen);
    fn teams_list_repos_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListReposInOrgWhen, operations::TeamsListReposInOrgThen);
    fn teams_check_permissions_for_repo_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForRepoInOrgWhen,
            operations::TeamsCheckPermissionsForRepoInOrgThen,
        );
    fn teams_add_or_update_repo_permissions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateRepoPermissionsInOrgWhen,
            operations::TeamsAddOrUpdateRepoPermissionsInOrgThen,
        );
    fn teams_remove_repo_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveRepoInOrgWhen, operations::TeamsRemoveRepoInOrgThen);
    fn teams_list_child_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListChildInOrgWhen, operations::TeamsListChildInOrgThen);
    fn orgs_enable_or_disable_security_product_on_all_org_repos<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposWhen,
            operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposThen,
        );
    fn projects_get_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetCardWhen, operations::ProjectsGetCardThen);
    fn projects_delete_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteCardWhen, operations::ProjectsDeleteCardThen);
    fn projects_update_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateCardWhen, operations::ProjectsUpdateCardThen);
    fn projects_move_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsMoveCardWhen, operations::ProjectsMoveCardThen);
    fn projects_get_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetColumnWhen, operations::ProjectsGetColumnThen);
    fn projects_delete_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteColumnWhen, operations::ProjectsDeleteColumnThen);
    fn projects_update_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateColumnWhen, operations::ProjectsUpdateColumnThen);
    fn users_list_ssh_signing_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSshSigningKeysForUserWhen,
            operations::UsersListSshSigningKeysForUserThen,
        );
    fn projects_move_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsMoveColumnWhen, operations::ProjectsMoveColumnThen);
    fn projects_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetWhen, operations::ProjectsGetThen);
    fn projects_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteWhen, operations::ProjectsDeleteThen);
    fn projects_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateWhen, operations::ProjectsUpdateThen);
    fn projects_list_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsListCollaboratorsWhen,
            operations::ProjectsListCollaboratorsThen,
        );
    fn projects_add_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsAddCollaboratorWhen, operations::ProjectsAddCollaboratorThen);
    fn projects_remove_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsRemoveCollaboratorWhen,
            operations::ProjectsRemoveCollaboratorThen,
        );
    fn projects_get_permission_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsGetPermissionForUserWhen,
            operations::ProjectsGetPermissionForUserThen,
        );
    fn projects_list_columns<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListColumnsWhen, operations::ProjectsListColumnsThen);
    fn projects_create_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateColumnWhen, operations::ProjectsCreateColumnThen);
    fn rate_limit_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::RateLimitGetWhen, operations::RateLimitGetThen);
    fn actions_list_repo_required_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoRequiredWorkflowsWhen,
            operations::ActionsListRepoRequiredWorkflowsThen,
        );
    fn actions_get_repo_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRepoRequiredWorkflowWhen,
            operations::ActionsGetRepoRequiredWorkflowThen,
        );
    fn actions_get_repo_required_workflow_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRepoRequiredWorkflowUsageWhen,
            operations::ActionsGetRepoRequiredWorkflowUsageThen,
        );
    fn repos_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWhen, operations::ReposGetThen);
    fn repos_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteWhen, operations::ReposDeleteThen);
    fn repos_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateWhen, operations::ReposUpdateThen);
    fn actions_list_artifacts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListArtifactsForRepoWhen,
            operations::ActionsListArtifactsForRepoThen,
        );
    fn actions_get_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetArtifactWhen, operations::ActionsGetArtifactThen);
    fn actions_delete_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteArtifactWhen, operations::ActionsDeleteArtifactThen);
    fn actions_download_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDownloadArtifactWhen, operations::ActionsDownloadArtifactThen);
    fn actions_get_actions_cache_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageWhen,
            operations::ActionsGetActionsCacheUsageThen,
        );
    fn actions_get_actions_cache_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheListWhen,
            operations::ActionsGetActionsCacheListThen,
        );
    fn actions_delete_actions_cache_by_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteActionsCacheByKeyWhen,
            operations::ActionsDeleteActionsCacheByKeyThen,
        );
    fn actions_delete_actions_cache_by_id<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteActionsCacheByIdWhen,
            operations::ActionsDeleteActionsCacheByIdThen,
        );
    fn actions_get_job_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetJobForWorkflowRunWhen,
            operations::ActionsGetJobForWorkflowRunThen,
        );
    fn actions_download_job_logs_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadJobLogsForWorkflowRunWhen,
            operations::ActionsDownloadJobLogsForWorkflowRunThen,
        );
    fn actions_re_run_job_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReRunJobForWorkflowRunWhen,
            operations::ActionsReRunJobForWorkflowRunThen,
        );
    fn actions_get_custom_oidc_sub_claim_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetCustomOidcSubClaimForRepoWhen,
            operations::ActionsGetCustomOidcSubClaimForRepoThen,
        );
    fn actions_set_custom_oidc_sub_claim_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomOidcSubClaimForRepoWhen,
            operations::ActionsSetCustomOidcSubClaimForRepoThen,
        );
    fn actions_list_repo_organization_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoOrganizationSecretsWhen,
            operations::ActionsListRepoOrganizationSecretsThen,
        );
    fn actions_list_repo_organization_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoOrganizationVariablesWhen,
            operations::ActionsListRepoOrganizationVariablesThen,
        );
    fn actions_get_github_actions_permissions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsPermissionsRepositoryWhen,
            operations::ActionsGetGithubActionsPermissionsRepositoryThen,
        );
    fn actions_set_github_actions_permissions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsPermissionsRepositoryWhen,
            operations::ActionsSetGithubActionsPermissionsRepositoryThen,
        );
    fn actions_get_workflow_access_to_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowAccessToRepositoryWhen,
            operations::ActionsGetWorkflowAccessToRepositoryThen,
        );
    fn actions_set_workflow_access_to_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetWorkflowAccessToRepositoryWhen,
            operations::ActionsSetWorkflowAccessToRepositoryThen,
        );
    fn actions_get_allowed_actions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetAllowedActionsRepositoryWhen,
            operations::ActionsGetAllowedActionsRepositoryThen,
        );
    fn actions_set_allowed_actions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetAllowedActionsRepositoryWhen,
            operations::ActionsSetAllowedActionsRepositoryThen,
        );
    fn actions_get_github_actions_default_workflow_permissions_repository<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWhen,
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryThen,
        );
    fn actions_set_github_actions_default_workflow_permissions_repository<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWhen,
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryThen,
        );
    fn actions_list_required_workflow_runs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRequiredWorkflowRunsWhen,
            operations::ActionsListRequiredWorkflowRunsThen,
        );
    fn actions_list_self_hosted_runners_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelfHostedRunnersForRepoWhen,
            operations::ActionsListSelfHostedRunnersForRepoThen,
        );
    fn actions_list_runner_applications_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRunnerApplicationsForRepoWhen,
            operations::ActionsListRunnerApplicationsForRepoThen,
        );
    fn actions_create_registration_token_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRegistrationTokenForRepoWhen,
            operations::ActionsCreateRegistrationTokenForRepoThen,
        );
    fn actions_create_remove_token_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRemoveTokenForRepoWhen,
            operations::ActionsCreateRemoveTokenForRepoThen,
        );
    fn actions_get_self_hosted_runner_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetSelfHostedRunnerForRepoWhen,
            operations::ActionsGetSelfHostedRunnerForRepoThen,
        );
    fn actions_delete_self_hosted_runner_from_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteSelfHostedRunnerFromRepoWhen,
            operations::ActionsDeleteSelfHostedRunnerFromRepoThen,
        );
    fn actions_list_labels_for_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListLabelsForSelfHostedRunnerForRepoWhen,
            operations::ActionsListLabelsForSelfHostedRunnerForRepoThen,
        );
    fn actions_set_custom_labels_for_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoWhen,
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoThen,
        );
    fn actions_add_custom_labels_to_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoWhen,
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoThen,
        );
    fn actions_remove_all_custom_labels_from_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWhen,
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoThen,
        );
    fn actions_remove_custom_label_from_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoWhen,
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoThen,
        );
    fn actions_list_workflow_runs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListWorkflowRunsForRepoWhen,
            operations::ActionsListWorkflowRunsForRepoThen,
        );
    fn actions_get_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowRunWhen, operations::ActionsGetWorkflowRunThen);
    fn actions_delete_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteWorkflowRunWhen,
            operations::ActionsDeleteWorkflowRunThen,
        );
    fn actions_get_reviews_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetReviewsForRunWhen, operations::ActionsGetReviewsForRunThen);
    fn actions_approve_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsApproveWorkflowRunWhen,
            operations::ActionsApproveWorkflowRunThen,
        );
    fn actions_list_workflow_run_artifacts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListWorkflowRunArtifactsWhen,
            operations::ActionsListWorkflowRunArtifactsThen,
        );
    fn actions_get_workflow_run_attempt<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowRunAttemptWhen,
            operations::ActionsGetWorkflowRunAttemptThen,
        );
    fn actions_list_jobs_for_workflow_run_attempt<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListJobsForWorkflowRunAttemptWhen,
            operations::ActionsListJobsForWorkflowRunAttemptThen,
        );
    fn actions_download_workflow_run_attempt_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadWorkflowRunAttemptLogsWhen,
            operations::ActionsDownloadWorkflowRunAttemptLogsThen,
        );
    fn actions_cancel_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCancelWorkflowRunWhen,
            operations::ActionsCancelWorkflowRunThen,
        );
    fn actions_review_custom_gates_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReviewCustomGatesForRunWhen,
            operations::ActionsReviewCustomGatesForRunThen,
        );
    fn actions_list_jobs_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListJobsForWorkflowRunWhen,
            operations::ActionsListJobsForWorkflowRunThen,
        );
    fn actions_download_workflow_run_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadWorkflowRunLogsWhen,
            operations::ActionsDownloadWorkflowRunLogsThen,
        );
    fn actions_delete_workflow_run_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteWorkflowRunLogsWhen,
            operations::ActionsDeleteWorkflowRunLogsThen,
        );
    fn actions_get_pending_deployments_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetPendingDeploymentsForRunWhen,
            operations::ActionsGetPendingDeploymentsForRunThen,
        );
    fn actions_review_pending_deployments_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReviewPendingDeploymentsForRunWhen,
            operations::ActionsReviewPendingDeploymentsForRunThen,
        );
    fn actions_re_run_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsReRunWorkflowWhen, operations::ActionsReRunWorkflowThen);
    fn actions_re_run_workflow_failed_jobs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReRunWorkflowFailedJobsWhen,
            operations::ActionsReRunWorkflowFailedJobsThen,
        );
    fn actions_get_workflow_run_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowRunUsageWhen,
            operations::ActionsGetWorkflowRunUsageThen,
        );
    fn actions_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListRepoSecretsWhen, operations::ActionsListRepoSecretsThen);
    fn actions_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoPublicKeyWhen, operations::ActionsGetRepoPublicKeyThen);
    fn actions_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoSecretWhen, operations::ActionsGetRepoSecretThen);
    fn actions_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateRepoSecretWhen,
            operations::ActionsCreateOrUpdateRepoSecretThen,
        );
    fn actions_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteRepoSecretWhen, operations::ActionsDeleteRepoSecretThen);
    fn actions_list_repo_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoVariablesWhen,
            operations::ActionsListRepoVariablesThen,
        );
    fn actions_create_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRepoVariableWhen,
            operations::ActionsCreateRepoVariableThen,
        );
    fn actions_get_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoVariableWhen, operations::ActionsGetRepoVariableThen);
    fn actions_delete_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteRepoVariableWhen,
            operations::ActionsDeleteRepoVariableThen,
        );
    fn actions_update_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateRepoVariableWhen,
            operations::ActionsUpdateRepoVariableThen,
        );
    fn actions_list_repo_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoWorkflowsWhen,
            operations::ActionsListRepoWorkflowsThen,
        );
    fn actions_get_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowWhen, operations::ActionsGetWorkflowThen);
    fn actions_disable_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDisableWorkflowWhen, operations::ActionsDisableWorkflowThen);
    fn actions_create_workflow_dispatch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateWorkflowDispatchWhen,
            operations::ActionsCreateWorkflowDispatchThen,
        );
    fn actions_enable_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsEnableWorkflowWhen, operations::ActionsEnableWorkflowThen);
    fn actions_list_workflow_runs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListWorkflowRunsWhen, operations::ActionsListWorkflowRunsThen);
    fn actions_get_workflow_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowUsageWhen, operations::ActionsGetWorkflowUsageThen);
    fn issues_list_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListAssigneesWhen, operations::IssuesListAssigneesThen);
    fn issues_check_user_can_be_assigned<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesCheckUserCanBeAssignedWhen,
            operations::IssuesCheckUserCanBeAssignedThen,
        );
    fn repos_list_autolinks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListAutolinksWhen, operations::ReposListAutolinksThen);
    fn repos_create_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateAutolinkWhen, operations::ReposCreateAutolinkThen);
    fn repos_get_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAutolinkWhen, operations::ReposGetAutolinkThen);
    fn repos_delete_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteAutolinkWhen, operations::ReposDeleteAutolinkThen);
    fn repos_enable_automated_security_fixes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposEnableAutomatedSecurityFixesWhen,
            operations::ReposEnableAutomatedSecurityFixesThen,
        );
    fn repos_disable_automated_security_fixes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableAutomatedSecurityFixesWhen,
            operations::ReposDisableAutomatedSecurityFixesThen,
        );
    fn repos_list_branches<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListBranchesWhen, operations::ReposListBranchesThen);
    fn repos_get_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetBranchWhen, operations::ReposGetBranchThen);
    fn repos_get_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetBranchProtectionWhen,
            operations::ReposGetBranchProtectionThen,
        );
    fn repos_update_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateBranchProtectionWhen,
            operations::ReposUpdateBranchProtectionThen,
        );
    fn repos_delete_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteBranchProtectionWhen,
            operations::ReposDeleteBranchProtectionThen,
        );
    fn repos_get_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAdminBranchProtectionWhen,
            operations::ReposGetAdminBranchProtectionThen,
        );
    fn repos_set_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetAdminBranchProtectionWhen,
            operations::ReposSetAdminBranchProtectionThen,
        );
    fn repos_delete_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAdminBranchProtectionWhen,
            operations::ReposDeleteAdminBranchProtectionThen,
        );
    fn repos_get_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetPullRequestReviewProtectionWhen,
            operations::ReposGetPullRequestReviewProtectionThen,
        );
    fn repos_delete_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeletePullRequestReviewProtectionWhen,
            operations::ReposDeletePullRequestReviewProtectionThen,
        );
    fn repos_update_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdatePullRequestReviewProtectionWhen,
            operations::ReposUpdatePullRequestReviewProtectionThen,
        );
    fn repos_get_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommitSignatureProtectionWhen,
            operations::ReposGetCommitSignatureProtectionThen,
        );
    fn repos_create_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateCommitSignatureProtectionWhen,
            operations::ReposCreateCommitSignatureProtectionThen,
        );
    fn repos_delete_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteCommitSignatureProtectionWhen,
            operations::ReposDeleteCommitSignatureProtectionThen,
        );
    fn repos_get_status_checks_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetStatusChecksProtectionWhen,
            operations::ReposGetStatusChecksProtectionThen,
        );
    fn repos_remove_status_check_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveStatusCheckProtectionWhen,
            operations::ReposRemoveStatusCheckProtectionThen,
        );
    fn repos_update_status_check_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateStatusCheckProtectionWhen,
            operations::ReposUpdateStatusCheckProtectionThen,
        );
    fn repos_get_all_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAllStatusCheckContextsWhen,
            operations::ReposGetAllStatusCheckContextsThen,
        );
    fn repos_set_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetStatusCheckContextsWhen,
            operations::ReposSetStatusCheckContextsThen,
        );
    fn repos_add_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddStatusCheckContextsWhen,
            operations::ReposAddStatusCheckContextsThen,
        );
    fn repos_remove_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveStatusCheckContextsWhen,
            operations::ReposRemoveStatusCheckContextsThen,
        );
    fn repos_get_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAccessRestrictionsWhen,
            operations::ReposGetAccessRestrictionsThen,
        );
    fn repos_delete_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAccessRestrictionsWhen,
            operations::ReposDeleteAccessRestrictionsThen,
        );
    fn repos_get_apps_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAppsWithAccessToProtectedBranchWhen,
            operations::ReposGetAppsWithAccessToProtectedBranchThen,
        );
    fn repos_set_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetAppAccessRestrictionsWhen,
            operations::ReposSetAppAccessRestrictionsThen,
        );
    fn repos_add_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddAppAccessRestrictionsWhen,
            operations::ReposAddAppAccessRestrictionsThen,
        );
    fn repos_remove_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveAppAccessRestrictionsWhen,
            operations::ReposRemoveAppAccessRestrictionsThen,
        );
    fn repos_get_teams_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetTeamsWithAccessToProtectedBranchWhen,
            operations::ReposGetTeamsWithAccessToProtectedBranchThen,
        );
    fn repos_set_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetTeamAccessRestrictionsWhen,
            operations::ReposSetTeamAccessRestrictionsThen,
        );
    fn repos_add_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddTeamAccessRestrictionsWhen,
            operations::ReposAddTeamAccessRestrictionsThen,
        );
    fn repos_remove_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveTeamAccessRestrictionsWhen,
            operations::ReposRemoveTeamAccessRestrictionsThen,
        );
    fn repos_get_users_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetUsersWithAccessToProtectedBranchWhen,
            operations::ReposGetUsersWithAccessToProtectedBranchThen,
        );
    fn repos_set_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetUserAccessRestrictionsWhen,
            operations::ReposSetUserAccessRestrictionsThen,
        );
    fn repos_add_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddUserAccessRestrictionsWhen,
            operations::ReposAddUserAccessRestrictionsThen,
        );
    fn repos_remove_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveUserAccessRestrictionsWhen,
            operations::ReposRemoveUserAccessRestrictionsThen,
        );
    fn repos_rename_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRenameBranchWhen, operations::ReposRenameBranchThen);
    fn checks_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksCreateWhen, operations::ChecksCreateThen);
    fn checks_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksGetWhen, operations::ChecksGetThen);
    fn checks_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksUpdateWhen, operations::ChecksUpdateThen);
    fn checks_list_annotations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListAnnotationsWhen, operations::ChecksListAnnotationsThen);
    fn checks_rerequest_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksRerequestRunWhen, operations::ChecksRerequestRunThen);
    fn checks_create_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksCreateSuiteWhen, operations::ChecksCreateSuiteThen);
    fn checks_set_suites_preferences<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ChecksSetSuitesPreferencesWhen,
            operations::ChecksSetSuitesPreferencesThen,
        );
    fn checks_get_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksGetSuiteWhen, operations::ChecksGetSuiteThen);
    fn checks_list_for_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListForSuiteWhen, operations::ChecksListForSuiteThen);
    fn checks_rerequest_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksRerequestSuiteWhen, operations::ChecksRerequestSuiteThen);
    fn code_scanning_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertsForRepoWhen,
            operations::CodeScanningListAlertsForRepoThen,
        );
    fn code_scanning_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetAlertWhen, operations::CodeScanningGetAlertThen);
    fn code_scanning_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningUpdateAlertWhen, operations::CodeScanningUpdateAlertThen);
    fn code_scanning_list_alert_instances<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertInstancesWhen,
            operations::CodeScanningListAlertInstancesThen,
        );
    fn code_scanning_list_recent_analyses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListRecentAnalysesWhen,
            operations::CodeScanningListRecentAnalysesThen,
        );
    fn code_scanning_get_analysis<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetAnalysisWhen, operations::CodeScanningGetAnalysisThen);
    fn code_scanning_delete_analysis<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningDeleteAnalysisWhen,
            operations::CodeScanningDeleteAnalysisThen,
        );
    fn code_scanning_list_codeql_databases<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListCodeqlDatabasesWhen,
            operations::CodeScanningListCodeqlDatabasesThen,
        );
    fn code_scanning_get_codeql_database<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningGetCodeqlDatabaseWhen,
            operations::CodeScanningGetCodeqlDatabaseThen,
        );
    fn code_scanning_get_default_setup<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningGetDefaultSetupWhen,
            operations::CodeScanningGetDefaultSetupThen,
        );
    fn code_scanning_update_default_setup<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningUpdateDefaultSetupWhen,
            operations::CodeScanningUpdateDefaultSetupThen,
        );
    fn code_scanning_upload_sarif<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningUploadSarifWhen, operations::CodeScanningUploadSarifThen);
    fn code_scanning_get_sarif<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetSarifWhen, operations::CodeScanningGetSarifThen);
    fn repos_codeowners_errors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCodeownersErrorsWhen, operations::ReposCodeownersErrorsThen);
    fn codespaces_list_in_repository_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListInRepositoryForAuthenticatedUserWhen,
            operations::CodespacesListInRepositoryForAuthenticatedUserThen,
        );
    fn codespaces_create_with_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateWithRepoForAuthenticatedUserWhen,
            operations::CodespacesCreateWithRepoForAuthenticatedUserThen,
        );
    fn codespaces_list_devcontainers_in_repository_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserWhen,
            operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserThen,
        );
    fn codespaces_repo_machines_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRepoMachinesForAuthenticatedUserWhen,
            operations::CodespacesRepoMachinesForAuthenticatedUserThen,
        );
    fn codespaces_pre_flight_with_repo_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesPreFlightWithRepoForAuthenticatedUserWhen,
            operations::CodespacesPreFlightWithRepoForAuthenticatedUserThen,
        );
    fn codespaces_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListRepoSecretsWhen,
            operations::CodespacesListRepoSecretsThen,
        );
    fn codespaces_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetRepoPublicKeyWhen,
            operations::CodespacesGetRepoPublicKeyThen,
        );
    fn codespaces_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodespacesGetRepoSecretWhen, operations::CodespacesGetRepoSecretThen);
    fn codespaces_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateRepoSecretWhen,
            operations::CodespacesCreateOrUpdateRepoSecretThen,
        );
    fn codespaces_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteRepoSecretWhen,
            operations::CodespacesDeleteRepoSecretThen,
        );
    fn repos_list_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListCollaboratorsWhen, operations::ReposListCollaboratorsThen);
    fn repos_check_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCheckCollaboratorWhen, operations::ReposCheckCollaboratorThen);
    fn repos_add_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposAddCollaboratorWhen, operations::ReposAddCollaboratorThen);
    fn repos_remove_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRemoveCollaboratorWhen, operations::ReposRemoveCollaboratorThen);
    fn repos_get_collaborator_permission_level<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCollaboratorPermissionLevelWhen,
            operations::ReposGetCollaboratorPermissionLevelThen,
        );
    fn repos_list_commit_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommitCommentsForRepoWhen,
            operations::ReposListCommitCommentsForRepoThen,
        );
    fn repos_get_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetCommitCommentWhen, operations::ReposGetCommitCommentThen);
    fn repos_delete_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteCommitCommentWhen,
            operations::ReposDeleteCommitCommentThen,
        );
    fn repos_update_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateCommitCommentWhen,
            operations::ReposUpdateCommitCommentThen,
        );
    fn reactions_list_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForCommitCommentWhen,
            operations::ReactionsListForCommitCommentThen,
        );
    fn reactions_create_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForCommitCommentWhen,
            operations::ReactionsCreateForCommitCommentThen,
        );
    fn reactions_delete_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForCommitCommentWhen,
            operations::ReactionsDeleteForCommitCommentThen,
        );
    fn repos_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListCommitsWhen, operations::ReposListCommitsThen);
    fn repos_list_branches_for_head_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListBranchesForHeadCommitWhen,
            operations::ReposListBranchesForHeadCommitThen,
        );
    fn repos_list_comments_for_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommentsForCommitWhen,
            operations::ReposListCommentsForCommitThen,
        );
    fn repos_create_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateCommitCommentWhen,
            operations::ReposCreateCommitCommentThen,
        );
    fn repos_list_pull_requests_associated_with_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListPullRequestsAssociatedWithCommitWhen,
            operations::ReposListPullRequestsAssociatedWithCommitThen,
        );
    fn repos_get_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetCommitWhen, operations::ReposGetCommitThen);
    fn checks_list_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListForRefWhen, operations::ChecksListForRefThen);
    fn checks_list_suites_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListSuitesForRefWhen, operations::ChecksListSuitesForRefThen);
    fn repos_get_combined_status_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCombinedStatusForRefWhen,
            operations::ReposGetCombinedStatusForRefThen,
        );
    fn repos_list_commit_statuses_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommitStatusesForRefWhen,
            operations::ReposListCommitStatusesForRefThen,
        );
    fn repos_get_community_profile_metrics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommunityProfileMetricsWhen,
            operations::ReposGetCommunityProfileMetricsThen,
        );
    fn repos_compare_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCompareCommitsWhen, operations::ReposCompareCommitsThen);
    fn repos_get_content<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetContentWhen, operations::ReposGetContentThen);
    fn repos_create_or_update_file_contents<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateOrUpdateFileContentsWhen,
            operations::ReposCreateOrUpdateFileContentsThen,
        );
    fn repos_delete_file<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteFileWhen, operations::ReposDeleteFileThen);
    fn repos_list_contributors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListContributorsWhen, operations::ReposListContributorsThen);
    fn dependabot_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForRepoWhen,
            operations::DependabotListAlertsForRepoThen,
        );
    fn dependabot_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetAlertWhen, operations::DependabotGetAlertThen);
    fn dependabot_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotUpdateAlertWhen, operations::DependabotUpdateAlertThen);
    fn dependabot_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListRepoSecretsWhen,
            operations::DependabotListRepoSecretsThen,
        );
    fn dependabot_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotGetRepoPublicKeyWhen,
            operations::DependabotGetRepoPublicKeyThen,
        );
    fn dependabot_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetRepoSecretWhen, operations::DependabotGetRepoSecretThen);
    fn dependabot_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotCreateOrUpdateRepoSecretWhen,
            operations::DependabotCreateOrUpdateRepoSecretThen,
        );
    fn dependabot_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotDeleteRepoSecretWhen,
            operations::DependabotDeleteRepoSecretThen,
        );
    fn dependency_graph_diff_range<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphDiffRangeWhen,
            operations::DependencyGraphDiffRangeThen,
        );
    fn dependency_graph_export_sbom<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphExportSbomWhen,
            operations::DependencyGraphExportSbomThen,
        );
    fn dependency_graph_create_repository_snapshot<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphCreateRepositorySnapshotWhen,
            operations::DependencyGraphCreateRepositorySnapshotThen,
        );
    fn repos_list_deployments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListDeploymentsWhen, operations::ReposListDeploymentsThen);
    fn repos_create_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateDeploymentWhen, operations::ReposCreateDeploymentThen);
    fn repos_get_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetDeploymentWhen, operations::ReposGetDeploymentThen);
    fn repos_delete_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteDeploymentWhen, operations::ReposDeleteDeploymentThen);
    fn repos_list_deployment_statuses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListDeploymentStatusesWhen,
            operations::ReposListDeploymentStatusesThen,
        );
    fn repos_create_deployment_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentStatusWhen,
            operations::ReposCreateDeploymentStatusThen,
        );
    fn repos_get_deployment_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetDeploymentStatusWhen,
            operations::ReposGetDeploymentStatusThen,
        );
    fn repos_create_dispatch_event<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDispatchEventWhen,
            operations::ReposCreateDispatchEventThen,
        );
    fn repos_get_all_environments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAllEnvironmentsWhen, operations::ReposGetAllEnvironmentsThen);
    fn repos_get_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetEnvironmentWhen, operations::ReposGetEnvironmentThen);
    fn repos_create_or_update_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateOrUpdateEnvironmentWhen,
            operations::ReposCreateOrUpdateEnvironmentThen,
        );
    fn repos_delete_an_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAnEnvironmentWhen,
            operations::ReposDeleteAnEnvironmentThen,
        );
    fn repos_list_deployment_branch_policies<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListDeploymentBranchPoliciesWhen,
            operations::ReposListDeploymentBranchPoliciesThen,
        );
    fn repos_create_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentBranchPolicyWhen,
            operations::ReposCreateDeploymentBranchPolicyThen,
        );
    fn repos_get_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetDeploymentBranchPolicyWhen,
            operations::ReposGetDeploymentBranchPolicyThen,
        );
    fn repos_update_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateDeploymentBranchPolicyWhen,
            operations::ReposUpdateDeploymentBranchPolicyThen,
        );
    fn repos_delete_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteDeploymentBranchPolicyWhen,
            operations::ReposDeleteDeploymentBranchPolicyThen,
        );
    fn repos_get_all_deployment_protection_rules<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAllDeploymentProtectionRulesWhen,
            operations::ReposGetAllDeploymentProtectionRulesThen,
        );
    fn repos_create_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentProtectionRuleWhen,
            operations::ReposCreateDeploymentProtectionRuleThen,
        );
    fn repos_list_custom_deployment_rule_integrations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCustomDeploymentRuleIntegrationsWhen,
            operations::ReposListCustomDeploymentRuleIntegrationsThen,
        );
    fn repos_get_custom_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCustomDeploymentProtectionRuleWhen,
            operations::ReposGetCustomDeploymentProtectionRuleThen,
        );
    fn repos_disable_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableDeploymentProtectionRuleWhen,
            operations::ReposDisableDeploymentProtectionRuleThen,
        );
    fn activity_list_repo_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityListRepoEventsWhen, operations::ActivityListRepoEventsThen);
    fn repos_list_forks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForksWhen, operations::ReposListForksThen);
    fn repos_create_fork<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateForkWhen, operations::ReposCreateForkThen);
    fn git_create_blob<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateBlobWhen, operations::GitCreateBlobThen);
    fn git_get_blob<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetBlobWhen, operations::GitGetBlobThen);
    fn git_create_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateCommitWhen, operations::GitCreateCommitThen);
    fn git_get_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetCommitWhen, operations::GitGetCommitThen);
    fn git_list_matching_refs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitListMatchingRefsWhen, operations::GitListMatchingRefsThen);
    fn git_get_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetRefWhen, operations::GitGetRefThen);
    fn git_create_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateRefWhen, operations::GitCreateRefThen);
    fn git_delete_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitDeleteRefWhen, operations::GitDeleteRefThen);
    fn git_update_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitUpdateRefWhen, operations::GitUpdateRefThen);
    fn git_create_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateTagWhen, operations::GitCreateTagThen);
    fn git_get_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetTagWhen, operations::GitGetTagThen);
    fn git_create_tree<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateTreeWhen, operations::GitCreateTreeThen);
    fn git_get_tree<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetTreeWhen, operations::GitGetTreeThen);
    fn repos_list_webhooks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListWebhooksWhen, operations::ReposListWebhooksThen);
    fn repos_create_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateWebhookWhen, operations::ReposCreateWebhookThen);
    fn repos_get_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWebhookWhen, operations::ReposGetWebhookThen);
    fn repos_delete_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteWebhookWhen, operations::ReposDeleteWebhookThen);
    fn repos_update_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateWebhookWhen, operations::ReposUpdateWebhookThen);
    fn repos_get_webhook_config_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetWebhookConfigForRepoWhen,
            operations::ReposGetWebhookConfigForRepoThen,
        );
    fn repos_update_webhook_config_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateWebhookConfigForRepoWhen,
            operations::ReposUpdateWebhookConfigForRepoThen,
        );
    fn repos_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListWebhookDeliveriesWhen,
            operations::ReposListWebhookDeliveriesThen,
        );
    fn repos_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWebhookDeliveryWhen, operations::ReposGetWebhookDeliveryThen);
    fn repos_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRedeliverWebhookDeliveryWhen,
            operations::ReposRedeliverWebhookDeliveryThen,
        );
    fn repos_ping_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposPingWebhookWhen, operations::ReposPingWebhookThen);
    fn repos_test_push_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposTestPushWebhookWhen, operations::ReposTestPushWebhookThen);
    fn migrations_get_import_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetImportStatusWhen,
            operations::MigrationsGetImportStatusThen,
        );
    fn migrations_start_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsStartImportWhen, operations::MigrationsStartImportThen);
    fn migrations_cancel_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsCancelImportWhen, operations::MigrationsCancelImportThen);
    fn migrations_update_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsUpdateImportWhen, operations::MigrationsUpdateImportThen);
    fn migrations_get_commit_authors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetCommitAuthorsWhen,
            operations::MigrationsGetCommitAuthorsThen,
        );
    fn migrations_map_commit_author<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsMapCommitAuthorWhen,
            operations::MigrationsMapCommitAuthorThen,
        );
    fn migrations_get_large_files<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsGetLargeFilesWhen, operations::MigrationsGetLargeFilesThen);
    fn migrations_set_lfs_preference<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsSetLfsPreferenceWhen,
            operations::MigrationsSetLfsPreferenceThen,
        );
    fn apps_get_repo_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetRepoInstallationWhen, operations::AppsGetRepoInstallationThen);
    fn interactions_get_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForRepoWhen,
            operations::InteractionsGetRestrictionsForRepoThen,
        );
    fn interactions_set_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForRepoWhen,
            operations::InteractionsSetRestrictionsForRepoThen,
        );
    fn interactions_remove_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForRepoWhen,
            operations::InteractionsRemoveRestrictionsForRepoThen,
        );
    fn repos_list_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListInvitationsWhen, operations::ReposListInvitationsThen);
    fn repos_delete_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteInvitationWhen, operations::ReposDeleteInvitationThen);
    fn repos_update_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateInvitationWhen, operations::ReposUpdateInvitationThen);
    fn issues_list_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListForRepoWhen, operations::IssuesListForRepoThen);
    fn issues_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateWhen, operations::IssuesCreateThen);
    fn issues_list_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListCommentsForRepoWhen,
            operations::IssuesListCommentsForRepoThen,
        );
    fn issues_get_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetCommentWhen, operations::IssuesGetCommentThen);
    fn issues_delete_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteCommentWhen, operations::IssuesDeleteCommentThen);
    fn issues_update_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateCommentWhen, operations::IssuesUpdateCommentThen);
    fn reactions_list_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForIssueCommentWhen,
            operations::ReactionsListForIssueCommentThen,
        );
    fn reactions_create_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForIssueCommentWhen,
            operations::ReactionsCreateForIssueCommentThen,
        );
    fn reactions_delete_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForIssueCommentWhen,
            operations::ReactionsDeleteForIssueCommentThen,
        );
    fn issues_list_events_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListEventsForRepoWhen, operations::IssuesListEventsForRepoThen);
    fn issues_get_event<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetEventWhen, operations::IssuesGetEventThen);
    fn issues_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetWhen, operations::IssuesGetThen);
    fn issues_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateWhen, operations::IssuesUpdateThen);
    fn issues_add_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesAddAssigneesWhen, operations::IssuesAddAssigneesThen);
    fn issues_remove_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveAssigneesWhen, operations::IssuesRemoveAssigneesThen);
    fn issues_check_user_can_be_assigned_to_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesCheckUserCanBeAssignedToIssueWhen,
            operations::IssuesCheckUserCanBeAssignedToIssueThen,
        );
    fn issues_list_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListCommentsWhen, operations::IssuesListCommentsThen);
    fn issues_create_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateCommentWhen, operations::IssuesCreateCommentThen);
    fn issues_list_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListEventsWhen, operations::IssuesListEventsThen);
    fn issues_list_labels_on_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListLabelsOnIssueWhen, operations::IssuesListLabelsOnIssueThen);
    fn issues_set_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesSetLabelsWhen, operations::IssuesSetLabelsThen);
    fn issues_add_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesAddLabelsWhen, operations::IssuesAddLabelsThen);
    fn issues_remove_all_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveAllLabelsWhen, operations::IssuesRemoveAllLabelsThen);
    fn issues_remove_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveLabelWhen, operations::IssuesRemoveLabelThen);
    fn issues_lock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesLockWhen, operations::IssuesLockThen);
    fn issues_unlock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUnlockWhen, operations::IssuesUnlockThen);
    fn reactions_list_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsListForIssueWhen, operations::ReactionsListForIssueThen);
    fn reactions_create_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsCreateForIssueWhen, operations::ReactionsCreateForIssueThen);
    fn reactions_delete_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsDeleteForIssueWhen, operations::ReactionsDeleteForIssueThen);
    fn issues_list_events_for_timeline<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListEventsForTimelineWhen,
            operations::IssuesListEventsForTimelineThen,
        );
    fn repos_list_deploy_keys<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListDeployKeysWhen, operations::ReposListDeployKeysThen);
    fn repos_create_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateDeployKeyWhen, operations::ReposCreateDeployKeyThen);
    fn repos_get_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetDeployKeyWhen, operations::ReposGetDeployKeyThen);
    fn repos_delete_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteDeployKeyWhen, operations::ReposDeleteDeployKeyThen);
    fn issues_list_labels_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListLabelsForRepoWhen, operations::IssuesListLabelsForRepoThen);
    fn issues_create_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateLabelWhen, operations::IssuesCreateLabelThen);
    fn issues_get_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetLabelWhen, operations::IssuesGetLabelThen);
    fn issues_delete_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteLabelWhen, operations::IssuesDeleteLabelThen);
    fn issues_update_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateLabelWhen, operations::IssuesUpdateLabelThen);
    fn repos_list_languages<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListLanguagesWhen, operations::ReposListLanguagesThen);
    fn repos_enable_lfs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposEnableLfsForRepoWhen, operations::ReposEnableLfsForRepoThen);
    fn repos_disable_lfs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDisableLfsForRepoWhen, operations::ReposDisableLfsForRepoThen);
    fn licenses_get_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::LicensesGetForRepoWhen, operations::LicensesGetForRepoThen);
    fn repos_merge_upstream<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposMergeUpstreamWhen, operations::ReposMergeUpstreamThen);
    fn repos_merge<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposMergeWhen, operations::ReposMergeThen);
    fn issues_list_milestones<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListMilestonesWhen, operations::IssuesListMilestonesThen);
    fn issues_create_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateMilestoneWhen, operations::IssuesCreateMilestoneThen);
    fn issues_get_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetMilestoneWhen, operations::IssuesGetMilestoneThen);
    fn issues_delete_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteMilestoneWhen, operations::IssuesDeleteMilestoneThen);
    fn issues_update_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateMilestoneWhen, operations::IssuesUpdateMilestoneThen);
    fn issues_list_labels_for_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListLabelsForMilestoneWhen,
            operations::IssuesListLabelsForMilestoneThen,
        );
    fn activity_list_repo_notifications_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListRepoNotificationsForAuthenticatedUserWhen,
            operations::ActivityListRepoNotificationsForAuthenticatedUserThen,
        );
    fn activity_mark_repo_notifications_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkRepoNotificationsAsReadWhen,
            operations::ActivityMarkRepoNotificationsAsReadThen,
        );
    fn repos_get_pages<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPagesWhen, operations::ReposGetPagesThen);
    fn repos_update_information_about_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateInformationAboutPagesSiteWhen,
            operations::ReposUpdateInformationAboutPagesSiteThen,
        );
    fn repos_create_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreatePagesSiteWhen, operations::ReposCreatePagesSiteThen);
    fn repos_delete_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeletePagesSiteWhen, operations::ReposDeletePagesSiteThen);
    fn repos_list_pages_builds<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListPagesBuildsWhen, operations::ReposListPagesBuildsThen);
    fn repos_request_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRequestPagesBuildWhen, operations::ReposRequestPagesBuildThen);
    fn repos_get_latest_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetLatestPagesBuildWhen,
            operations::ReposGetLatestPagesBuildThen,
        );
    fn repos_get_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPagesBuildWhen, operations::ReposGetPagesBuildThen);
    fn repos_create_pages_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreatePagesDeploymentWhen,
            operations::ReposCreatePagesDeploymentThen,
        );
    fn repos_get_pages_health_check<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetPagesHealthCheckWhen,
            operations::ReposGetPagesHealthCheckThen,
        );
    fn projects_list_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForRepoWhen, operations::ProjectsListForRepoThen);
    fn projects_create_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateForRepoWhen, operations::ProjectsCreateForRepoThen);
    fn pulls_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListWhen, operations::PullsListThen);
    fn pulls_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCreateWhen, operations::PullsCreateThen);
    fn pulls_list_review_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListReviewCommentsForRepoWhen,
            operations::PullsListReviewCommentsForRepoThen,
        );
    fn pulls_get_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetReviewCommentWhen, operations::PullsGetReviewCommentThen);
    fn pulls_delete_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsDeleteReviewCommentWhen,
            operations::PullsDeleteReviewCommentThen,
        );
    fn pulls_update_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsUpdateReviewCommentWhen,
            operations::PullsUpdateReviewCommentThen,
        );
    fn reactions_list_for_pull_request_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForPullRequestReviewCommentWhen,
            operations::ReactionsListForPullRequestReviewCommentThen,
        );
    fn reactions_create_for_pull_request_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForPullRequestReviewCommentWhen,
            operations::ReactionsCreateForPullRequestReviewCommentThen,
        );
    fn reactions_delete_for_pull_request_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForPullRequestCommentWhen,
            operations::ReactionsDeleteForPullRequestCommentThen,
        );
    fn pulls_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetWhen, operations::PullsGetThen);
    fn pulls_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateWhen, operations::PullsUpdateThen);
    fn codespaces_create_with_pr_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateWithPrForAuthenticatedUserWhen,
            operations::CodespacesCreateWithPrForAuthenticatedUserThen,
        );
    fn pulls_list_review_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListReviewCommentsWhen, operations::PullsListReviewCommentsThen);
    fn pulls_create_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsCreateReviewCommentWhen,
            operations::PullsCreateReviewCommentThen,
        );
    fn pulls_create_reply_for_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsCreateReplyForReviewCommentWhen,
            operations::PullsCreateReplyForReviewCommentThen,
        );
    fn pulls_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListCommitsWhen, operations::PullsListCommitsThen);
    fn pulls_list_files<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListFilesWhen, operations::PullsListFilesThen);
    fn pulls_check_if_merged<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCheckIfMergedWhen, operations::PullsCheckIfMergedThen);
    fn pulls_merge<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsMergeWhen, operations::PullsMergeThen);
    fn pulls_list_requested_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListRequestedReviewersWhen,
            operations::PullsListRequestedReviewersThen,
        );
    fn pulls_request_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsRequestReviewersWhen, operations::PullsRequestReviewersThen);
    fn pulls_remove_requested_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsRemoveRequestedReviewersWhen,
            operations::PullsRemoveRequestedReviewersThen,
        );
    fn pulls_list_reviews<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListReviewsWhen, operations::PullsListReviewsThen);
    fn pulls_create_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCreateReviewWhen, operations::PullsCreateReviewThen);
    fn pulls_get_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetReviewWhen, operations::PullsGetReviewThen);
    fn pulls_update_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateReviewWhen, operations::PullsUpdateReviewThen);
    fn pulls_delete_pending_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsDeletePendingReviewWhen,
            operations::PullsDeletePendingReviewThen,
        );
    fn pulls_list_comments_for_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListCommentsForReviewWhen,
            operations::PullsListCommentsForReviewThen,
        );
    fn pulls_dismiss_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsDismissReviewWhen, operations::PullsDismissReviewThen);
    fn pulls_submit_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsSubmitReviewWhen, operations::PullsSubmitReviewThen);
    fn pulls_update_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateBranchWhen, operations::PullsUpdateBranchThen);
    fn repos_get_readme<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReadmeWhen, operations::ReposGetReadmeThen);
    fn repos_get_readme_in_directory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetReadmeInDirectoryWhen,
            operations::ReposGetReadmeInDirectoryThen,
        );
    fn activity_list_repos_watched_by_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposWatchedByUserWhen,
            operations::ActivityListReposWatchedByUserThen,
        );
    fn repos_get_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReleaseAssetWhen, operations::ReposGetReleaseAssetThen);
    fn repos_delete_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteReleaseAssetWhen, operations::ReposDeleteReleaseAssetThen);
    fn repos_update_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateReleaseAssetWhen, operations::ReposUpdateReleaseAssetThen);
    fn repos_generate_release_notes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGenerateReleaseNotesWhen,
            operations::ReposGenerateReleaseNotesThen,
        );
    fn repos_get_latest_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetLatestReleaseWhen, operations::ReposGetLatestReleaseThen);
    fn repos_get_release_by_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReleaseByTagWhen, operations::ReposGetReleaseByTagThen);
    fn activity_list_repos_starred_by_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposStarredByUserWhen,
            operations::ActivityListReposStarredByUserThen,
        );
    fn repos_list_release_assets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListReleaseAssetsWhen, operations::ReposListReleaseAssetsThen);
    fn repos_upload_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUploadReleaseAssetWhen, operations::ReposUploadReleaseAssetThen);
    fn reactions_list_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsListForReleaseWhen, operations::ReactionsListForReleaseThen);
    fn reactions_create_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForReleaseWhen,
            operations::ReactionsCreateForReleaseThen,
        );
    fn reactions_delete_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForReleaseWhen,
            operations::ReactionsDeleteForReleaseThen,
        );
    fn repos_get_branch_rules<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetBranchRulesWhen, operations::ReposGetBranchRulesThen);
    fn repos_get_repo_rulesets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetRepoRulesetsWhen, operations::ReposGetRepoRulesetsThen);
    fn repos_create_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateRepoRulesetWhen, operations::ReposCreateRepoRulesetThen);
    fn repos_get_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetRepoRulesetWhen, operations::ReposGetRepoRulesetThen);
    fn repos_update_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateRepoRulesetWhen, operations::ReposUpdateRepoRulesetThen);
    fn repos_delete_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteRepoRulesetWhen, operations::ReposDeleteRepoRulesetThen);
    fn secret_scanning_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForRepoWhen,
            operations::SecretScanningListAlertsForRepoThen,
        );
    fn secret_scanning_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SecretScanningGetAlertWhen, operations::SecretScanningGetAlertThen);
    fn secret_scanning_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningUpdateAlertWhen,
            operations::SecretScanningUpdateAlertThen,
        );
    fn secret_scanning_list_locations_for_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListLocationsForAlertWhen,
            operations::SecretScanningListLocationsForAlertThen,
        );
    fn security_advisories_list_repository_advisories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesListRepositoryAdvisoriesWhen,
            operations::SecurityAdvisoriesListRepositoryAdvisoriesThen,
        );
    fn security_advisories_create_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesCreateRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesCreateRepositoryAdvisoryThen,
        );
    fn security_advisories_create_private_vulnerability_report<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportWhen,
            operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportThen,
        );
    fn security_advisories_get_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesGetRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesGetRepositoryAdvisoryThen,
        );
    fn security_advisories_update_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesUpdateRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesUpdateRepositoryAdvisoryThen,
        );
    fn activity_list_stargazers_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListStargazersForRepoWhen,
            operations::ActivityListStargazersForRepoThen,
        );
    fn repos_get_code_frequency_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCodeFrequencyStatsWhen,
            operations::ReposGetCodeFrequencyStatsThen,
        );
    fn repos_get_commit_activity_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommitActivityStatsWhen,
            operations::ReposGetCommitActivityStatsThen,
        );
    fn repos_get_contributors_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetContributorsStatsWhen,
            operations::ReposGetContributorsStatsThen,
        );
    fn repos_get_participation_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetParticipationStatsWhen,
            operations::ReposGetParticipationStatsThen,
        );
    fn repos_get_punch_card_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPunchCardStatsWhen, operations::ReposGetPunchCardStatsThen);
    fn repos_create_commit_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateCommitStatusWhen, operations::ReposCreateCommitStatusThen);
    fn activity_list_watchers_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListWatchersForRepoWhen,
            operations::ActivityListWatchersForRepoThen,
        );
    fn activity_get_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityGetRepoSubscriptionWhen,
            operations::ActivityGetRepoSubscriptionThen,
        );
    fn activity_set_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivitySetRepoSubscriptionWhen,
            operations::ActivitySetRepoSubscriptionThen,
        );
    fn activity_delete_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityDeleteRepoSubscriptionWhen,
            operations::ActivityDeleteRepoSubscriptionThen,
        );
    fn repos_list_tags<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTagsWhen, operations::ReposListTagsThen);
    fn repos_list_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTagProtectionWhen, operations::ReposListTagProtectionThen);
    fn repos_create_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateTagProtectionWhen,
            operations::ReposCreateTagProtectionThen,
        );
    fn repos_delete_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteTagProtectionWhen,
            operations::ReposDeleteTagProtectionThen,
        );
    fn repos_download_tarball_archive<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDownloadTarballArchiveWhen,
            operations::ReposDownloadTarballArchiveThen,
        );
    fn repos_list_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTeamsWhen, operations::ReposListTeamsThen);
    fn repos_get_all_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAllTopicsWhen, operations::ReposGetAllTopicsThen);
    fn repos_replace_all_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposReplaceAllTopicsWhen, operations::ReposReplaceAllTopicsThen);
    fn repos_get_clones<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetClonesWhen, operations::ReposGetClonesThen);
    fn repos_get_top_paths<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetTopPathsWhen, operations::ReposGetTopPathsThen);
    fn repos_get_top_referrers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetTopReferrersWhen, operations::ReposGetTopReferrersThen);
    fn repos_get_views<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetViewsWhen, operations::ReposGetViewsThen);
    fn repos_transfer<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposTransferWhen, operations::ReposTransferThen);
    fn repos_check_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCheckVulnerabilityAlertsWhen,
            operations::ReposCheckVulnerabilityAlertsThen,
        );
    fn repos_enable_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposEnableVulnerabilityAlertsWhen,
            operations::ReposEnableVulnerabilityAlertsThen,
        );
    fn repos_disable_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableVulnerabilityAlertsWhen,
            operations::ReposDisableVulnerabilityAlertsThen,
        );
    fn repos_download_zipball_archive<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDownloadZipballArchiveWhen,
            operations::ReposDownloadZipballArchiveThen,
        );
    fn repos_create_using_template<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateUsingTemplateWhen,
            operations::ReposCreateUsingTemplateThen,
        );
    fn repos_list_public<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListPublicWhen, operations::ReposListPublicThen);
    fn actions_list_environment_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListEnvironmentSecretsWhen,
            operations::ActionsListEnvironmentSecretsThen,
        );
    fn actions_get_environment_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentPublicKeyWhen,
            operations::ActionsGetEnvironmentPublicKeyThen,
        );
    fn actions_get_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentSecretWhen,
            operations::ActionsGetEnvironmentSecretThen,
        );
    fn actions_create_or_update_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateEnvironmentSecretWhen,
            operations::ActionsCreateOrUpdateEnvironmentSecretThen,
        );
    fn actions_delete_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteEnvironmentSecretWhen,
            operations::ActionsDeleteEnvironmentSecretThen,
        );
    fn actions_list_environment_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListEnvironmentVariablesWhen,
            operations::ActionsListEnvironmentVariablesThen,
        );
    fn actions_create_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateEnvironmentVariableWhen,
            operations::ActionsCreateEnvironmentVariableThen,
        );
    fn actions_get_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentVariableWhen,
            operations::ActionsGetEnvironmentVariableThen,
        );
    fn actions_delete_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteEnvironmentVariableWhen,
            operations::ActionsDeleteEnvironmentVariableThen,
        );
    fn actions_update_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateEnvironmentVariableWhen,
            operations::ActionsUpdateEnvironmentVariableThen,
        );
    fn search_code<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchCodeWhen, operations::SearchCodeThen);
    fn search_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchCommitsWhen, operations::SearchCommitsThen);
    fn search_issues_and_pull_requests<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SearchIssuesAndPullRequestsWhen,
            operations::SearchIssuesAndPullRequestsThen,
        );
    fn search_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchLabelsWhen, operations::SearchLabelsThen);
    fn search_repos<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchReposWhen, operations::SearchReposThen);
    fn search_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchTopicsWhen, operations::SearchTopicsThen);
    fn search_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchUsersWhen, operations::SearchUsersThen);
    fn teams_get_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetLegacyWhen, operations::TeamsGetLegacyThen);
    fn teams_delete_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsDeleteLegacyWhen, operations::TeamsDeleteLegacyThen);
    fn teams_update_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsUpdateLegacyWhen, operations::TeamsUpdateLegacyThen);
    fn teams_list_discussions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionsLegacyWhen,
            operations::TeamsListDiscussionsLegacyThen,
        );
    fn teams_create_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionLegacyWhen,
            operations::TeamsCreateDiscussionLegacyThen,
        );
    fn teams_get_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionLegacyWhen,
            operations::TeamsGetDiscussionLegacyThen,
        );
    fn teams_delete_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionLegacyWhen,
            operations::TeamsDeleteDiscussionLegacyThen,
        );
    fn teams_update_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionLegacyWhen,
            operations::TeamsUpdateDiscussionLegacyThen,
        );
    fn teams_list_discussion_comments_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionCommentsLegacyWhen,
            operations::TeamsListDiscussionCommentsLegacyThen,
        );
    fn teams_create_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionCommentLegacyWhen,
            operations::TeamsCreateDiscussionCommentLegacyThen,
        );
    fn teams_get_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionCommentLegacyWhen,
            operations::TeamsGetDiscussionCommentLegacyThen,
        );
    fn teams_delete_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionCommentLegacyWhen,
            operations::TeamsDeleteDiscussionCommentLegacyThen,
        );
    fn teams_update_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionCommentLegacyWhen,
            operations::TeamsUpdateDiscussionCommentLegacyThen,
        );
    fn reactions_list_for_team_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionCommentLegacyWhen,
            operations::ReactionsListForTeamDiscussionCommentLegacyThen,
        );
    fn reactions_create_for_team_discussion_comment_legacy<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionCommentLegacyWhen,
            operations::ReactionsCreateForTeamDiscussionCommentLegacyThen,
        );
    fn reactions_list_for_team_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionLegacyWhen,
            operations::ReactionsListForTeamDiscussionLegacyThen,
        );
    fn reactions_create_for_team_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionLegacyWhen,
            operations::ReactionsCreateForTeamDiscussionLegacyThen,
        );
    fn teams_list_pending_invitations_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListPendingInvitationsLegacyWhen,
            operations::TeamsListPendingInvitationsLegacyThen,
        );
    fn teams_list_members_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListMembersLegacyWhen, operations::TeamsListMembersLegacyThen);
    fn teams_get_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetMemberLegacyWhen, operations::TeamsGetMemberLegacyThen);
    fn teams_add_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsAddMemberLegacyWhen, operations::TeamsAddMemberLegacyThen);
    fn teams_remove_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveMemberLegacyWhen, operations::TeamsRemoveMemberLegacyThen);
    fn teams_get_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetMembershipForUserLegacyWhen,
            operations::TeamsGetMembershipForUserLegacyThen,
        );
    fn teams_add_or_update_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateMembershipForUserLegacyWhen,
            operations::TeamsAddOrUpdateMembershipForUserLegacyThen,
        );
    fn teams_remove_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveMembershipForUserLegacyWhen,
            operations::TeamsRemoveMembershipForUserLegacyThen,
        );
    fn teams_list_projects_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListProjectsLegacyWhen, operations::TeamsListProjectsLegacyThen);
    fn teams_check_permissions_for_project_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForProjectLegacyWhen,
            operations::TeamsCheckPermissionsForProjectLegacyThen,
        );
    fn teams_add_or_update_project_permissions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateProjectPermissionsLegacyWhen,
            operations::TeamsAddOrUpdateProjectPermissionsLegacyThen,
        );
    fn teams_remove_project_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveProjectLegacyWhen,
            operations::TeamsRemoveProjectLegacyThen,
        );
    fn teams_list_repos_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListReposLegacyWhen, operations::TeamsListReposLegacyThen);
    fn teams_check_permissions_for_repo_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForRepoLegacyWhen,
            operations::TeamsCheckPermissionsForRepoLegacyThen,
        );
    fn teams_add_or_update_repo_permissions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateRepoPermissionsLegacyWhen,
            operations::TeamsAddOrUpdateRepoPermissionsLegacyThen,
        );
    fn teams_remove_repo_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveRepoLegacyWhen, operations::TeamsRemoveRepoLegacyThen);
    fn teams_list_child_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListChildLegacyWhen, operations::TeamsListChildLegacyThen);
    fn users_get_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetAuthenticatedWhen, operations::UsersGetAuthenticatedThen);
    fn users_update_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersUpdateAuthenticatedWhen,
            operations::UsersUpdateAuthenticatedThen,
        );
    fn users_list_blocked_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListBlockedByAuthenticatedUserWhen,
            operations::UsersListBlockedByAuthenticatedUserThen,
        );
    fn users_check_blocked<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersCheckBlockedWhen, operations::UsersCheckBlockedThen);
    fn users_block<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersBlockWhen, operations::UsersBlockThen);
    fn users_unblock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersUnblockWhen, operations::UsersUnblockThen);
    fn codespaces_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListForAuthenticatedUserWhen,
            operations::CodespacesListForAuthenticatedUserThen,
        );
    fn codespaces_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateForAuthenticatedUserWhen,
            operations::CodespacesCreateForAuthenticatedUserThen,
        );
    fn codespaces_list_secrets_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListSecretsForAuthenticatedUserWhen,
            operations::CodespacesListSecretsForAuthenticatedUserThen,
        );
    fn codespaces_get_public_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetPublicKeyForAuthenticatedUserWhen,
            operations::CodespacesGetPublicKeyForAuthenticatedUserThen,
        );
    fn codespaces_get_secret_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetSecretForAuthenticatedUserWhen,
            operations::CodespacesGetSecretForAuthenticatedUserThen,
        );
    fn codespaces_create_or_update_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserWhen,
            operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserThen,
        );
    fn codespaces_delete_secret_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteSecretForAuthenticatedUserWhen,
            operations::CodespacesDeleteSecretForAuthenticatedUserThen,
        );
    fn codespaces_list_repositories_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListRepositoriesForSecretForAuthenticatedUserWhen,
            operations::CodespacesListRepositoriesForSecretForAuthenticatedUserThen,
        );
    fn codespaces_set_repositories_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserWhen,
            operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserThen,
        );
    fn codespaces_add_repository_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesAddRepositoryForSecretForAuthenticatedUserWhen,
            operations::CodespacesAddRepositoryForSecretForAuthenticatedUserThen,
        );
    fn codespaces_remove_repository_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserWhen,
            operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserThen,
        );
    fn codespaces_get_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetForAuthenticatedUserWhen,
            operations::CodespacesGetForAuthenticatedUserThen,
        );
    fn codespaces_delete_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteForAuthenticatedUserWhen,
            operations::CodespacesDeleteForAuthenticatedUserThen,
        );
    fn codespaces_update_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesUpdateForAuthenticatedUserWhen,
            operations::CodespacesUpdateForAuthenticatedUserThen,
        );
    fn codespaces_export_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesExportForAuthenticatedUserWhen,
            operations::CodespacesExportForAuthenticatedUserThen,
        );
    fn codespaces_get_export_details_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetExportDetailsForAuthenticatedUserWhen,
            operations::CodespacesGetExportDetailsForAuthenticatedUserThen,
        );
    fn codespaces_codespace_machines_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCodespaceMachinesForAuthenticatedUserWhen,
            operations::CodespacesCodespaceMachinesForAuthenticatedUserThen,
        );
    fn codespaces_publish_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesPublishForAuthenticatedUserWhen,
            operations::CodespacesPublishForAuthenticatedUserThen,
        );
    fn codespaces_start_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStartForAuthenticatedUserWhen,
            operations::CodespacesStartForAuthenticatedUserThen,
        );
    fn codespaces_stop_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStopForAuthenticatedUserWhen,
            operations::CodespacesStopForAuthenticatedUserThen,
        );
    fn packages_list_docker_migration_conflicting_packages_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserThen,
        );
    fn users_set_primary_email_visibility_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserWhen,
            operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserThen,
        );
    fn users_list_emails_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListEmailsForAuthenticatedUserWhen,
            operations::UsersListEmailsForAuthenticatedUserThen,
        );
    fn users_add_email_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersAddEmailForAuthenticatedUserWhen,
            operations::UsersAddEmailForAuthenticatedUserThen,
        );
    fn users_delete_email_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteEmailForAuthenticatedUserWhen,
            operations::UsersDeleteEmailForAuthenticatedUserThen,
        );
    fn users_list_followers_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowersForAuthenticatedUserWhen,
            operations::UsersListFollowersForAuthenticatedUserThen,
        );
    fn users_list_followed_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowedByAuthenticatedUserWhen,
            operations::UsersListFollowedByAuthenticatedUserThen,
        );
    fn users_check_person_is_followed_by_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCheckPersonIsFollowedByAuthenticatedWhen,
            operations::UsersCheckPersonIsFollowedByAuthenticatedThen,
        );
    fn users_follow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersFollowWhen, operations::UsersFollowThen);
    fn users_unfollow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersUnfollowWhen, operations::UsersUnfollowThen);
    fn users_list_gpg_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListGpgKeysForAuthenticatedUserWhen,
            operations::UsersListGpgKeysForAuthenticatedUserThen,
        );
    fn users_create_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreateGpgKeyForAuthenticatedUserWhen,
            operations::UsersCreateGpgKeyForAuthenticatedUserThen,
        );
    fn users_get_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetGpgKeyForAuthenticatedUserWhen,
            operations::UsersGetGpgKeyForAuthenticatedUserThen,
        );
    fn users_delete_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteGpgKeyForAuthenticatedUserWhen,
            operations::UsersDeleteGpgKeyForAuthenticatedUserThen,
        );
    fn apps_list_installations_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationsForAuthenticatedUserWhen,
            operations::AppsListInstallationsForAuthenticatedUserThen,
        );
    fn apps_list_installation_repos_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationReposForAuthenticatedUserWhen,
            operations::AppsListInstallationReposForAuthenticatedUserThen,
        );
    fn apps_add_repo_to_installation_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsAddRepoToInstallationForAuthenticatedUserWhen,
            operations::AppsAddRepoToInstallationForAuthenticatedUserThen,
        );
    fn apps_remove_repo_from_installation_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRemoveRepoFromInstallationForAuthenticatedUserWhen,
            operations::AppsRemoveRepoFromInstallationForAuthenticatedUserThen,
        );
    fn interactions_get_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsGetRestrictionsForAuthenticatedUserThen,
        );
    fn interactions_set_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsSetRestrictionsForAuthenticatedUserThen,
        );
    fn interactions_remove_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsRemoveRestrictionsForAuthenticatedUserThen,
        );
    fn issues_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListForAuthenticatedUserWhen,
            operations::IssuesListForAuthenticatedUserThen,
        );
    fn users_list_public_ssh_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicSshKeysForAuthenticatedUserWhen,
            operations::UsersListPublicSshKeysForAuthenticatedUserThen,
        );
    fn users_create_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreatePublicSshKeyForAuthenticatedUserWhen,
            operations::UsersCreatePublicSshKeyForAuthenticatedUserThen,
        );
    fn users_get_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetPublicSshKeyForAuthenticatedUserWhen,
            operations::UsersGetPublicSshKeyForAuthenticatedUserThen,
        );
    fn users_delete_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeletePublicSshKeyForAuthenticatedUserWhen,
            operations::UsersDeletePublicSshKeyForAuthenticatedUserThen,
        );
    fn apps_list_subscriptions_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListSubscriptionsForAuthenticatedUserWhen,
            operations::AppsListSubscriptionsForAuthenticatedUserThen,
        );
    fn apps_list_subscriptions_for_authenticated_user_stubbed<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListSubscriptionsForAuthenticatedUserStubbedWhen,
            operations::AppsListSubscriptionsForAuthenticatedUserStubbedThen,
        );
    fn orgs_list_memberships_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListMembershipsForAuthenticatedUserWhen,
            operations::OrgsListMembershipsForAuthenticatedUserThen,
        );
    fn orgs_get_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetMembershipForAuthenticatedUserWhen,
            operations::OrgsGetMembershipForAuthenticatedUserThen,
        );
    fn orgs_update_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsUpdateMembershipForAuthenticatedUserWhen,
            operations::OrgsUpdateMembershipForAuthenticatedUserThen,
        );
    fn migrations_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListForAuthenticatedUserWhen,
            operations::MigrationsListForAuthenticatedUserThen,
        );
    fn migrations_start_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsStartForAuthenticatedUserWhen,
            operations::MigrationsStartForAuthenticatedUserThen,
        );
    fn migrations_get_status_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetStatusForAuthenticatedUserWhen,
            operations::MigrationsGetStatusForAuthenticatedUserThen,
        );
    fn migrations_get_archive_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetArchiveForAuthenticatedUserWhen,
            operations::MigrationsGetArchiveForAuthenticatedUserThen,
        );
    fn migrations_delete_archive_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDeleteArchiveForAuthenticatedUserWhen,
            operations::MigrationsDeleteArchiveForAuthenticatedUserThen,
        );
    fn migrations_unlock_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsUnlockRepoForAuthenticatedUserWhen,
            operations::MigrationsUnlockRepoForAuthenticatedUserThen,
        );
    fn migrations_list_repos_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListReposForAuthenticatedUserWhen,
            operations::MigrationsListReposForAuthenticatedUserThen,
        );
    fn orgs_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListForAuthenticatedUserWhen,
            operations::OrgsListForAuthenticatedUserThen,
        );
    fn packages_list_packages_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForAuthenticatedUserWhen,
            operations::PackagesListPackagesForAuthenticatedUserThen,
        );
    fn packages_get_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForAuthenticatedUserWhen,
            operations::PackagesGetPackageForAuthenticatedUserThen,
        );
    fn packages_delete_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForAuthenticatedUserWhen,
            operations::PackagesDeletePackageForAuthenticatedUserThen,
        );
    fn packages_restore_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForAuthenticatedUserWhen,
            operations::PackagesRestorePackageForAuthenticatedUserThen,
        );
    fn packages_get_all_package_versions_for_package_owned_by_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserThen,
        );
    fn packages_get_package_version_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForAuthenticatedUserWhen,
            operations::PackagesGetPackageVersionForAuthenticatedUserThen,
        );
    fn packages_delete_package_version_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForAuthenticatedUserWhen,
            operations::PackagesDeletePackageVersionForAuthenticatedUserThen,
        );
    fn packages_restore_package_version_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForAuthenticatedUserWhen,
            operations::PackagesRestorePackageVersionForAuthenticatedUserThen,
        );
    fn projects_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsCreateForAuthenticatedUserWhen,
            operations::ProjectsCreateForAuthenticatedUserThen,
        );
    fn users_list_public_emails_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicEmailsForAuthenticatedUserWhen,
            operations::UsersListPublicEmailsForAuthenticatedUserThen,
        );
    fn repos_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListForAuthenticatedUserWhen,
            operations::ReposListForAuthenticatedUserThen,
        );
    fn repos_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateForAuthenticatedUserWhen,
            operations::ReposCreateForAuthenticatedUserThen,
        );
    fn repos_list_invitations_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListInvitationsForAuthenticatedUserWhen,
            operations::ReposListInvitationsForAuthenticatedUserThen,
        );
    fn repos_decline_invitation_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeclineInvitationForAuthenticatedUserWhen,
            operations::ReposDeclineInvitationForAuthenticatedUserThen,
        );
    fn repos_accept_invitation_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAcceptInvitationForAuthenticatedUserWhen,
            operations::ReposAcceptInvitationForAuthenticatedUserThen,
        );
    fn users_list_social_accounts_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSocialAccountsForAuthenticatedUserWhen,
            operations::UsersListSocialAccountsForAuthenticatedUserThen,
        );
    fn users_add_social_account_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersAddSocialAccountForAuthenticatedUserWhen,
            operations::UsersAddSocialAccountForAuthenticatedUserThen,
        );
    fn users_delete_social_account_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteSocialAccountForAuthenticatedUserWhen,
            operations::UsersDeleteSocialAccountForAuthenticatedUserThen,
        );
    fn users_list_ssh_signing_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSshSigningKeysForAuthenticatedUserWhen,
            operations::UsersListSshSigningKeysForAuthenticatedUserThen,
        );
    fn users_create_ssh_signing_key_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreateSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersCreateSshSigningKeyForAuthenticatedUserThen,
        );
    fn users_get_ssh_signing_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersGetSshSigningKeyForAuthenticatedUserThen,
        );
    fn users_delete_ssh_signing_key_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersDeleteSshSigningKeyForAuthenticatedUserThen,
        );
    fn activity_list_repos_starred_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposStarredByAuthenticatedUserWhen,
            operations::ActivityListReposStarredByAuthenticatedUserThen,
        );
    fn activity_check_repo_is_starred_by_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityCheckRepoIsStarredByAuthenticatedUserWhen,
            operations::ActivityCheckRepoIsStarredByAuthenticatedUserThen,
        );
    fn activity_star_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityStarRepoForAuthenticatedUserWhen,
            operations::ActivityStarRepoForAuthenticatedUserThen,
        );
    fn activity_unstar_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityUnstarRepoForAuthenticatedUserWhen,
            operations::ActivityUnstarRepoForAuthenticatedUserThen,
        );
    fn activity_list_watched_repos_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListWatchedReposForAuthenticatedUserWhen,
            operations::ActivityListWatchedReposForAuthenticatedUserThen,
        );
    fn teams_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListForAuthenticatedUserWhen,
            operations::TeamsListForAuthenticatedUserThen,
        );
    fn users_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersListWhen, operations::UsersListThen);
    fn users_get_by_username<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetByUsernameWhen, operations::UsersGetByUsernameThen);
    fn packages_list_docker_migration_conflicting_packages_for_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForUserWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForUserThen,
        );
    fn activity_list_events_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListEventsForAuthenticatedUserWhen,
            operations::ActivityListEventsForAuthenticatedUserThen,
        );
    fn activity_list_org_events_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListOrgEventsForAuthenticatedUserWhen,
            operations::ActivityListOrgEventsForAuthenticatedUserThen,
        );
    fn activity_list_public_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsForUserWhen,
            operations::ActivityListPublicEventsForUserThen,
        );
    fn users_list_followers_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowersForUserWhen,
            operations::UsersListFollowersForUserThen,
        );
    fn users_list_following_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowingForUserWhen,
            operations::UsersListFollowingForUserThen,
        );
    fn users_check_following_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCheckFollowingForUserWhen,
            operations::UsersCheckFollowingForUserThen,
        );
    fn gists_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListForUserWhen, operations::GistsListForUserThen);
    fn users_list_gpg_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersListGpgKeysForUserWhen, operations::UsersListGpgKeysForUserThen);
    fn users_get_context_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetContextForUserWhen, operations::UsersGetContextForUserThen);
    fn apps_get_user_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetUserInstallationWhen, operations::AppsGetUserInstallationThen);
    fn users_list_public_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicKeysForUserWhen,
            operations::UsersListPublicKeysForUserThen,
        );
    fn orgs_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListForUserWhen, operations::OrgsListForUserThen);
    fn packages_list_packages_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForUserWhen,
            operations::PackagesListPackagesForUserThen,
        );
    fn packages_get_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForUserWhen,
            operations::PackagesGetPackageForUserThen,
        );
    fn packages_delete_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForUserWhen,
            operations::PackagesDeletePackageForUserThen,
        );
    fn packages_restore_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForUserWhen,
            operations::PackagesRestorePackageForUserThen,
        );
    fn packages_get_all_package_versions_for_package_owned_by_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByUserWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByUserThen,
        );
    fn packages_get_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForUserWhen,
            operations::PackagesGetPackageVersionForUserThen,
        );
    fn packages_delete_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForUserWhen,
            operations::PackagesDeletePackageVersionForUserThen,
        );
    fn packages_restore_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForUserWhen,
            operations::PackagesRestorePackageVersionForUserThen,
        );
    fn projects_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForUserWhen, operations::ProjectsListForUserThen);
    fn activity_list_received_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReceivedEventsForUserWhen,
            operations::ActivityListReceivedEventsForUserThen,
        );
    fn activity_list_received_public_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReceivedPublicEventsForUserWhen,
            operations::ActivityListReceivedPublicEventsForUserThen,
        );
    fn repos_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForUserWhen, operations::ReposListForUserThen);
    fn billing_get_github_actions_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubActionsBillingUserWhen,
            operations::BillingGetGithubActionsBillingUserThen,
        );
    fn billing_get_github_packages_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubPackagesBillingUserWhen,
            operations::BillingGetGithubPackagesBillingUserThen,
        );
    fn billing_get_shared_storage_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetSharedStorageBillingUserWhen,
            operations::BillingGetSharedStorageBillingUserThen,
        );
    fn users_list_social_accounts_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSocialAccountsForUserWhen,
            operations::UsersListSocialAccountsForUserThen,
        );
}

impl MockServerExt for httpmock::MockServer {
    fn meta_root<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaRootWhen, operations::MetaRootThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MetaRootWhen::new(when),
                operations::MetaRootThen::new(then),
            )
        })
    }

    fn apps_get_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetAuthenticatedWhen, operations::AppsGetAuthenticatedThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetAuthenticatedWhen::new(when),
                operations::AppsGetAuthenticatedThen::new(then),
            )
        })
    }

    fn apps_create_from_manifest<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsCreateFromManifestWhen, operations::AppsCreateFromManifestThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsCreateFromManifestWhen::new(when),
                operations::AppsCreateFromManifestThen::new(then),
            )
        })
    }

    fn apps_get_webhook_config_for_app<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetWebhookConfigForAppWhen,
            operations::AppsGetWebhookConfigForAppThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetWebhookConfigForAppWhen::new(when),
                operations::AppsGetWebhookConfigForAppThen::new(then),
            )
        })
    }

    fn apps_update_webhook_config_for_app<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsUpdateWebhookConfigForAppWhen,
            operations::AppsUpdateWebhookConfigForAppThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsUpdateWebhookConfigForAppWhen::new(when),
                operations::AppsUpdateWebhookConfigForAppThen::new(then),
            )
        })
    }

    fn apps_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListWebhookDeliveriesWhen,
            operations::AppsListWebhookDeliveriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListWebhookDeliveriesWhen::new(when),
                operations::AppsListWebhookDeliveriesThen::new(then),
            )
        })
    }

    fn apps_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetWebhookDeliveryWhen, operations::AppsGetWebhookDeliveryThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetWebhookDeliveryWhen::new(when),
                operations::AppsGetWebhookDeliveryThen::new(then),
            )
        })
    }

    fn apps_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRedeliverWebhookDeliveryWhen,
            operations::AppsRedeliverWebhookDeliveryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsRedeliverWebhookDeliveryWhen::new(when),
                operations::AppsRedeliverWebhookDeliveryThen::new(then),
            )
        })
    }

    fn apps_list_installation_requests_for_authenticated_app<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationRequestsForAuthenticatedAppWhen,
            operations::AppsListInstallationRequestsForAuthenticatedAppThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListInstallationRequestsForAuthenticatedAppWhen::new(when),
                operations::AppsListInstallationRequestsForAuthenticatedAppThen::new(then),
            )
        })
    }

    fn apps_list_installations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListInstallationsWhen, operations::AppsListInstallationsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListInstallationsWhen::new(when),
                operations::AppsListInstallationsThen::new(then),
            )
        })
    }

    fn apps_get_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetInstallationWhen, operations::AppsGetInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetInstallationWhen::new(when),
                operations::AppsGetInstallationThen::new(then),
            )
        })
    }

    fn apps_delete_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteInstallationWhen, operations::AppsDeleteInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsDeleteInstallationWhen::new(when),
                operations::AppsDeleteInstallationThen::new(then),
            )
        })
    }

    fn apps_create_installation_access_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsCreateInstallationAccessTokenWhen,
            operations::AppsCreateInstallationAccessTokenThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsCreateInstallationAccessTokenWhen::new(when),
                operations::AppsCreateInstallationAccessTokenThen::new(then),
            )
        })
    }

    fn apps_suspend_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsSuspendInstallationWhen, operations::AppsSuspendInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsSuspendInstallationWhen::new(when),
                operations::AppsSuspendInstallationThen::new(then),
            )
        })
    }

    fn apps_unsuspend_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsUnsuspendInstallationWhen,
            operations::AppsUnsuspendInstallationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsUnsuspendInstallationWhen::new(when),
                operations::AppsUnsuspendInstallationThen::new(then),
            )
        })
    }

    fn apps_delete_authorization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteAuthorizationWhen, operations::AppsDeleteAuthorizationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsDeleteAuthorizationWhen::new(when),
                operations::AppsDeleteAuthorizationThen::new(then),
            )
        })
    }

    fn apps_check_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsCheckTokenWhen, operations::AppsCheckTokenThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsCheckTokenWhen::new(when),
                operations::AppsCheckTokenThen::new(then),
            )
        })
    }

    fn apps_delete_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsDeleteTokenWhen, operations::AppsDeleteTokenThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsDeleteTokenWhen::new(when),
                operations::AppsDeleteTokenThen::new(then),
            )
        })
    }

    fn apps_reset_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsResetTokenWhen, operations::AppsResetTokenThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsResetTokenWhen::new(when),
                operations::AppsResetTokenThen::new(then),
            )
        })
    }

    fn apps_scope_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsScopeTokenWhen, operations::AppsScopeTokenThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsScopeTokenWhen::new(when),
                operations::AppsScopeTokenThen::new(then),
            )
        })
    }

    fn apps_get_by_slug<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetBySlugWhen, operations::AppsGetBySlugThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetBySlugWhen::new(when),
                operations::AppsGetBySlugThen::new(then),
            )
        })
    }

    fn codes_of_conduct_get_all_codes_of_conduct<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodesOfConductGetAllCodesOfConductWhen,
            operations::CodesOfConductGetAllCodesOfConductThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodesOfConductGetAllCodesOfConductWhen::new(when),
                operations::CodesOfConductGetAllCodesOfConductThen::new(then),
            )
        })
    }

    fn codes_of_conduct_get_conduct_code<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodesOfConductGetConductCodeWhen,
            operations::CodesOfConductGetConductCodeThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodesOfConductGetConductCodeWhen::new(when),
                operations::CodesOfConductGetConductCodeThen::new(then),
            )
        })
    }

    fn emojis_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::EmojisGetWhen, operations::EmojisGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::EmojisGetWhen::new(when),
                operations::EmojisGetThen::new(then),
            )
        })
    }

    fn dependabot_list_alerts_for_enterprise<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForEnterpriseWhen,
            operations::DependabotListAlertsForEnterpriseThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListAlertsForEnterpriseWhen::new(when),
                operations::DependabotListAlertsForEnterpriseThen::new(then),
            )
        })
    }

    fn secret_scanning_list_alerts_for_enterprise<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForEnterpriseWhen,
            operations::SecretScanningListAlertsForEnterpriseThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningListAlertsForEnterpriseWhen::new(when),
                operations::SecretScanningListAlertsForEnterpriseThen::new(then),
            )
        })
    }

    fn activity_list_public_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsWhen,
            operations::ActivityListPublicEventsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListPublicEventsWhen::new(when),
                operations::ActivityListPublicEventsThen::new(then),
            )
        })
    }

    fn activity_get_feeds<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityGetFeedsWhen, operations::ActivityGetFeedsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityGetFeedsWhen::new(when),
                operations::ActivityGetFeedsThen::new(then),
            )
        })
    }

    fn gists_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListWhen, operations::GistsListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListWhen::new(when),
                operations::GistsListThen::new(then),
            )
        })
    }

    fn gists_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCreateWhen, operations::GistsCreateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsCreateWhen::new(when),
                operations::GistsCreateThen::new(then),
            )
        })
    }

    fn gists_list_public<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListPublicWhen, operations::GistsListPublicThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListPublicWhen::new(when),
                operations::GistsListPublicThen::new(then),
            )
        })
    }

    fn gists_list_starred<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListStarredWhen, operations::GistsListStarredThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListStarredWhen::new(when),
                operations::GistsListStarredThen::new(then),
            )
        })
    }

    fn gists_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetWhen, operations::GistsGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsGetWhen::new(when),
                operations::GistsGetThen::new(then),
            )
        })
    }

    fn gists_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsDeleteWhen, operations::GistsDeleteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsDeleteWhen::new(when),
                operations::GistsDeleteThen::new(then),
            )
        })
    }

    fn gists_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUpdateWhen, operations::GistsUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsUpdateWhen::new(when),
                operations::GistsUpdateThen::new(then),
            )
        })
    }

    fn gists_list_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListCommentsWhen, operations::GistsListCommentsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListCommentsWhen::new(when),
                operations::GistsListCommentsThen::new(then),
            )
        })
    }

    fn gists_create_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCreateCommentWhen, operations::GistsCreateCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsCreateCommentWhen::new(when),
                operations::GistsCreateCommentThen::new(then),
            )
        })
    }

    fn gists_get_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetCommentWhen, operations::GistsGetCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsGetCommentWhen::new(when),
                operations::GistsGetCommentThen::new(then),
            )
        })
    }

    fn gists_delete_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsDeleteCommentWhen, operations::GistsDeleteCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsDeleteCommentWhen::new(when),
                operations::GistsDeleteCommentThen::new(then),
            )
        })
    }

    fn gists_update_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUpdateCommentWhen, operations::GistsUpdateCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsUpdateCommentWhen::new(when),
                operations::GistsUpdateCommentThen::new(then),
            )
        })
    }

    fn gists_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListCommitsWhen, operations::GistsListCommitsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListCommitsWhen::new(when),
                operations::GistsListCommitsThen::new(then),
            )
        })
    }

    fn gists_list_forks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListForksWhen, operations::GistsListForksThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListForksWhen::new(when),
                operations::GistsListForksThen::new(then),
            )
        })
    }

    fn gists_fork<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsForkWhen, operations::GistsForkThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsForkWhen::new(when),
                operations::GistsForkThen::new(then),
            )
        })
    }

    fn gists_check_is_starred<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsCheckIsStarredWhen, operations::GistsCheckIsStarredThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsCheckIsStarredWhen::new(when),
                operations::GistsCheckIsStarredThen::new(then),
            )
        })
    }

    fn gists_star<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsStarWhen, operations::GistsStarThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsStarWhen::new(when),
                operations::GistsStarThen::new(then),
            )
        })
    }

    fn gists_unstar<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsUnstarWhen, operations::GistsUnstarThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsUnstarWhen::new(when),
                operations::GistsUnstarThen::new(then),
            )
        })
    }

    fn gists_get_revision<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsGetRevisionWhen, operations::GistsGetRevisionThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsGetRevisionWhen::new(when),
                operations::GistsGetRevisionThen::new(then),
            )
        })
    }

    fn gitignore_get_all_templates<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::GitignoreGetAllTemplatesWhen,
            operations::GitignoreGetAllTemplatesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitignoreGetAllTemplatesWhen::new(when),
                operations::GitignoreGetAllTemplatesThen::new(then),
            )
        })
    }

    fn gitignore_get_template<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitignoreGetTemplateWhen, operations::GitignoreGetTemplateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitignoreGetTemplateWhen::new(when),
                operations::GitignoreGetTemplateThen::new(then),
            )
        })
    }

    fn apps_list_repos_accessible_to_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListReposAccessibleToInstallationWhen,
            operations::AppsListReposAccessibleToInstallationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListReposAccessibleToInstallationWhen::new(when),
                operations::AppsListReposAccessibleToInstallationThen::new(then),
            )
        })
    }

    fn apps_revoke_installation_access_token<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRevokeInstallationAccessTokenWhen,
            operations::AppsRevokeInstallationAccessTokenThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsRevokeInstallationAccessTokenWhen::new(when),
                operations::AppsRevokeInstallationAccessTokenThen::new(then),
            )
        })
    }

    fn issues_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListWhen, operations::IssuesListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListWhen::new(when),
                operations::IssuesListThen::new(then),
            )
        })
    }

    fn licenses_get_all_commonly_used<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::LicensesGetAllCommonlyUsedWhen,
            operations::LicensesGetAllCommonlyUsedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::LicensesGetAllCommonlyUsedWhen::new(when),
                operations::LicensesGetAllCommonlyUsedThen::new(then),
            )
        })
    }

    fn licenses_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::LicensesGetWhen, operations::LicensesGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::LicensesGetWhen::new(when),
                operations::LicensesGetThen::new(then),
            )
        })
    }

    fn markdown_render<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MarkdownRenderWhen, operations::MarkdownRenderThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MarkdownRenderWhen::new(when),
                operations::MarkdownRenderThen::new(then),
            )
        })
    }

    fn meta_get_all_versions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetAllVersionsWhen, operations::MetaGetAllVersionsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MetaGetAllVersionsWhen::new(when),
                operations::MetaGetAllVersionsThen::new(then),
            )
        })
    }

    fn apps_get_subscription_plan_for_account<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetSubscriptionPlanForAccountWhen,
            operations::AppsGetSubscriptionPlanForAccountThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetSubscriptionPlanForAccountWhen::new(when),
                operations::AppsGetSubscriptionPlanForAccountThen::new(then),
            )
        })
    }

    fn apps_list_plans<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListPlansWhen, operations::AppsListPlansThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListPlansWhen::new(when),
                operations::AppsListPlansThen::new(then),
            )
        })
    }

    fn apps_list_accounts_for_plan<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListAccountsForPlanWhen, operations::AppsListAccountsForPlanThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListAccountsForPlanWhen::new(when),
                operations::AppsListAccountsForPlanThen::new(then),
            )
        })
    }

    fn apps_get_subscription_plan_for_account_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsGetSubscriptionPlanForAccountStubbedWhen,
            operations::AppsGetSubscriptionPlanForAccountStubbedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetSubscriptionPlanForAccountStubbedWhen::new(when),
                operations::AppsGetSubscriptionPlanForAccountStubbedThen::new(then),
            )
        })
    }

    fn apps_list_plans_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsListPlansStubbedWhen, operations::AppsListPlansStubbedThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListPlansStubbedWhen::new(when),
                operations::AppsListPlansStubbedThen::new(then),
            )
        })
    }

    fn apps_list_accounts_for_plan_stubbed<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListAccountsForPlanStubbedWhen,
            operations::AppsListAccountsForPlanStubbedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListAccountsForPlanStubbedWhen::new(when),
                operations::AppsListAccountsForPlanStubbedThen::new(then),
            )
        })
    }

    fn meta_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetWhen, operations::MetaGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MetaGetWhen::new(when),
                operations::MetaGetThen::new(then),
            )
        })
    }

    fn activity_list_public_events_for_repo_network<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsForRepoNetworkWhen,
            operations::ActivityListPublicEventsForRepoNetworkThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListPublicEventsForRepoNetworkWhen::new(when),
                operations::ActivityListPublicEventsForRepoNetworkThen::new(then),
            )
        })
    }

    fn activity_list_notifications_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListNotificationsForAuthenticatedUserWhen,
            operations::ActivityListNotificationsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListNotificationsForAuthenticatedUserWhen::new(when),
                operations::ActivityListNotificationsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_mark_notifications_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkNotificationsAsReadWhen,
            operations::ActivityMarkNotificationsAsReadThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityMarkNotificationsAsReadWhen::new(when),
                operations::ActivityMarkNotificationsAsReadThen::new(then),
            )
        })
    }

    fn activity_get_thread<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityGetThreadWhen, operations::ActivityGetThreadThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityGetThreadWhen::new(when),
                operations::ActivityGetThreadThen::new(then),
            )
        })
    }

    fn activity_mark_thread_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkThreadAsReadWhen,
            operations::ActivityMarkThreadAsReadThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityMarkThreadAsReadWhen::new(when),
                operations::ActivityMarkThreadAsReadThen::new(then),
            )
        })
    }

    fn activity_get_thread_subscription_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityGetThreadSubscriptionForAuthenticatedUserWhen,
            operations::ActivityGetThreadSubscriptionForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityGetThreadSubscriptionForAuthenticatedUserWhen::new(when),
                operations::ActivityGetThreadSubscriptionForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_set_thread_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivitySetThreadSubscriptionWhen,
            operations::ActivitySetThreadSubscriptionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivitySetThreadSubscriptionWhen::new(when),
                operations::ActivitySetThreadSubscriptionThen::new(then),
            )
        })
    }

    fn activity_delete_thread_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityDeleteThreadSubscriptionWhen,
            operations::ActivityDeleteThreadSubscriptionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityDeleteThreadSubscriptionWhen::new(when),
                operations::ActivityDeleteThreadSubscriptionThen::new(then),
            )
        })
    }

    fn meta_get_octocat<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetOctocatWhen, operations::MetaGetOctocatThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MetaGetOctocatWhen::new(when),
                operations::MetaGetOctocatThen::new(then),
            )
        })
    }

    fn orgs_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListWhen, operations::OrgsListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListWhen::new(when),
                operations::OrgsListThen::new(then),
            )
        })
    }

    fn orgs_list_pat_grant_requests<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRequestsWhen,
            operations::OrgsListPatGrantRequestsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPatGrantRequestsWhen::new(when),
                operations::OrgsListPatGrantRequestsThen::new(then),
            )
        })
    }

    fn orgs_review_pat_grant_requests_in_bulk<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsReviewPatGrantRequestsInBulkWhen,
            operations::OrgsReviewPatGrantRequestsInBulkThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsReviewPatGrantRequestsInBulkWhen::new(when),
                operations::OrgsReviewPatGrantRequestsInBulkThen::new(then),
            )
        })
    }

    fn orgs_review_pat_grant_request<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsReviewPatGrantRequestWhen,
            operations::OrgsReviewPatGrantRequestThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsReviewPatGrantRequestWhen::new(when),
                operations::OrgsReviewPatGrantRequestThen::new(then),
            )
        })
    }

    fn orgs_list_pat_grant_request_repositories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRequestRepositoriesWhen,
            operations::OrgsListPatGrantRequestRepositoriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPatGrantRequestRepositoriesWhen::new(when),
                operations::OrgsListPatGrantRequestRepositoriesThen::new(then),
            )
        })
    }

    fn orgs_list_pat_grants<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListPatGrantsWhen, operations::OrgsListPatGrantsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPatGrantsWhen::new(when),
                operations::OrgsListPatGrantsThen::new(then),
            )
        })
    }

    fn orgs_update_pat_accesses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdatePatAccessesWhen, operations::OrgsUpdatePatAccessesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUpdatePatAccessesWhen::new(when),
                operations::OrgsUpdatePatAccessesThen::new(then),
            )
        })
    }

    fn orgs_update_pat_access<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdatePatAccessWhen, operations::OrgsUpdatePatAccessThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUpdatePatAccessWhen::new(when),
                operations::OrgsUpdatePatAccessThen::new(then),
            )
        })
    }

    fn orgs_list_pat_grant_repositories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPatGrantRepositoriesWhen,
            operations::OrgsListPatGrantRepositoriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPatGrantRepositoriesWhen::new(when),
                operations::OrgsListPatGrantRepositoriesThen::new(then),
            )
        })
    }

    fn meta_get_zen<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MetaGetZenWhen, operations::MetaGetZenThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MetaGetZenWhen::new(when),
                operations::MetaGetZenThen::new(then),
            )
        })
    }

    fn actions_get_actions_cache_usage_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageForOrgWhen,
            operations::ActionsGetActionsCacheUsageForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetActionsCacheUsageForOrgWhen::new(when),
                operations::ActionsGetActionsCacheUsageForOrgThen::new(then),
            )
        })
    }

    fn actions_get_actions_cache_usage_by_repo_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageByRepoForOrgWhen,
            operations::ActionsGetActionsCacheUsageByRepoForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetActionsCacheUsageByRepoForOrgWhen::new(when),
                operations::ActionsGetActionsCacheUsageByRepoForOrgThen::new(then),
            )
        })
    }

    fn oidc_get_oidc_custom_sub_template_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OidcGetOidcCustomSubTemplateForOrgWhen,
            operations::OidcGetOidcCustomSubTemplateForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OidcGetOidcCustomSubTemplateForOrgWhen::new(when),
                operations::OidcGetOidcCustomSubTemplateForOrgThen::new(then),
            )
        })
    }

    fn oidc_update_oidc_custom_sub_template_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OidcUpdateOidcCustomSubTemplateForOrgWhen,
            operations::OidcUpdateOidcCustomSubTemplateForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OidcUpdateOidcCustomSubTemplateForOrgWhen::new(when),
                operations::OidcUpdateOidcCustomSubTemplateForOrgThen::new(then),
            )
        })
    }

    fn actions_get_github_actions_permissions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsPermissionsOrganizationWhen,
            operations::ActionsGetGithubActionsPermissionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetGithubActionsPermissionsOrganizationWhen::new(when),
                operations::ActionsGetGithubActionsPermissionsOrganizationThen::new(then),
            )
        })
    }

    fn actions_set_github_actions_permissions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsPermissionsOrganizationWhen,
            operations::ActionsSetGithubActionsPermissionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetGithubActionsPermissionsOrganizationWhen::new(when),
                operations::ActionsSetGithubActionsPermissionsOrganizationThen::new(then),
            )
        })
    }

    fn actions_list_selected_repositories_enabled_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationWhen,
            operations::ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationThen,
        ),
    {
        self . mock (| when , then | { config_fn (operations :: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationWhen :: new (when) , operations :: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationThen :: new (then) ,) })
    }

    fn actions_set_selected_repositories_enabled_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWhen,
            operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationWhen::new(
                    when,
                ),
                operations::ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_enable_selected_repository_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationWhen,
            operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationWhen::new(when),
                operations::ActionsEnableSelectedRepositoryGithubActionsOrganizationThen::new(then),
            )
        })
    }

    fn actions_disable_selected_repository_github_actions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationWhen,
            operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationWhen::new(
                    when,
                ),
                operations::ActionsDisableSelectedRepositoryGithubActionsOrganizationThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_get_allowed_actions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetAllowedActionsOrganizationWhen,
            operations::ActionsGetAllowedActionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetAllowedActionsOrganizationWhen::new(when),
                operations::ActionsGetAllowedActionsOrganizationThen::new(then),
            )
        })
    }

    fn actions_set_allowed_actions_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetAllowedActionsOrganizationWhen,
            operations::ActionsSetAllowedActionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetAllowedActionsOrganizationWhen::new(when),
                operations::ActionsSetAllowedActionsOrganizationThen::new(then),
            )
        })
    }

    fn actions_get_github_actions_default_workflow_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWhen,
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationWhen::new(
                    when,
                ),
                operations::ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_set_github_actions_default_workflow_permissions_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWhen,
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationWhen::new(
                    when,
                ),
                operations::ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_list_required_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRequiredWorkflowsWhen,
            operations::ActionsListRequiredWorkflowsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRequiredWorkflowsWhen::new(when),
                operations::ActionsListRequiredWorkflowsThen::new(then),
            )
        })
    }

    fn actions_create_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRequiredWorkflowWhen,
            operations::ActionsCreateRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRequiredWorkflowWhen::new(when),
                operations::ActionsCreateRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_get_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRequiredWorkflowWhen,
            operations::ActionsGetRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRequiredWorkflowWhen::new(when),
                operations::ActionsGetRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_delete_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteRequiredWorkflowWhen,
            operations::ActionsDeleteRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteRequiredWorkflowWhen::new(when),
                operations::ActionsDeleteRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_update_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateRequiredWorkflowWhen,
            operations::ActionsUpdateRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsUpdateRequiredWorkflowWhen::new(when),
                operations::ActionsUpdateRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_list_selected_repositories_required_workflow<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedRepositoriesRequiredWorkflowWhen,
            operations::ActionsListSelectedRepositoriesRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListSelectedRepositoriesRequiredWorkflowWhen::new(when),
                operations::ActionsListSelectedRepositoriesRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_set_selected_repos_to_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposToRequiredWorkflowWhen,
            operations::ActionsSetSelectedReposToRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetSelectedReposToRequiredWorkflowWhen::new(when),
                operations::ActionsSetSelectedReposToRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_add_selected_repo_to_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToRequiredWorkflowWhen,
            operations::ActionsAddSelectedRepoToRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsAddSelectedRepoToRequiredWorkflowWhen::new(when),
                operations::ActionsAddSelectedRepoToRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_remove_selected_repo_from_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromRequiredWorkflowWhen,
            operations::ActionsRemoveSelectedRepoFromRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveSelectedRepoFromRequiredWorkflowWhen::new(when),
                operations::ActionsRemoveSelectedRepoFromRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_list_self_hosted_runners_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelfHostedRunnersForOrgWhen,
            operations::ActionsListSelfHostedRunnersForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListSelfHostedRunnersForOrgWhen::new(when),
                operations::ActionsListSelfHostedRunnersForOrgThen::new(then),
            )
        })
    }

    fn actions_list_runner_applications_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRunnerApplicationsForOrgWhen,
            operations::ActionsListRunnerApplicationsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRunnerApplicationsForOrgWhen::new(when),
                operations::ActionsListRunnerApplicationsForOrgThen::new(then),
            )
        })
    }

    fn actions_create_registration_token_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRegistrationTokenForOrgWhen,
            operations::ActionsCreateRegistrationTokenForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRegistrationTokenForOrgWhen::new(when),
                operations::ActionsCreateRegistrationTokenForOrgThen::new(then),
            )
        })
    }

    fn actions_create_remove_token_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRemoveTokenForOrgWhen,
            operations::ActionsCreateRemoveTokenForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRemoveTokenForOrgWhen::new(when),
                operations::ActionsCreateRemoveTokenForOrgThen::new(then),
            )
        })
    }

    fn actions_get_self_hosted_runner_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetSelfHostedRunnerForOrgWhen,
            operations::ActionsGetSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsGetSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_delete_self_hosted_runner_from_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteSelfHostedRunnerFromOrgWhen,
            operations::ActionsDeleteSelfHostedRunnerFromOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteSelfHostedRunnerFromOrgWhen::new(when),
                operations::ActionsDeleteSelfHostedRunnerFromOrgThen::new(then),
            )
        })
    }

    fn actions_list_labels_for_self_hosted_runner_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListLabelsForSelfHostedRunnerForOrgWhen,
            operations::ActionsListLabelsForSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListLabelsForSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsListLabelsForSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_set_custom_labels_for_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgWhen,
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsSetCustomLabelsForSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_add_custom_labels_to_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgWhen,
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsAddCustomLabelsToSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_remove_all_custom_labels_from_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWhen,
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_remove_custom_label_from_self_hosted_runner_for_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgWhen,
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgWhen::new(when),
                operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgThen::new(then),
            )
        })
    }

    fn actions_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListOrgSecretsWhen, operations::ActionsListOrgSecretsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListOrgSecretsWhen::new(when),
                operations::ActionsListOrgSecretsThen::new(then),
            )
        })
    }

    fn actions_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgPublicKeyWhen, operations::ActionsGetOrgPublicKeyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetOrgPublicKeyWhen::new(when),
                operations::ActionsGetOrgPublicKeyThen::new(then),
            )
        })
    }

    fn actions_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgSecretWhen, operations::ActionsGetOrgSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetOrgSecretWhen::new(when),
                operations::ActionsGetOrgSecretThen::new(then),
            )
        })
    }

    fn actions_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateOrgSecretWhen,
            operations::ActionsCreateOrUpdateOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateOrUpdateOrgSecretWhen::new(when),
                operations::ActionsCreateOrUpdateOrgSecretThen::new(then),
            )
        })
    }

    fn actions_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteOrgSecretWhen, operations::ActionsDeleteOrgSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteOrgSecretWhen::new(when),
                operations::ActionsDeleteOrgSecretThen::new(then),
            )
        })
    }

    fn actions_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedReposForOrgSecretWhen,
            operations::ActionsListSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListSelectedReposForOrgSecretWhen::new(when),
                operations::ActionsListSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn actions_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposForOrgSecretWhen,
            operations::ActionsSetSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetSelectedReposForOrgSecretWhen::new(when),
                operations::ActionsSetSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn actions_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToOrgSecretWhen,
            operations::ActionsAddSelectedRepoToOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsAddSelectedRepoToOrgSecretWhen::new(when),
                operations::ActionsAddSelectedRepoToOrgSecretThen::new(then),
            )
        })
    }

    fn actions_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromOrgSecretWhen,
            operations::ActionsRemoveSelectedRepoFromOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveSelectedRepoFromOrgSecretWhen::new(when),
                operations::ActionsRemoveSelectedRepoFromOrgSecretThen::new(then),
            )
        })
    }

    fn actions_list_org_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListOrgVariablesWhen, operations::ActionsListOrgVariablesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListOrgVariablesWhen::new(when),
                operations::ActionsListOrgVariablesThen::new(then),
            )
        })
    }

    fn actions_create_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrgVariableWhen,
            operations::ActionsCreateOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateOrgVariableWhen::new(when),
                operations::ActionsCreateOrgVariableThen::new(then),
            )
        })
    }

    fn actions_get_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetOrgVariableWhen, operations::ActionsGetOrgVariableThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetOrgVariableWhen::new(when),
                operations::ActionsGetOrgVariableThen::new(then),
            )
        })
    }

    fn actions_delete_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteOrgVariableWhen,
            operations::ActionsDeleteOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteOrgVariableWhen::new(when),
                operations::ActionsDeleteOrgVariableThen::new(then),
            )
        })
    }

    fn actions_update_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateOrgVariableWhen,
            operations::ActionsUpdateOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsUpdateOrgVariableWhen::new(when),
                operations::ActionsUpdateOrgVariableThen::new(then),
            )
        })
    }

    fn actions_list_selected_repos_for_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelectedReposForOrgVariableWhen,
            operations::ActionsListSelectedReposForOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListSelectedReposForOrgVariableWhen::new(when),
                operations::ActionsListSelectedReposForOrgVariableThen::new(then),
            )
        })
    }

    fn actions_set_selected_repos_for_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetSelectedReposForOrgVariableWhen,
            operations::ActionsSetSelectedReposForOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetSelectedReposForOrgVariableWhen::new(when),
                operations::ActionsSetSelectedReposForOrgVariableThen::new(then),
            )
        })
    }

    fn actions_add_selected_repo_to_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddSelectedRepoToOrgVariableWhen,
            operations::ActionsAddSelectedRepoToOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsAddSelectedRepoToOrgVariableWhen::new(when),
                operations::ActionsAddSelectedRepoToOrgVariableThen::new(then),
            )
        })
    }

    fn actions_remove_selected_repo_from_org_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveSelectedRepoFromOrgVariableWhen,
            operations::ActionsRemoveSelectedRepoFromOrgVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveSelectedRepoFromOrgVariableWhen::new(when),
                operations::ActionsRemoveSelectedRepoFromOrgVariableThen::new(then),
            )
        })
    }

    fn orgs_list_blocked_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListBlockedUsersWhen, operations::OrgsListBlockedUsersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListBlockedUsersWhen::new(when),
                operations::OrgsListBlockedUsersThen::new(then),
            )
        })
    }

    fn orgs_check_blocked_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCheckBlockedUserWhen, operations::OrgsCheckBlockedUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCheckBlockedUserWhen::new(when),
                operations::OrgsCheckBlockedUserThen::new(then),
            )
        })
    }

    fn orgs_block_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsBlockUserWhen, operations::OrgsBlockUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsBlockUserWhen::new(when),
                operations::OrgsBlockUserThen::new(then),
            )
        })
    }

    fn orgs_unblock_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUnblockUserWhen, operations::OrgsUnblockUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUnblockUserWhen::new(when),
                operations::OrgsUnblockUserThen::new(then),
            )
        })
    }

    fn code_scanning_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertsForOrgWhen,
            operations::CodeScanningListAlertsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningListAlertsForOrgWhen::new(when),
                operations::CodeScanningListAlertsForOrgThen::new(then),
            )
        })
    }

    fn codespaces_list_in_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListInOrganizationWhen,
            operations::CodespacesListInOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListInOrganizationWhen::new(when),
                operations::CodespacesListInOrganizationThen::new(then),
            )
        })
    }

    fn codespaces_set_codespaces_billing<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetCodespacesBillingWhen,
            operations::CodespacesSetCodespacesBillingThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesSetCodespacesBillingWhen::new(when),
                operations::CodespacesSetCodespacesBillingThen::new(then),
            )
        })
    }

    fn codespaces_set_codespaces_billing_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetCodespacesBillingUsersWhen,
            operations::CodespacesSetCodespacesBillingUsersThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesSetCodespacesBillingUsersWhen::new(when),
                operations::CodespacesSetCodespacesBillingUsersThen::new(then),
            )
        })
    }

    fn codespaces_delete_codespaces_billing_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteCodespacesBillingUsersWhen,
            operations::CodespacesDeleteCodespacesBillingUsersThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteCodespacesBillingUsersWhen::new(when),
                operations::CodespacesDeleteCodespacesBillingUsersThen::new(then),
            )
        })
    }

    fn codespaces_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListOrgSecretsWhen,
            operations::CodespacesListOrgSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListOrgSecretsWhen::new(when),
                operations::CodespacesListOrgSecretsThen::new(then),
            )
        })
    }

    fn codespaces_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetOrgPublicKeyWhen,
            operations::CodespacesGetOrgPublicKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetOrgPublicKeyWhen::new(when),
                operations::CodespacesGetOrgPublicKeyThen::new(then),
            )
        })
    }

    fn codespaces_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodespacesGetOrgSecretWhen, operations::CodespacesGetOrgSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetOrgSecretWhen::new(when),
                operations::CodespacesGetOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateOrgSecretWhen,
            operations::CodespacesCreateOrUpdateOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateOrUpdateOrgSecretWhen::new(when),
                operations::CodespacesCreateOrUpdateOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteOrgSecretWhen,
            operations::CodespacesDeleteOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteOrgSecretWhen::new(when),
                operations::CodespacesDeleteOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListSelectedReposForOrgSecretWhen,
            operations::CodespacesListSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListSelectedReposForOrgSecretWhen::new(when),
                operations::CodespacesListSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetSelectedReposForOrgSecretWhen,
            operations::CodespacesSetSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesSetSelectedReposForOrgSecretWhen::new(when),
                operations::CodespacesSetSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesAddSelectedRepoToOrgSecretWhen,
            operations::CodespacesAddSelectedRepoToOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesAddSelectedRepoToOrgSecretWhen::new(when),
                operations::CodespacesAddSelectedRepoToOrgSecretThen::new(then),
            )
        })
    }

    fn codespaces_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRemoveSelectedRepoFromOrgSecretWhen,
            operations::CodespacesRemoveSelectedRepoFromOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesRemoveSelectedRepoFromOrgSecretWhen::new(when),
                operations::CodespacesRemoveSelectedRepoFromOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForOrgWhen,
            operations::DependabotListAlertsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListAlertsForOrgWhen::new(when),
                operations::DependabotListAlertsForOrgThen::new(then),
            )
        })
    }

    fn dependabot_list_org_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListOrgSecretsWhen,
            operations::DependabotListOrgSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListOrgSecretsWhen::new(when),
                operations::DependabotListOrgSecretsThen::new(then),
            )
        })
    }

    fn dependabot_get_org_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotGetOrgPublicKeyWhen,
            operations::DependabotGetOrgPublicKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotGetOrgPublicKeyWhen::new(when),
                operations::DependabotGetOrgPublicKeyThen::new(then),
            )
        })
    }

    fn dependabot_get_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetOrgSecretWhen, operations::DependabotGetOrgSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotGetOrgSecretWhen::new(when),
                operations::DependabotGetOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_create_or_update_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotCreateOrUpdateOrgSecretWhen,
            operations::DependabotCreateOrUpdateOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotCreateOrUpdateOrgSecretWhen::new(when),
                operations::DependabotCreateOrUpdateOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_delete_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotDeleteOrgSecretWhen,
            operations::DependabotDeleteOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotDeleteOrgSecretWhen::new(when),
                operations::DependabotDeleteOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_list_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListSelectedReposForOrgSecretWhen,
            operations::DependabotListSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListSelectedReposForOrgSecretWhen::new(when),
                operations::DependabotListSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_set_selected_repos_for_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotSetSelectedReposForOrgSecretWhen,
            operations::DependabotSetSelectedReposForOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotSetSelectedReposForOrgSecretWhen::new(when),
                operations::DependabotSetSelectedReposForOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_add_selected_repo_to_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotAddSelectedRepoToOrgSecretWhen,
            operations::DependabotAddSelectedRepoToOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotAddSelectedRepoToOrgSecretWhen::new(when),
                operations::DependabotAddSelectedRepoToOrgSecretThen::new(then),
            )
        })
    }

    fn dependabot_remove_selected_repo_from_org_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotRemoveSelectedRepoFromOrgSecretWhen,
            operations::DependabotRemoveSelectedRepoFromOrgSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotRemoveSelectedRepoFromOrgSecretWhen::new(when),
                operations::DependabotRemoveSelectedRepoFromOrgSecretThen::new(then),
            )
        })
    }

    fn packages_list_docker_migration_conflicting_packages_for_organization<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForOrganizationWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesListDockerMigrationConflictingPackagesForOrganizationWhen::new(
                    when,
                ),
                operations::PackagesListDockerMigrationConflictingPackagesForOrganizationThen::new(
                    then,
                ),
            )
        })
    }

    fn activity_list_public_org_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicOrgEventsWhen,
            operations::ActivityListPublicOrgEventsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListPublicOrgEventsWhen::new(when),
                operations::ActivityListPublicOrgEventsThen::new(then),
            )
        })
    }

    fn orgs_list_failed_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListFailedInvitationsWhen,
            operations::OrgsListFailedInvitationsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListFailedInvitationsWhen::new(when),
                operations::OrgsListFailedInvitationsThen::new(then),
            )
        })
    }

    fn orgs_list_webhooks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListWebhooksWhen, operations::OrgsListWebhooksThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListWebhooksWhen::new(when),
                operations::OrgsListWebhooksThen::new(then),
            )
        })
    }

    fn orgs_create_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCreateWebhookWhen, operations::OrgsCreateWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCreateWebhookWhen::new(when),
                operations::OrgsCreateWebhookThen::new(then),
            )
        })
    }

    fn orgs_get_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsGetWebhookWhen, operations::OrgsGetWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsGetWebhookWhen::new(when),
                operations::OrgsGetWebhookThen::new(then),
            )
        })
    }

    fn orgs_delete_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsDeleteWebhookWhen, operations::OrgsDeleteWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsDeleteWebhookWhen::new(when),
                operations::OrgsDeleteWebhookThen::new(then),
            )
        })
    }

    fn orgs_update_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsUpdateWebhookWhen, operations::OrgsUpdateWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUpdateWebhookWhen::new(when),
                operations::OrgsUpdateWebhookThen::new(then),
            )
        })
    }

    fn orgs_get_webhook_config_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetWebhookConfigForOrgWhen,
            operations::OrgsGetWebhookConfigForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsGetWebhookConfigForOrgWhen::new(when),
                operations::OrgsGetWebhookConfigForOrgThen::new(then),
            )
        })
    }

    fn orgs_update_webhook_config_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsUpdateWebhookConfigForOrgWhen,
            operations::OrgsUpdateWebhookConfigForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUpdateWebhookConfigForOrgWhen::new(when),
                operations::OrgsUpdateWebhookConfigForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListWebhookDeliveriesWhen,
            operations::OrgsListWebhookDeliveriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListWebhookDeliveriesWhen::new(when),
                operations::OrgsListWebhookDeliveriesThen::new(then),
            )
        })
    }

    fn orgs_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsGetWebhookDeliveryWhen, operations::OrgsGetWebhookDeliveryThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsGetWebhookDeliveryWhen::new(when),
                operations::OrgsGetWebhookDeliveryThen::new(then),
            )
        })
    }

    fn orgs_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRedeliverWebhookDeliveryWhen,
            operations::OrgsRedeliverWebhookDeliveryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRedeliverWebhookDeliveryWhen::new(when),
                operations::OrgsRedeliverWebhookDeliveryThen::new(then),
            )
        })
    }

    fn orgs_ping_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsPingWebhookWhen, operations::OrgsPingWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsPingWebhookWhen::new(when),
                operations::OrgsPingWebhookThen::new(then),
            )
        })
    }

    fn apps_get_org_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetOrgInstallationWhen, operations::AppsGetOrgInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetOrgInstallationWhen::new(when),
                operations::AppsGetOrgInstallationThen::new(then),
            )
        })
    }

    fn orgs_list_app_installations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListAppInstallationsWhen,
            operations::OrgsListAppInstallationsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListAppInstallationsWhen::new(when),
                operations::OrgsListAppInstallationsThen::new(then),
            )
        })
    }

    fn interactions_get_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForOrgWhen,
            operations::InteractionsGetRestrictionsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsGetRestrictionsForOrgWhen::new(when),
                operations::InteractionsGetRestrictionsForOrgThen::new(then),
            )
        })
    }

    fn interactions_set_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForOrgWhen,
            operations::InteractionsSetRestrictionsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsSetRestrictionsForOrgWhen::new(when),
                operations::InteractionsSetRestrictionsForOrgThen::new(then),
            )
        })
    }

    fn interactions_remove_restrictions_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForOrgWhen,
            operations::InteractionsRemoveRestrictionsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsRemoveRestrictionsForOrgWhen::new(when),
                operations::InteractionsRemoveRestrictionsForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_pending_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListPendingInvitationsWhen,
            operations::OrgsListPendingInvitationsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPendingInvitationsWhen::new(when),
                operations::OrgsListPendingInvitationsThen::new(then),
            )
        })
    }

    fn orgs_create_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCreateInvitationWhen, operations::OrgsCreateInvitationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCreateInvitationWhen::new(when),
                operations::OrgsCreateInvitationThen::new(then),
            )
        })
    }

    fn orgs_cancel_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsCancelInvitationWhen, operations::OrgsCancelInvitationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCancelInvitationWhen::new(when),
                operations::OrgsCancelInvitationThen::new(then),
            )
        })
    }

    fn orgs_list_invitation_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListInvitationTeamsWhen, operations::OrgsListInvitationTeamsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListInvitationTeamsWhen::new(when),
                operations::OrgsListInvitationTeamsThen::new(then),
            )
        })
    }

    fn issues_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListForOrgWhen, operations::IssuesListForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListForOrgWhen::new(when),
                operations::IssuesListForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_members<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListMembersWhen, operations::OrgsListMembersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListMembersWhen::new(when),
                operations::OrgsListMembersThen::new(then),
            )
        })
    }

    fn orgs_check_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsCheckMembershipForUserWhen,
            operations::OrgsCheckMembershipForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCheckMembershipForUserWhen::new(when),
                operations::OrgsCheckMembershipForUserThen::new(then),
            )
        })
    }

    fn orgs_remove_member<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsRemoveMemberWhen, operations::OrgsRemoveMemberThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRemoveMemberWhen::new(when),
                operations::OrgsRemoveMemberThen::new(then),
            )
        })
    }

    fn codespaces_get_codespaces_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetCodespacesForUserInOrgWhen,
            operations::CodespacesGetCodespacesForUserInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetCodespacesForUserInOrgWhen::new(when),
                operations::CodespacesGetCodespacesForUserInOrgThen::new(then),
            )
        })
    }

    fn codespaces_delete_from_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteFromOrganizationWhen,
            operations::CodespacesDeleteFromOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteFromOrganizationWhen::new(when),
                operations::CodespacesDeleteFromOrganizationThen::new(then),
            )
        })
    }

    fn codespaces_stop_in_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStopInOrganizationWhen,
            operations::CodespacesStopInOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesStopInOrganizationWhen::new(when),
                operations::CodespacesStopInOrganizationThen::new(then),
            )
        })
    }

    fn orgs_get_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetMembershipForUserWhen,
            operations::OrgsGetMembershipForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsGetMembershipForUserWhen::new(when),
                operations::OrgsGetMembershipForUserThen::new(then),
            )
        })
    }

    fn orgs_set_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsSetMembershipForUserWhen,
            operations::OrgsSetMembershipForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsSetMembershipForUserWhen::new(when),
                operations::OrgsSetMembershipForUserThen::new(then),
            )
        })
    }

    fn orgs_remove_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveMembershipForUserWhen,
            operations::OrgsRemoveMembershipForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRemoveMembershipForUserWhen::new(when),
                operations::OrgsRemoveMembershipForUserThen::new(then),
            )
        })
    }

    fn migrations_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsListForOrgWhen, operations::MigrationsListForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsListForOrgWhen::new(when),
                operations::MigrationsListForOrgThen::new(then),
            )
        })
    }

    fn migrations_start_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsStartForOrgWhen, operations::MigrationsStartForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsStartForOrgWhen::new(when),
                operations::MigrationsStartForOrgThen::new(then),
            )
        })
    }

    fn migrations_get_status_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetStatusForOrgWhen,
            operations::MigrationsGetStatusForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetStatusForOrgWhen::new(when),
                operations::MigrationsGetStatusForOrgThen::new(then),
            )
        })
    }

    fn migrations_download_archive_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDownloadArchiveForOrgWhen,
            operations::MigrationsDownloadArchiveForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsDownloadArchiveForOrgWhen::new(when),
                operations::MigrationsDownloadArchiveForOrgThen::new(then),
            )
        })
    }

    fn migrations_delete_archive_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDeleteArchiveForOrgWhen,
            operations::MigrationsDeleteArchiveForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsDeleteArchiveForOrgWhen::new(when),
                operations::MigrationsDeleteArchiveForOrgThen::new(then),
            )
        })
    }

    fn migrations_unlock_repo_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsUnlockRepoForOrgWhen,
            operations::MigrationsUnlockRepoForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsUnlockRepoForOrgWhen::new(when),
                operations::MigrationsUnlockRepoForOrgThen::new(then),
            )
        })
    }

    fn migrations_list_repos_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListReposForOrgWhen,
            operations::MigrationsListReposForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsListReposForOrgWhen::new(when),
                operations::MigrationsListReposForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_outside_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListOutsideCollaboratorsWhen,
            operations::OrgsListOutsideCollaboratorsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListOutsideCollaboratorsWhen::new(when),
                operations::OrgsListOutsideCollaboratorsThen::new(then),
            )
        })
    }

    fn orgs_convert_member_to_outside_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsConvertMemberToOutsideCollaboratorWhen,
            operations::OrgsConvertMemberToOutsideCollaboratorThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsConvertMemberToOutsideCollaboratorWhen::new(when),
                operations::OrgsConvertMemberToOutsideCollaboratorThen::new(then),
            )
        })
    }

    fn orgs_remove_outside_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveOutsideCollaboratorWhen,
            operations::OrgsRemoveOutsideCollaboratorThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRemoveOutsideCollaboratorWhen::new(when),
                operations::OrgsRemoveOutsideCollaboratorThen::new(then),
            )
        })
    }

    fn packages_list_packages_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForOrganizationWhen,
            operations::PackagesListPackagesForOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesListPackagesForOrganizationWhen::new(when),
                operations::PackagesListPackagesForOrganizationThen::new(then),
            )
        })
    }

    fn packages_get_package_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForOrganizationWhen,
            operations::PackagesGetPackageForOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageForOrganizationWhen::new(when),
                operations::PackagesGetPackageForOrganizationThen::new(then),
            )
        })
    }

    fn packages_delete_package_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForOrgWhen,
            operations::PackagesDeletePackageForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageForOrgWhen::new(when),
                operations::PackagesDeletePackageForOrgThen::new(then),
            )
        })
    }

    fn packages_restore_package_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForOrgWhen,
            operations::PackagesRestorePackageForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageForOrgWhen::new(when),
                operations::PackagesRestorePackageForOrgThen::new(then),
            )
        })
    }

    fn packages_get_all_package_versions_for_package_owned_by_org<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgWhen::new(when),
                operations::PackagesGetAllPackageVersionsForPackageOwnedByOrgThen::new(then),
            )
        })
    }

    fn packages_get_package_version_for_organization<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForOrganizationWhen,
            operations::PackagesGetPackageVersionForOrganizationThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageVersionForOrganizationWhen::new(when),
                operations::PackagesGetPackageVersionForOrganizationThen::new(then),
            )
        })
    }

    fn packages_delete_package_version_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForOrgWhen,
            operations::PackagesDeletePackageVersionForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageVersionForOrgWhen::new(when),
                operations::PackagesDeletePackageVersionForOrgThen::new(then),
            )
        })
    }

    fn packages_restore_package_version_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForOrgWhen,
            operations::PackagesRestorePackageVersionForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageVersionForOrgWhen::new(when),
                operations::PackagesRestorePackageVersionForOrgThen::new(then),
            )
        })
    }

    fn projects_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForOrgWhen, operations::ProjectsListForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsListForOrgWhen::new(when),
                operations::ProjectsListForOrgThen::new(then),
            )
        })
    }

    fn projects_create_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateForOrgWhen, operations::ProjectsCreateForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsCreateForOrgWhen::new(when),
                operations::ProjectsCreateForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_public_members<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListPublicMembersWhen, operations::OrgsListPublicMembersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListPublicMembersWhen::new(when),
                operations::OrgsListPublicMembersThen::new(then),
            )
        })
    }

    fn orgs_check_public_membership_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsCheckPublicMembershipForUserWhen,
            operations::OrgsCheckPublicMembershipForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsCheckPublicMembershipForUserWhen::new(when),
                operations::OrgsCheckPublicMembershipForUserThen::new(then),
            )
        })
    }

    fn orgs_set_public_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsSetPublicMembershipForAuthenticatedUserWhen,
            operations::OrgsSetPublicMembershipForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsSetPublicMembershipForAuthenticatedUserWhen::new(when),
                operations::OrgsSetPublicMembershipForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn orgs_remove_public_membership_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemovePublicMembershipForAuthenticatedUserWhen,
            operations::OrgsRemovePublicMembershipForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRemovePublicMembershipForAuthenticatedUserWhen::new(when),
                operations::OrgsRemovePublicMembershipForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_list_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForOrgWhen, operations::ReposListForOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListForOrgWhen::new(when),
                operations::ReposListForOrgThen::new(then),
            )
        })
    }

    fn repos_create_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateInOrgWhen, operations::ReposCreateInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateInOrgWhen::new(when),
                operations::ReposCreateInOrgThen::new(then),
            )
        })
    }

    fn repos_get_org_rulesets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetOrgRulesetsWhen, operations::ReposGetOrgRulesetsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetOrgRulesetsWhen::new(when),
                operations::ReposGetOrgRulesetsThen::new(then),
            )
        })
    }

    fn repos_create_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateOrgRulesetWhen, operations::ReposCreateOrgRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateOrgRulesetWhen::new(when),
                operations::ReposCreateOrgRulesetThen::new(then),
            )
        })
    }

    fn repos_get_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetOrgRulesetWhen, operations::ReposGetOrgRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetOrgRulesetWhen::new(when),
                operations::ReposGetOrgRulesetThen::new(then),
            )
        })
    }

    fn repos_update_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateOrgRulesetWhen, operations::ReposUpdateOrgRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateOrgRulesetWhen::new(when),
                operations::ReposUpdateOrgRulesetThen::new(then),
            )
        })
    }

    fn repos_delete_org_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteOrgRulesetWhen, operations::ReposDeleteOrgRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteOrgRulesetWhen::new(when),
                operations::ReposDeleteOrgRulesetThen::new(then),
            )
        })
    }

    fn secret_scanning_list_alerts_for_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForOrgWhen,
            operations::SecretScanningListAlertsForOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningListAlertsForOrgWhen::new(when),
                operations::SecretScanningListAlertsForOrgThen::new(then),
            )
        })
    }

    fn orgs_list_security_manager_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListSecurityManagerTeamsWhen,
            operations::OrgsListSecurityManagerTeamsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListSecurityManagerTeamsWhen::new(when),
                operations::OrgsListSecurityManagerTeamsThen::new(then),
            )
        })
    }

    fn orgs_add_security_manager_team<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsAddSecurityManagerTeamWhen,
            operations::OrgsAddSecurityManagerTeamThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsAddSecurityManagerTeamWhen::new(when),
                operations::OrgsAddSecurityManagerTeamThen::new(then),
            )
        })
    }

    fn orgs_remove_security_manager_team<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsRemoveSecurityManagerTeamWhen,
            operations::OrgsRemoveSecurityManagerTeamThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsRemoveSecurityManagerTeamWhen::new(when),
                operations::OrgsRemoveSecurityManagerTeamThen::new(then),
            )
        })
    }

    fn billing_get_github_actions_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubActionsBillingOrgWhen,
            operations::BillingGetGithubActionsBillingOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetGithubActionsBillingOrgWhen::new(when),
                operations::BillingGetGithubActionsBillingOrgThen::new(then),
            )
        })
    }

    fn billing_get_github_packages_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubPackagesBillingOrgWhen,
            operations::BillingGetGithubPackagesBillingOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetGithubPackagesBillingOrgWhen::new(when),
                operations::BillingGetGithubPackagesBillingOrgThen::new(then),
            )
        })
    }

    fn billing_get_shared_storage_billing_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetSharedStorageBillingOrgWhen,
            operations::BillingGetSharedStorageBillingOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetSharedStorageBillingOrgWhen::new(when),
                operations::BillingGetSharedStorageBillingOrgThen::new(then),
            )
        })
    }

    fn teams_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListWhen, operations::TeamsListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListWhen::new(when),
                operations::TeamsListThen::new(then),
            )
        })
    }

    fn teams_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsCreateWhen, operations::TeamsCreateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCreateWhen::new(when),
                operations::TeamsCreateThen::new(then),
            )
        })
    }

    fn teams_get_by_name<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetByNameWhen, operations::TeamsGetByNameThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetByNameWhen::new(when),
                operations::TeamsGetByNameThen::new(then),
            )
        })
    }

    fn teams_delete_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsDeleteInOrgWhen, operations::TeamsDeleteInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteInOrgWhen::new(when),
                operations::TeamsDeleteInOrgThen::new(then),
            )
        })
    }

    fn teams_update_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsUpdateInOrgWhen, operations::TeamsUpdateInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateInOrgWhen::new(when),
                operations::TeamsUpdateInOrgThen::new(then),
            )
        })
    }

    fn teams_list_discussions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionsInOrgWhen,
            operations::TeamsListDiscussionsInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListDiscussionsInOrgWhen::new(when),
                operations::TeamsListDiscussionsInOrgThen::new(then),
            )
        })
    }

    fn teams_create_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionInOrgWhen,
            operations::TeamsCreateDiscussionInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCreateDiscussionInOrgWhen::new(when),
                operations::TeamsCreateDiscussionInOrgThen::new(then),
            )
        })
    }

    fn teams_get_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetDiscussionInOrgWhen, operations::TeamsGetDiscussionInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetDiscussionInOrgWhen::new(when),
                operations::TeamsGetDiscussionInOrgThen::new(then),
            )
        })
    }

    fn teams_delete_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionInOrgWhen,
            operations::TeamsDeleteDiscussionInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteDiscussionInOrgWhen::new(when),
                operations::TeamsDeleteDiscussionInOrgThen::new(then),
            )
        })
    }

    fn teams_update_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionInOrgWhen,
            operations::TeamsUpdateDiscussionInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateDiscussionInOrgWhen::new(when),
                operations::TeamsUpdateDiscussionInOrgThen::new(then),
            )
        })
    }

    fn teams_list_discussion_comments_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionCommentsInOrgWhen,
            operations::TeamsListDiscussionCommentsInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListDiscussionCommentsInOrgWhen::new(when),
                operations::TeamsListDiscussionCommentsInOrgThen::new(then),
            )
        })
    }

    fn teams_create_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionCommentInOrgWhen,
            operations::TeamsCreateDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCreateDiscussionCommentInOrgWhen::new(when),
                operations::TeamsCreateDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn teams_get_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionCommentInOrgWhen,
            operations::TeamsGetDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetDiscussionCommentInOrgWhen::new(when),
                operations::TeamsGetDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn teams_delete_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionCommentInOrgWhen,
            operations::TeamsDeleteDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteDiscussionCommentInOrgWhen::new(when),
                operations::TeamsDeleteDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn teams_update_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionCommentInOrgWhen,
            operations::TeamsUpdateDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateDiscussionCommentInOrgWhen::new(when),
                operations::TeamsUpdateDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn reactions_list_for_team_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionCommentInOrgWhen,
            operations::ReactionsListForTeamDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForTeamDiscussionCommentInOrgWhen::new(when),
                operations::ReactionsListForTeamDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn reactions_create_for_team_discussion_comment_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionCommentInOrgWhen,
            operations::ReactionsCreateForTeamDiscussionCommentInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForTeamDiscussionCommentInOrgWhen::new(when),
                operations::ReactionsCreateForTeamDiscussionCommentInOrgThen::new(then),
            )
        })
    }

    fn reactions_delete_for_team_discussion_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForTeamDiscussionCommentWhen,
            operations::ReactionsDeleteForTeamDiscussionCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForTeamDiscussionCommentWhen::new(when),
                operations::ReactionsDeleteForTeamDiscussionCommentThen::new(then),
            )
        })
    }

    fn reactions_list_for_team_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionInOrgWhen,
            operations::ReactionsListForTeamDiscussionInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForTeamDiscussionInOrgWhen::new(when),
                operations::ReactionsListForTeamDiscussionInOrgThen::new(then),
            )
        })
    }

    fn reactions_create_for_team_discussion_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionInOrgWhen,
            operations::ReactionsCreateForTeamDiscussionInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForTeamDiscussionInOrgWhen::new(when),
                operations::ReactionsCreateForTeamDiscussionInOrgThen::new(then),
            )
        })
    }

    fn reactions_delete_for_team_discussion<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForTeamDiscussionWhen,
            operations::ReactionsDeleteForTeamDiscussionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForTeamDiscussionWhen::new(when),
                operations::ReactionsDeleteForTeamDiscussionThen::new(then),
            )
        })
    }

    fn teams_list_pending_invitations_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListPendingInvitationsInOrgWhen,
            operations::TeamsListPendingInvitationsInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListPendingInvitationsInOrgWhen::new(when),
                operations::TeamsListPendingInvitationsInOrgThen::new(then),
            )
        })
    }

    fn teams_list_members_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListMembersInOrgWhen, operations::TeamsListMembersInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListMembersInOrgWhen::new(when),
                operations::TeamsListMembersInOrgThen::new(then),
            )
        })
    }

    fn teams_get_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetMembershipForUserInOrgWhen,
            operations::TeamsGetMembershipForUserInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetMembershipForUserInOrgWhen::new(when),
                operations::TeamsGetMembershipForUserInOrgThen::new(then),
            )
        })
    }

    fn teams_add_or_update_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateMembershipForUserInOrgWhen,
            operations::TeamsAddOrUpdateMembershipForUserInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateMembershipForUserInOrgWhen::new(when),
                operations::TeamsAddOrUpdateMembershipForUserInOrgThen::new(then),
            )
        })
    }

    fn teams_remove_membership_for_user_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveMembershipForUserInOrgWhen,
            operations::TeamsRemoveMembershipForUserInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveMembershipForUserInOrgWhen::new(when),
                operations::TeamsRemoveMembershipForUserInOrgThen::new(then),
            )
        })
    }

    fn teams_list_projects_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListProjectsInOrgWhen, operations::TeamsListProjectsInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListProjectsInOrgWhen::new(when),
                operations::TeamsListProjectsInOrgThen::new(then),
            )
        })
    }

    fn teams_check_permissions_for_project_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForProjectInOrgWhen,
            operations::TeamsCheckPermissionsForProjectInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCheckPermissionsForProjectInOrgWhen::new(when),
                operations::TeamsCheckPermissionsForProjectInOrgThen::new(then),
            )
        })
    }

    fn teams_add_or_update_project_permissions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateProjectPermissionsInOrgWhen,
            operations::TeamsAddOrUpdateProjectPermissionsInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateProjectPermissionsInOrgWhen::new(when),
                operations::TeamsAddOrUpdateProjectPermissionsInOrgThen::new(then),
            )
        })
    }

    fn teams_remove_project_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveProjectInOrgWhen, operations::TeamsRemoveProjectInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveProjectInOrgWhen::new(when),
                operations::TeamsRemoveProjectInOrgThen::new(then),
            )
        })
    }

    fn teams_list_repos_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListReposInOrgWhen, operations::TeamsListReposInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListReposInOrgWhen::new(when),
                operations::TeamsListReposInOrgThen::new(then),
            )
        })
    }

    fn teams_check_permissions_for_repo_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForRepoInOrgWhen,
            operations::TeamsCheckPermissionsForRepoInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCheckPermissionsForRepoInOrgWhen::new(when),
                operations::TeamsCheckPermissionsForRepoInOrgThen::new(then),
            )
        })
    }

    fn teams_add_or_update_repo_permissions_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateRepoPermissionsInOrgWhen,
            operations::TeamsAddOrUpdateRepoPermissionsInOrgThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateRepoPermissionsInOrgWhen::new(when),
                operations::TeamsAddOrUpdateRepoPermissionsInOrgThen::new(then),
            )
        })
    }

    fn teams_remove_repo_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveRepoInOrgWhen, operations::TeamsRemoveRepoInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveRepoInOrgWhen::new(when),
                operations::TeamsRemoveRepoInOrgThen::new(then),
            )
        })
    }

    fn teams_list_child_in_org<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListChildInOrgWhen, operations::TeamsListChildInOrgThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListChildInOrgWhen::new(when),
                operations::TeamsListChildInOrgThen::new(then),
            )
        })
    }

    fn orgs_enable_or_disable_security_product_on_all_org_repos<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposWhen,
            operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposWhen::new(when),
                operations::OrgsEnableOrDisableSecurityProductOnAllOrgReposThen::new(then),
            )
        })
    }

    fn projects_get_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetCardWhen, operations::ProjectsGetCardThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsGetCardWhen::new(when),
                operations::ProjectsGetCardThen::new(then),
            )
        })
    }

    fn projects_delete_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteCardWhen, operations::ProjectsDeleteCardThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsDeleteCardWhen::new(when),
                operations::ProjectsDeleteCardThen::new(then),
            )
        })
    }

    fn projects_update_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateCardWhen, operations::ProjectsUpdateCardThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsUpdateCardWhen::new(when),
                operations::ProjectsUpdateCardThen::new(then),
            )
        })
    }

    fn projects_move_card<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsMoveCardWhen, operations::ProjectsMoveCardThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsMoveCardWhen::new(when),
                operations::ProjectsMoveCardThen::new(then),
            )
        })
    }

    fn projects_get_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetColumnWhen, operations::ProjectsGetColumnThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsGetColumnWhen::new(when),
                operations::ProjectsGetColumnThen::new(then),
            )
        })
    }

    fn projects_delete_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteColumnWhen, operations::ProjectsDeleteColumnThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsDeleteColumnWhen::new(when),
                operations::ProjectsDeleteColumnThen::new(then),
            )
        })
    }

    fn projects_update_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateColumnWhen, operations::ProjectsUpdateColumnThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsUpdateColumnWhen::new(when),
                operations::ProjectsUpdateColumnThen::new(then),
            )
        })
    }

    fn users_list_ssh_signing_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSshSigningKeysForUserWhen,
            operations::UsersListSshSigningKeysForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListSshSigningKeysForUserWhen::new(when),
                operations::UsersListSshSigningKeysForUserThen::new(then),
            )
        })
    }

    fn projects_move_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsMoveColumnWhen, operations::ProjectsMoveColumnThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsMoveColumnWhen::new(when),
                operations::ProjectsMoveColumnThen::new(then),
            )
        })
    }

    fn projects_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsGetWhen, operations::ProjectsGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsGetWhen::new(when),
                operations::ProjectsGetThen::new(then),
            )
        })
    }

    fn projects_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsDeleteWhen, operations::ProjectsDeleteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsDeleteWhen::new(when),
                operations::ProjectsDeleteThen::new(then),
            )
        })
    }

    fn projects_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsUpdateWhen, operations::ProjectsUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsUpdateWhen::new(when),
                operations::ProjectsUpdateThen::new(then),
            )
        })
    }

    fn projects_list_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsListCollaboratorsWhen,
            operations::ProjectsListCollaboratorsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsListCollaboratorsWhen::new(when),
                operations::ProjectsListCollaboratorsThen::new(then),
            )
        })
    }

    fn projects_add_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsAddCollaboratorWhen, operations::ProjectsAddCollaboratorThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsAddCollaboratorWhen::new(when),
                operations::ProjectsAddCollaboratorThen::new(then),
            )
        })
    }

    fn projects_remove_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsRemoveCollaboratorWhen,
            operations::ProjectsRemoveCollaboratorThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsRemoveCollaboratorWhen::new(when),
                operations::ProjectsRemoveCollaboratorThen::new(then),
            )
        })
    }

    fn projects_get_permission_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsGetPermissionForUserWhen,
            operations::ProjectsGetPermissionForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsGetPermissionForUserWhen::new(when),
                operations::ProjectsGetPermissionForUserThen::new(then),
            )
        })
    }

    fn projects_list_columns<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListColumnsWhen, operations::ProjectsListColumnsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsListColumnsWhen::new(when),
                operations::ProjectsListColumnsThen::new(then),
            )
        })
    }

    fn projects_create_column<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateColumnWhen, operations::ProjectsCreateColumnThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsCreateColumnWhen::new(when),
                operations::ProjectsCreateColumnThen::new(then),
            )
        })
    }

    fn rate_limit_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::RateLimitGetWhen, operations::RateLimitGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::RateLimitGetWhen::new(when),
                operations::RateLimitGetThen::new(then),
            )
        })
    }

    fn actions_list_repo_required_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoRequiredWorkflowsWhen,
            operations::ActionsListRepoRequiredWorkflowsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoRequiredWorkflowsWhen::new(when),
                operations::ActionsListRepoRequiredWorkflowsThen::new(then),
            )
        })
    }

    fn actions_get_repo_required_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRepoRequiredWorkflowWhen,
            operations::ActionsGetRepoRequiredWorkflowThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRepoRequiredWorkflowWhen::new(when),
                operations::ActionsGetRepoRequiredWorkflowThen::new(then),
            )
        })
    }

    fn actions_get_repo_required_workflow_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetRepoRequiredWorkflowUsageWhen,
            operations::ActionsGetRepoRequiredWorkflowUsageThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRepoRequiredWorkflowUsageWhen::new(when),
                operations::ActionsGetRepoRequiredWorkflowUsageThen::new(then),
            )
        })
    }

    fn repos_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWhen, operations::ReposGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetWhen::new(when),
                operations::ReposGetThen::new(then),
            )
        })
    }

    fn repos_delete<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteWhen, operations::ReposDeleteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteWhen::new(when),
                operations::ReposDeleteThen::new(then),
            )
        })
    }

    fn repos_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateWhen, operations::ReposUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateWhen::new(when),
                operations::ReposUpdateThen::new(then),
            )
        })
    }

    fn actions_list_artifacts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListArtifactsForRepoWhen,
            operations::ActionsListArtifactsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListArtifactsForRepoWhen::new(when),
                operations::ActionsListArtifactsForRepoThen::new(then),
            )
        })
    }

    fn actions_get_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetArtifactWhen, operations::ActionsGetArtifactThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetArtifactWhen::new(when),
                operations::ActionsGetArtifactThen::new(then),
            )
        })
    }

    fn actions_delete_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteArtifactWhen, operations::ActionsDeleteArtifactThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteArtifactWhen::new(when),
                operations::ActionsDeleteArtifactThen::new(then),
            )
        })
    }

    fn actions_download_artifact<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDownloadArtifactWhen, operations::ActionsDownloadArtifactThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDownloadArtifactWhen::new(when),
                operations::ActionsDownloadArtifactThen::new(then),
            )
        })
    }

    fn actions_get_actions_cache_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheUsageWhen,
            operations::ActionsGetActionsCacheUsageThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetActionsCacheUsageWhen::new(when),
                operations::ActionsGetActionsCacheUsageThen::new(then),
            )
        })
    }

    fn actions_get_actions_cache_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetActionsCacheListWhen,
            operations::ActionsGetActionsCacheListThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetActionsCacheListWhen::new(when),
                operations::ActionsGetActionsCacheListThen::new(then),
            )
        })
    }

    fn actions_delete_actions_cache_by_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteActionsCacheByKeyWhen,
            operations::ActionsDeleteActionsCacheByKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteActionsCacheByKeyWhen::new(when),
                operations::ActionsDeleteActionsCacheByKeyThen::new(then),
            )
        })
    }

    fn actions_delete_actions_cache_by_id<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteActionsCacheByIdWhen,
            operations::ActionsDeleteActionsCacheByIdThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteActionsCacheByIdWhen::new(when),
                operations::ActionsDeleteActionsCacheByIdThen::new(then),
            )
        })
    }

    fn actions_get_job_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetJobForWorkflowRunWhen,
            operations::ActionsGetJobForWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetJobForWorkflowRunWhen::new(when),
                operations::ActionsGetJobForWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_download_job_logs_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadJobLogsForWorkflowRunWhen,
            operations::ActionsDownloadJobLogsForWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDownloadJobLogsForWorkflowRunWhen::new(when),
                operations::ActionsDownloadJobLogsForWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_re_run_job_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReRunJobForWorkflowRunWhen,
            operations::ActionsReRunJobForWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsReRunJobForWorkflowRunWhen::new(when),
                operations::ActionsReRunJobForWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_get_custom_oidc_sub_claim_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetCustomOidcSubClaimForRepoWhen,
            operations::ActionsGetCustomOidcSubClaimForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetCustomOidcSubClaimForRepoWhen::new(when),
                operations::ActionsGetCustomOidcSubClaimForRepoThen::new(then),
            )
        })
    }

    fn actions_set_custom_oidc_sub_claim_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomOidcSubClaimForRepoWhen,
            operations::ActionsSetCustomOidcSubClaimForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetCustomOidcSubClaimForRepoWhen::new(when),
                operations::ActionsSetCustomOidcSubClaimForRepoThen::new(then),
            )
        })
    }

    fn actions_list_repo_organization_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoOrganizationSecretsWhen,
            operations::ActionsListRepoOrganizationSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoOrganizationSecretsWhen::new(when),
                operations::ActionsListRepoOrganizationSecretsThen::new(then),
            )
        })
    }

    fn actions_list_repo_organization_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoOrganizationVariablesWhen,
            operations::ActionsListRepoOrganizationVariablesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoOrganizationVariablesWhen::new(when),
                operations::ActionsListRepoOrganizationVariablesThen::new(then),
            )
        })
    }

    fn actions_get_github_actions_permissions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsPermissionsRepositoryWhen,
            operations::ActionsGetGithubActionsPermissionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetGithubActionsPermissionsRepositoryWhen::new(when),
                operations::ActionsGetGithubActionsPermissionsRepositoryThen::new(then),
            )
        })
    }

    fn actions_set_github_actions_permissions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsPermissionsRepositoryWhen,
            operations::ActionsSetGithubActionsPermissionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetGithubActionsPermissionsRepositoryWhen::new(when),
                operations::ActionsSetGithubActionsPermissionsRepositoryThen::new(then),
            )
        })
    }

    fn actions_get_workflow_access_to_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowAccessToRepositoryWhen,
            operations::ActionsGetWorkflowAccessToRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowAccessToRepositoryWhen::new(when),
                operations::ActionsGetWorkflowAccessToRepositoryThen::new(then),
            )
        })
    }

    fn actions_set_workflow_access_to_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetWorkflowAccessToRepositoryWhen,
            operations::ActionsSetWorkflowAccessToRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetWorkflowAccessToRepositoryWhen::new(when),
                operations::ActionsSetWorkflowAccessToRepositoryThen::new(then),
            )
        })
    }

    fn actions_get_allowed_actions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetAllowedActionsRepositoryWhen,
            operations::ActionsGetAllowedActionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetAllowedActionsRepositoryWhen::new(when),
                operations::ActionsGetAllowedActionsRepositoryThen::new(then),
            )
        })
    }

    fn actions_set_allowed_actions_repository<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetAllowedActionsRepositoryWhen,
            operations::ActionsSetAllowedActionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetAllowedActionsRepositoryWhen::new(when),
                operations::ActionsSetAllowedActionsRepositoryThen::new(then),
            )
        })
    }

    fn actions_get_github_actions_default_workflow_permissions_repository<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWhen,
            operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryWhen::new(
                    when,
                ),
                operations::ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_set_github_actions_default_workflow_permissions_repository<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWhen,
            operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryWhen::new(
                    when,
                ),
                operations::ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryThen::new(
                    then,
                ),
            )
        })
    }

    fn actions_list_required_workflow_runs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRequiredWorkflowRunsWhen,
            operations::ActionsListRequiredWorkflowRunsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRequiredWorkflowRunsWhen::new(when),
                operations::ActionsListRequiredWorkflowRunsThen::new(then),
            )
        })
    }

    fn actions_list_self_hosted_runners_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListSelfHostedRunnersForRepoWhen,
            operations::ActionsListSelfHostedRunnersForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListSelfHostedRunnersForRepoWhen::new(when),
                operations::ActionsListSelfHostedRunnersForRepoThen::new(then),
            )
        })
    }

    fn actions_list_runner_applications_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRunnerApplicationsForRepoWhen,
            operations::ActionsListRunnerApplicationsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRunnerApplicationsForRepoWhen::new(when),
                operations::ActionsListRunnerApplicationsForRepoThen::new(then),
            )
        })
    }

    fn actions_create_registration_token_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRegistrationTokenForRepoWhen,
            operations::ActionsCreateRegistrationTokenForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRegistrationTokenForRepoWhen::new(when),
                operations::ActionsCreateRegistrationTokenForRepoThen::new(then),
            )
        })
    }

    fn actions_create_remove_token_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRemoveTokenForRepoWhen,
            operations::ActionsCreateRemoveTokenForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRemoveTokenForRepoWhen::new(when),
                operations::ActionsCreateRemoveTokenForRepoThen::new(then),
            )
        })
    }

    fn actions_get_self_hosted_runner_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetSelfHostedRunnerForRepoWhen,
            operations::ActionsGetSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsGetSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_delete_self_hosted_runner_from_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteSelfHostedRunnerFromRepoWhen,
            operations::ActionsDeleteSelfHostedRunnerFromRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteSelfHostedRunnerFromRepoWhen::new(when),
                operations::ActionsDeleteSelfHostedRunnerFromRepoThen::new(then),
            )
        })
    }

    fn actions_list_labels_for_self_hosted_runner_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListLabelsForSelfHostedRunnerForRepoWhen,
            operations::ActionsListLabelsForSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListLabelsForSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsListLabelsForSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_set_custom_labels_for_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoWhen,
            operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsSetCustomLabelsForSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_add_custom_labels_to_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoWhen,
            operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsAddCustomLabelsToSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_remove_all_custom_labels_from_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWhen,
            operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_remove_custom_label_from_self_hosted_runner_for_repo<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoWhen,
            operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoWhen::new(when),
                operations::ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoThen::new(then),
            )
        })
    }

    fn actions_list_workflow_runs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListWorkflowRunsForRepoWhen,
            operations::ActionsListWorkflowRunsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListWorkflowRunsForRepoWhen::new(when),
                operations::ActionsListWorkflowRunsForRepoThen::new(then),
            )
        })
    }

    fn actions_get_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowRunWhen, operations::ActionsGetWorkflowRunThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowRunWhen::new(when),
                operations::ActionsGetWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_delete_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteWorkflowRunWhen,
            operations::ActionsDeleteWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteWorkflowRunWhen::new(when),
                operations::ActionsDeleteWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_get_reviews_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetReviewsForRunWhen, operations::ActionsGetReviewsForRunThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetReviewsForRunWhen::new(when),
                operations::ActionsGetReviewsForRunThen::new(then),
            )
        })
    }

    fn actions_approve_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsApproveWorkflowRunWhen,
            operations::ActionsApproveWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsApproveWorkflowRunWhen::new(when),
                operations::ActionsApproveWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_list_workflow_run_artifacts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListWorkflowRunArtifactsWhen,
            operations::ActionsListWorkflowRunArtifactsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListWorkflowRunArtifactsWhen::new(when),
                operations::ActionsListWorkflowRunArtifactsThen::new(then),
            )
        })
    }

    fn actions_get_workflow_run_attempt<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowRunAttemptWhen,
            operations::ActionsGetWorkflowRunAttemptThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowRunAttemptWhen::new(when),
                operations::ActionsGetWorkflowRunAttemptThen::new(then),
            )
        })
    }

    fn actions_list_jobs_for_workflow_run_attempt<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListJobsForWorkflowRunAttemptWhen,
            operations::ActionsListJobsForWorkflowRunAttemptThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListJobsForWorkflowRunAttemptWhen::new(when),
                operations::ActionsListJobsForWorkflowRunAttemptThen::new(then),
            )
        })
    }

    fn actions_download_workflow_run_attempt_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadWorkflowRunAttemptLogsWhen,
            operations::ActionsDownloadWorkflowRunAttemptLogsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDownloadWorkflowRunAttemptLogsWhen::new(when),
                operations::ActionsDownloadWorkflowRunAttemptLogsThen::new(then),
            )
        })
    }

    fn actions_cancel_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCancelWorkflowRunWhen,
            operations::ActionsCancelWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCancelWorkflowRunWhen::new(when),
                operations::ActionsCancelWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_review_custom_gates_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReviewCustomGatesForRunWhen,
            operations::ActionsReviewCustomGatesForRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsReviewCustomGatesForRunWhen::new(when),
                operations::ActionsReviewCustomGatesForRunThen::new(then),
            )
        })
    }

    fn actions_list_jobs_for_workflow_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListJobsForWorkflowRunWhen,
            operations::ActionsListJobsForWorkflowRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListJobsForWorkflowRunWhen::new(when),
                operations::ActionsListJobsForWorkflowRunThen::new(then),
            )
        })
    }

    fn actions_download_workflow_run_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDownloadWorkflowRunLogsWhen,
            operations::ActionsDownloadWorkflowRunLogsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDownloadWorkflowRunLogsWhen::new(when),
                operations::ActionsDownloadWorkflowRunLogsThen::new(then),
            )
        })
    }

    fn actions_delete_workflow_run_logs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteWorkflowRunLogsWhen,
            operations::ActionsDeleteWorkflowRunLogsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteWorkflowRunLogsWhen::new(when),
                operations::ActionsDeleteWorkflowRunLogsThen::new(then),
            )
        })
    }

    fn actions_get_pending_deployments_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetPendingDeploymentsForRunWhen,
            operations::ActionsGetPendingDeploymentsForRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetPendingDeploymentsForRunWhen::new(when),
                operations::ActionsGetPendingDeploymentsForRunThen::new(then),
            )
        })
    }

    fn actions_review_pending_deployments_for_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReviewPendingDeploymentsForRunWhen,
            operations::ActionsReviewPendingDeploymentsForRunThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsReviewPendingDeploymentsForRunWhen::new(when),
                operations::ActionsReviewPendingDeploymentsForRunThen::new(then),
            )
        })
    }

    fn actions_re_run_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsReRunWorkflowWhen, operations::ActionsReRunWorkflowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsReRunWorkflowWhen::new(when),
                operations::ActionsReRunWorkflowThen::new(then),
            )
        })
    }

    fn actions_re_run_workflow_failed_jobs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsReRunWorkflowFailedJobsWhen,
            operations::ActionsReRunWorkflowFailedJobsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsReRunWorkflowFailedJobsWhen::new(when),
                operations::ActionsReRunWorkflowFailedJobsThen::new(then),
            )
        })
    }

    fn actions_get_workflow_run_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetWorkflowRunUsageWhen,
            operations::ActionsGetWorkflowRunUsageThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowRunUsageWhen::new(when),
                operations::ActionsGetWorkflowRunUsageThen::new(then),
            )
        })
    }

    fn actions_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListRepoSecretsWhen, operations::ActionsListRepoSecretsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoSecretsWhen::new(when),
                operations::ActionsListRepoSecretsThen::new(then),
            )
        })
    }

    fn actions_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoPublicKeyWhen, operations::ActionsGetRepoPublicKeyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRepoPublicKeyWhen::new(when),
                operations::ActionsGetRepoPublicKeyThen::new(then),
            )
        })
    }

    fn actions_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoSecretWhen, operations::ActionsGetRepoSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRepoSecretWhen::new(when),
                operations::ActionsGetRepoSecretThen::new(then),
            )
        })
    }

    fn actions_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateRepoSecretWhen,
            operations::ActionsCreateOrUpdateRepoSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateOrUpdateRepoSecretWhen::new(when),
                operations::ActionsCreateOrUpdateRepoSecretThen::new(then),
            )
        })
    }

    fn actions_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDeleteRepoSecretWhen, operations::ActionsDeleteRepoSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteRepoSecretWhen::new(when),
                operations::ActionsDeleteRepoSecretThen::new(then),
            )
        })
    }

    fn actions_list_repo_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoVariablesWhen,
            operations::ActionsListRepoVariablesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoVariablesWhen::new(when),
                operations::ActionsListRepoVariablesThen::new(then),
            )
        })
    }

    fn actions_create_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateRepoVariableWhen,
            operations::ActionsCreateRepoVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateRepoVariableWhen::new(when),
                operations::ActionsCreateRepoVariableThen::new(then),
            )
        })
    }

    fn actions_get_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetRepoVariableWhen, operations::ActionsGetRepoVariableThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetRepoVariableWhen::new(when),
                operations::ActionsGetRepoVariableThen::new(then),
            )
        })
    }

    fn actions_delete_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteRepoVariableWhen,
            operations::ActionsDeleteRepoVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteRepoVariableWhen::new(when),
                operations::ActionsDeleteRepoVariableThen::new(then),
            )
        })
    }

    fn actions_update_repo_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateRepoVariableWhen,
            operations::ActionsUpdateRepoVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsUpdateRepoVariableWhen::new(when),
                operations::ActionsUpdateRepoVariableThen::new(then),
            )
        })
    }

    fn actions_list_repo_workflows<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListRepoWorkflowsWhen,
            operations::ActionsListRepoWorkflowsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListRepoWorkflowsWhen::new(when),
                operations::ActionsListRepoWorkflowsThen::new(then),
            )
        })
    }

    fn actions_get_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowWhen, operations::ActionsGetWorkflowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowWhen::new(when),
                operations::ActionsGetWorkflowThen::new(then),
            )
        })
    }

    fn actions_disable_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsDisableWorkflowWhen, operations::ActionsDisableWorkflowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDisableWorkflowWhen::new(when),
                operations::ActionsDisableWorkflowThen::new(then),
            )
        })
    }

    fn actions_create_workflow_dispatch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateWorkflowDispatchWhen,
            operations::ActionsCreateWorkflowDispatchThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateWorkflowDispatchWhen::new(when),
                operations::ActionsCreateWorkflowDispatchThen::new(then),
            )
        })
    }

    fn actions_enable_workflow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsEnableWorkflowWhen, operations::ActionsEnableWorkflowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsEnableWorkflowWhen::new(when),
                operations::ActionsEnableWorkflowThen::new(then),
            )
        })
    }

    fn actions_list_workflow_runs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsListWorkflowRunsWhen, operations::ActionsListWorkflowRunsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListWorkflowRunsWhen::new(when),
                operations::ActionsListWorkflowRunsThen::new(then),
            )
        })
    }

    fn actions_get_workflow_usage<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActionsGetWorkflowUsageWhen, operations::ActionsGetWorkflowUsageThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetWorkflowUsageWhen::new(when),
                operations::ActionsGetWorkflowUsageThen::new(then),
            )
        })
    }

    fn issues_list_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListAssigneesWhen, operations::IssuesListAssigneesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListAssigneesWhen::new(when),
                operations::IssuesListAssigneesThen::new(then),
            )
        })
    }

    fn issues_check_user_can_be_assigned<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesCheckUserCanBeAssignedWhen,
            operations::IssuesCheckUserCanBeAssignedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCheckUserCanBeAssignedWhen::new(when),
                operations::IssuesCheckUserCanBeAssignedThen::new(then),
            )
        })
    }

    fn repos_list_autolinks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListAutolinksWhen, operations::ReposListAutolinksThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListAutolinksWhen::new(when),
                operations::ReposListAutolinksThen::new(then),
            )
        })
    }

    fn repos_create_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateAutolinkWhen, operations::ReposCreateAutolinkThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateAutolinkWhen::new(when),
                operations::ReposCreateAutolinkThen::new(then),
            )
        })
    }

    fn repos_get_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAutolinkWhen, operations::ReposGetAutolinkThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAutolinkWhen::new(when),
                operations::ReposGetAutolinkThen::new(then),
            )
        })
    }

    fn repos_delete_autolink<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteAutolinkWhen, operations::ReposDeleteAutolinkThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteAutolinkWhen::new(when),
                operations::ReposDeleteAutolinkThen::new(then),
            )
        })
    }

    fn repos_enable_automated_security_fixes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposEnableAutomatedSecurityFixesWhen,
            operations::ReposEnableAutomatedSecurityFixesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposEnableAutomatedSecurityFixesWhen::new(when),
                operations::ReposEnableAutomatedSecurityFixesThen::new(then),
            )
        })
    }

    fn repos_disable_automated_security_fixes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableAutomatedSecurityFixesWhen,
            operations::ReposDisableAutomatedSecurityFixesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDisableAutomatedSecurityFixesWhen::new(when),
                operations::ReposDisableAutomatedSecurityFixesThen::new(then),
            )
        })
    }

    fn repos_list_branches<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListBranchesWhen, operations::ReposListBranchesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListBranchesWhen::new(when),
                operations::ReposListBranchesThen::new(then),
            )
        })
    }

    fn repos_get_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetBranchWhen, operations::ReposGetBranchThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetBranchWhen::new(when),
                operations::ReposGetBranchThen::new(then),
            )
        })
    }

    fn repos_get_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetBranchProtectionWhen,
            operations::ReposGetBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetBranchProtectionWhen::new(when),
                operations::ReposGetBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_update_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateBranchProtectionWhen,
            operations::ReposUpdateBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateBranchProtectionWhen::new(when),
                operations::ReposUpdateBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_delete_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteBranchProtectionWhen,
            operations::ReposDeleteBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteBranchProtectionWhen::new(when),
                operations::ReposDeleteBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_get_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAdminBranchProtectionWhen,
            operations::ReposGetAdminBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAdminBranchProtectionWhen::new(when),
                operations::ReposGetAdminBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_set_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetAdminBranchProtectionWhen,
            operations::ReposSetAdminBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposSetAdminBranchProtectionWhen::new(when),
                operations::ReposSetAdminBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_delete_admin_branch_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAdminBranchProtectionWhen,
            operations::ReposDeleteAdminBranchProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteAdminBranchProtectionWhen::new(when),
                operations::ReposDeleteAdminBranchProtectionThen::new(then),
            )
        })
    }

    fn repos_get_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetPullRequestReviewProtectionWhen,
            operations::ReposGetPullRequestReviewProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetPullRequestReviewProtectionWhen::new(when),
                operations::ReposGetPullRequestReviewProtectionThen::new(then),
            )
        })
    }

    fn repos_delete_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeletePullRequestReviewProtectionWhen,
            operations::ReposDeletePullRequestReviewProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeletePullRequestReviewProtectionWhen::new(when),
                operations::ReposDeletePullRequestReviewProtectionThen::new(then),
            )
        })
    }

    fn repos_update_pull_request_review_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdatePullRequestReviewProtectionWhen,
            operations::ReposUpdatePullRequestReviewProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdatePullRequestReviewProtectionWhen::new(when),
                operations::ReposUpdatePullRequestReviewProtectionThen::new(then),
            )
        })
    }

    fn repos_get_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommitSignatureProtectionWhen,
            operations::ReposGetCommitSignatureProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCommitSignatureProtectionWhen::new(when),
                operations::ReposGetCommitSignatureProtectionThen::new(then),
            )
        })
    }

    fn repos_create_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateCommitSignatureProtectionWhen,
            operations::ReposCreateCommitSignatureProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateCommitSignatureProtectionWhen::new(when),
                operations::ReposCreateCommitSignatureProtectionThen::new(then),
            )
        })
    }

    fn repos_delete_commit_signature_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteCommitSignatureProtectionWhen,
            operations::ReposDeleteCommitSignatureProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteCommitSignatureProtectionWhen::new(when),
                operations::ReposDeleteCommitSignatureProtectionThen::new(then),
            )
        })
    }

    fn repos_get_status_checks_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetStatusChecksProtectionWhen,
            operations::ReposGetStatusChecksProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetStatusChecksProtectionWhen::new(when),
                operations::ReposGetStatusChecksProtectionThen::new(then),
            )
        })
    }

    fn repos_remove_status_check_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveStatusCheckProtectionWhen,
            operations::ReposRemoveStatusCheckProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveStatusCheckProtectionWhen::new(when),
                operations::ReposRemoveStatusCheckProtectionThen::new(then),
            )
        })
    }

    fn repos_update_status_check_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateStatusCheckProtectionWhen,
            operations::ReposUpdateStatusCheckProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateStatusCheckProtectionWhen::new(when),
                operations::ReposUpdateStatusCheckProtectionThen::new(then),
            )
        })
    }

    fn repos_get_all_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAllStatusCheckContextsWhen,
            operations::ReposGetAllStatusCheckContextsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAllStatusCheckContextsWhen::new(when),
                operations::ReposGetAllStatusCheckContextsThen::new(then),
            )
        })
    }

    fn repos_set_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetStatusCheckContextsWhen,
            operations::ReposSetStatusCheckContextsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposSetStatusCheckContextsWhen::new(when),
                operations::ReposSetStatusCheckContextsThen::new(then),
            )
        })
    }

    fn repos_add_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddStatusCheckContextsWhen,
            operations::ReposAddStatusCheckContextsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAddStatusCheckContextsWhen::new(when),
                operations::ReposAddStatusCheckContextsThen::new(then),
            )
        })
    }

    fn repos_remove_status_check_contexts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveStatusCheckContextsWhen,
            operations::ReposRemoveStatusCheckContextsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveStatusCheckContextsWhen::new(when),
                operations::ReposRemoveStatusCheckContextsThen::new(then),
            )
        })
    }

    fn repos_get_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAccessRestrictionsWhen,
            operations::ReposGetAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAccessRestrictionsWhen::new(when),
                operations::ReposGetAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_delete_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAccessRestrictionsWhen,
            operations::ReposDeleteAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteAccessRestrictionsWhen::new(when),
                operations::ReposDeleteAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_get_apps_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAppsWithAccessToProtectedBranchWhen,
            operations::ReposGetAppsWithAccessToProtectedBranchThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAppsWithAccessToProtectedBranchWhen::new(when),
                operations::ReposGetAppsWithAccessToProtectedBranchThen::new(then),
            )
        })
    }

    fn repos_set_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetAppAccessRestrictionsWhen,
            operations::ReposSetAppAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposSetAppAccessRestrictionsWhen::new(when),
                operations::ReposSetAppAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_add_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddAppAccessRestrictionsWhen,
            operations::ReposAddAppAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAddAppAccessRestrictionsWhen::new(when),
                operations::ReposAddAppAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_remove_app_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveAppAccessRestrictionsWhen,
            operations::ReposRemoveAppAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveAppAccessRestrictionsWhen::new(when),
                operations::ReposRemoveAppAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_get_teams_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetTeamsWithAccessToProtectedBranchWhen,
            operations::ReposGetTeamsWithAccessToProtectedBranchThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetTeamsWithAccessToProtectedBranchWhen::new(when),
                operations::ReposGetTeamsWithAccessToProtectedBranchThen::new(then),
            )
        })
    }

    fn repos_set_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetTeamAccessRestrictionsWhen,
            operations::ReposSetTeamAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposSetTeamAccessRestrictionsWhen::new(when),
                operations::ReposSetTeamAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_add_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddTeamAccessRestrictionsWhen,
            operations::ReposAddTeamAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAddTeamAccessRestrictionsWhen::new(when),
                operations::ReposAddTeamAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_remove_team_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveTeamAccessRestrictionsWhen,
            operations::ReposRemoveTeamAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveTeamAccessRestrictionsWhen::new(when),
                operations::ReposRemoveTeamAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_get_users_with_access_to_protected_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetUsersWithAccessToProtectedBranchWhen,
            operations::ReposGetUsersWithAccessToProtectedBranchThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetUsersWithAccessToProtectedBranchWhen::new(when),
                operations::ReposGetUsersWithAccessToProtectedBranchThen::new(then),
            )
        })
    }

    fn repos_set_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposSetUserAccessRestrictionsWhen,
            operations::ReposSetUserAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposSetUserAccessRestrictionsWhen::new(when),
                operations::ReposSetUserAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_add_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAddUserAccessRestrictionsWhen,
            operations::ReposAddUserAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAddUserAccessRestrictionsWhen::new(when),
                operations::ReposAddUserAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_remove_user_access_restrictions<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRemoveUserAccessRestrictionsWhen,
            operations::ReposRemoveUserAccessRestrictionsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveUserAccessRestrictionsWhen::new(when),
                operations::ReposRemoveUserAccessRestrictionsThen::new(then),
            )
        })
    }

    fn repos_rename_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRenameBranchWhen, operations::ReposRenameBranchThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRenameBranchWhen::new(when),
                operations::ReposRenameBranchThen::new(then),
            )
        })
    }

    fn checks_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksCreateWhen, operations::ChecksCreateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksCreateWhen::new(when),
                operations::ChecksCreateThen::new(then),
            )
        })
    }

    fn checks_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksGetWhen, operations::ChecksGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksGetWhen::new(when),
                operations::ChecksGetThen::new(then),
            )
        })
    }

    fn checks_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksUpdateWhen, operations::ChecksUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksUpdateWhen::new(when),
                operations::ChecksUpdateThen::new(then),
            )
        })
    }

    fn checks_list_annotations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListAnnotationsWhen, operations::ChecksListAnnotationsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksListAnnotationsWhen::new(when),
                operations::ChecksListAnnotationsThen::new(then),
            )
        })
    }

    fn checks_rerequest_run<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksRerequestRunWhen, operations::ChecksRerequestRunThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksRerequestRunWhen::new(when),
                operations::ChecksRerequestRunThen::new(then),
            )
        })
    }

    fn checks_create_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksCreateSuiteWhen, operations::ChecksCreateSuiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksCreateSuiteWhen::new(when),
                operations::ChecksCreateSuiteThen::new(then),
            )
        })
    }

    fn checks_set_suites_preferences<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ChecksSetSuitesPreferencesWhen,
            operations::ChecksSetSuitesPreferencesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksSetSuitesPreferencesWhen::new(when),
                operations::ChecksSetSuitesPreferencesThen::new(then),
            )
        })
    }

    fn checks_get_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksGetSuiteWhen, operations::ChecksGetSuiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksGetSuiteWhen::new(when),
                operations::ChecksGetSuiteThen::new(then),
            )
        })
    }

    fn checks_list_for_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListForSuiteWhen, operations::ChecksListForSuiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksListForSuiteWhen::new(when),
                operations::ChecksListForSuiteThen::new(then),
            )
        })
    }

    fn checks_rerequest_suite<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksRerequestSuiteWhen, operations::ChecksRerequestSuiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksRerequestSuiteWhen::new(when),
                operations::ChecksRerequestSuiteThen::new(then),
            )
        })
    }

    fn code_scanning_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertsForRepoWhen,
            operations::CodeScanningListAlertsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningListAlertsForRepoWhen::new(when),
                operations::CodeScanningListAlertsForRepoThen::new(then),
            )
        })
    }

    fn code_scanning_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetAlertWhen, operations::CodeScanningGetAlertThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningGetAlertWhen::new(when),
                operations::CodeScanningGetAlertThen::new(then),
            )
        })
    }

    fn code_scanning_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningUpdateAlertWhen, operations::CodeScanningUpdateAlertThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningUpdateAlertWhen::new(when),
                operations::CodeScanningUpdateAlertThen::new(then),
            )
        })
    }

    fn code_scanning_list_alert_instances<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListAlertInstancesWhen,
            operations::CodeScanningListAlertInstancesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningListAlertInstancesWhen::new(when),
                operations::CodeScanningListAlertInstancesThen::new(then),
            )
        })
    }

    fn code_scanning_list_recent_analyses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListRecentAnalysesWhen,
            operations::CodeScanningListRecentAnalysesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningListRecentAnalysesWhen::new(when),
                operations::CodeScanningListRecentAnalysesThen::new(then),
            )
        })
    }

    fn code_scanning_get_analysis<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetAnalysisWhen, operations::CodeScanningGetAnalysisThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningGetAnalysisWhen::new(when),
                operations::CodeScanningGetAnalysisThen::new(then),
            )
        })
    }

    fn code_scanning_delete_analysis<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningDeleteAnalysisWhen,
            operations::CodeScanningDeleteAnalysisThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningDeleteAnalysisWhen::new(when),
                operations::CodeScanningDeleteAnalysisThen::new(then),
            )
        })
    }

    fn code_scanning_list_codeql_databases<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningListCodeqlDatabasesWhen,
            operations::CodeScanningListCodeqlDatabasesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningListCodeqlDatabasesWhen::new(when),
                operations::CodeScanningListCodeqlDatabasesThen::new(then),
            )
        })
    }

    fn code_scanning_get_codeql_database<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningGetCodeqlDatabaseWhen,
            operations::CodeScanningGetCodeqlDatabaseThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningGetCodeqlDatabaseWhen::new(when),
                operations::CodeScanningGetCodeqlDatabaseThen::new(then),
            )
        })
    }

    fn code_scanning_get_default_setup<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningGetDefaultSetupWhen,
            operations::CodeScanningGetDefaultSetupThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningGetDefaultSetupWhen::new(when),
                operations::CodeScanningGetDefaultSetupThen::new(then),
            )
        })
    }

    fn code_scanning_update_default_setup<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodeScanningUpdateDefaultSetupWhen,
            operations::CodeScanningUpdateDefaultSetupThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningUpdateDefaultSetupWhen::new(when),
                operations::CodeScanningUpdateDefaultSetupThen::new(then),
            )
        })
    }

    fn code_scanning_upload_sarif<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningUploadSarifWhen, operations::CodeScanningUploadSarifThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningUploadSarifWhen::new(when),
                operations::CodeScanningUploadSarifThen::new(then),
            )
        })
    }

    fn code_scanning_get_sarif<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodeScanningGetSarifWhen, operations::CodeScanningGetSarifThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodeScanningGetSarifWhen::new(when),
                operations::CodeScanningGetSarifThen::new(then),
            )
        })
    }

    fn repos_codeowners_errors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCodeownersErrorsWhen, operations::ReposCodeownersErrorsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCodeownersErrorsWhen::new(when),
                operations::ReposCodeownersErrorsThen::new(then),
            )
        })
    }

    fn codespaces_list_in_repository_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListInRepositoryForAuthenticatedUserWhen,
            operations::CodespacesListInRepositoryForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListInRepositoryForAuthenticatedUserWhen::new(when),
                operations::CodespacesListInRepositoryForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_create_with_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateWithRepoForAuthenticatedUserWhen,
            operations::CodespacesCreateWithRepoForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateWithRepoForAuthenticatedUserWhen::new(when),
                operations::CodespacesCreateWithRepoForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_list_devcontainers_in_repository_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserWhen,
            operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserWhen::new(
                    when,
                ),
                operations::CodespacesListDevcontainersInRepositoryForAuthenticatedUserThen::new(
                    then,
                ),
            )
        })
    }

    fn codespaces_repo_machines_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRepoMachinesForAuthenticatedUserWhen,
            operations::CodespacesRepoMachinesForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesRepoMachinesForAuthenticatedUserWhen::new(when),
                operations::CodespacesRepoMachinesForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_pre_flight_with_repo_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesPreFlightWithRepoForAuthenticatedUserWhen,
            operations::CodespacesPreFlightWithRepoForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesPreFlightWithRepoForAuthenticatedUserWhen::new(when),
                operations::CodespacesPreFlightWithRepoForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListRepoSecretsWhen,
            operations::CodespacesListRepoSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListRepoSecretsWhen::new(when),
                operations::CodespacesListRepoSecretsThen::new(then),
            )
        })
    }

    fn codespaces_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetRepoPublicKeyWhen,
            operations::CodespacesGetRepoPublicKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetRepoPublicKeyWhen::new(when),
                operations::CodespacesGetRepoPublicKeyThen::new(then),
            )
        })
    }

    fn codespaces_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::CodespacesGetRepoSecretWhen, operations::CodespacesGetRepoSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetRepoSecretWhen::new(when),
                operations::CodespacesGetRepoSecretThen::new(then),
            )
        })
    }

    fn codespaces_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateRepoSecretWhen,
            operations::CodespacesCreateOrUpdateRepoSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateOrUpdateRepoSecretWhen::new(when),
                operations::CodespacesCreateOrUpdateRepoSecretThen::new(then),
            )
        })
    }

    fn codespaces_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteRepoSecretWhen,
            operations::CodespacesDeleteRepoSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteRepoSecretWhen::new(when),
                operations::CodespacesDeleteRepoSecretThen::new(then),
            )
        })
    }

    fn repos_list_collaborators<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListCollaboratorsWhen, operations::ReposListCollaboratorsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCollaboratorsWhen::new(when),
                operations::ReposListCollaboratorsThen::new(then),
            )
        })
    }

    fn repos_check_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCheckCollaboratorWhen, operations::ReposCheckCollaboratorThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCheckCollaboratorWhen::new(when),
                operations::ReposCheckCollaboratorThen::new(then),
            )
        })
    }

    fn repos_add_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposAddCollaboratorWhen, operations::ReposAddCollaboratorThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAddCollaboratorWhen::new(when),
                operations::ReposAddCollaboratorThen::new(then),
            )
        })
    }

    fn repos_remove_collaborator<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRemoveCollaboratorWhen, operations::ReposRemoveCollaboratorThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRemoveCollaboratorWhen::new(when),
                operations::ReposRemoveCollaboratorThen::new(then),
            )
        })
    }

    fn repos_get_collaborator_permission_level<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCollaboratorPermissionLevelWhen,
            operations::ReposGetCollaboratorPermissionLevelThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCollaboratorPermissionLevelWhen::new(when),
                operations::ReposGetCollaboratorPermissionLevelThen::new(then),
            )
        })
    }

    fn repos_list_commit_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommitCommentsForRepoWhen,
            operations::ReposListCommitCommentsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCommitCommentsForRepoWhen::new(when),
                operations::ReposListCommitCommentsForRepoThen::new(then),
            )
        })
    }

    fn repos_get_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetCommitCommentWhen, operations::ReposGetCommitCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCommitCommentWhen::new(when),
                operations::ReposGetCommitCommentThen::new(then),
            )
        })
    }

    fn repos_delete_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteCommitCommentWhen,
            operations::ReposDeleteCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteCommitCommentWhen::new(when),
                operations::ReposDeleteCommitCommentThen::new(then),
            )
        })
    }

    fn repos_update_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateCommitCommentWhen,
            operations::ReposUpdateCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateCommitCommentWhen::new(when),
                operations::ReposUpdateCommitCommentThen::new(then),
            )
        })
    }

    fn reactions_list_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForCommitCommentWhen,
            operations::ReactionsListForCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForCommitCommentWhen::new(when),
                operations::ReactionsListForCommitCommentThen::new(then),
            )
        })
    }

    fn reactions_create_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForCommitCommentWhen,
            operations::ReactionsCreateForCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForCommitCommentWhen::new(when),
                operations::ReactionsCreateForCommitCommentThen::new(then),
            )
        })
    }

    fn reactions_delete_for_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForCommitCommentWhen,
            operations::ReactionsDeleteForCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForCommitCommentWhen::new(when),
                operations::ReactionsDeleteForCommitCommentThen::new(then),
            )
        })
    }

    fn repos_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListCommitsWhen, operations::ReposListCommitsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCommitsWhen::new(when),
                operations::ReposListCommitsThen::new(then),
            )
        })
    }

    fn repos_list_branches_for_head_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListBranchesForHeadCommitWhen,
            operations::ReposListBranchesForHeadCommitThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListBranchesForHeadCommitWhen::new(when),
                operations::ReposListBranchesForHeadCommitThen::new(then),
            )
        })
    }

    fn repos_list_comments_for_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommentsForCommitWhen,
            operations::ReposListCommentsForCommitThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCommentsForCommitWhen::new(when),
                operations::ReposListCommentsForCommitThen::new(then),
            )
        })
    }

    fn repos_create_commit_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateCommitCommentWhen,
            operations::ReposCreateCommitCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateCommitCommentWhen::new(when),
                operations::ReposCreateCommitCommentThen::new(then),
            )
        })
    }

    fn repos_list_pull_requests_associated_with_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListPullRequestsAssociatedWithCommitWhen,
            operations::ReposListPullRequestsAssociatedWithCommitThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListPullRequestsAssociatedWithCommitWhen::new(when),
                operations::ReposListPullRequestsAssociatedWithCommitThen::new(then),
            )
        })
    }

    fn repos_get_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetCommitWhen, operations::ReposGetCommitThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCommitWhen::new(when),
                operations::ReposGetCommitThen::new(then),
            )
        })
    }

    fn checks_list_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListForRefWhen, operations::ChecksListForRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksListForRefWhen::new(when),
                operations::ChecksListForRefThen::new(then),
            )
        })
    }

    fn checks_list_suites_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ChecksListSuitesForRefWhen, operations::ChecksListSuitesForRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ChecksListSuitesForRefWhen::new(when),
                operations::ChecksListSuitesForRefThen::new(then),
            )
        })
    }

    fn repos_get_combined_status_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCombinedStatusForRefWhen,
            operations::ReposGetCombinedStatusForRefThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCombinedStatusForRefWhen::new(when),
                operations::ReposGetCombinedStatusForRefThen::new(then),
            )
        })
    }

    fn repos_list_commit_statuses_for_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCommitStatusesForRefWhen,
            operations::ReposListCommitStatusesForRefThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCommitStatusesForRefWhen::new(when),
                operations::ReposListCommitStatusesForRefThen::new(then),
            )
        })
    }

    fn repos_get_community_profile_metrics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommunityProfileMetricsWhen,
            operations::ReposGetCommunityProfileMetricsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCommunityProfileMetricsWhen::new(when),
                operations::ReposGetCommunityProfileMetricsThen::new(then),
            )
        })
    }

    fn repos_compare_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCompareCommitsWhen, operations::ReposCompareCommitsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCompareCommitsWhen::new(when),
                operations::ReposCompareCommitsThen::new(then),
            )
        })
    }

    fn repos_get_content<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetContentWhen, operations::ReposGetContentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetContentWhen::new(when),
                operations::ReposGetContentThen::new(then),
            )
        })
    }

    fn repos_create_or_update_file_contents<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateOrUpdateFileContentsWhen,
            operations::ReposCreateOrUpdateFileContentsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateOrUpdateFileContentsWhen::new(when),
                operations::ReposCreateOrUpdateFileContentsThen::new(then),
            )
        })
    }

    fn repos_delete_file<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteFileWhen, operations::ReposDeleteFileThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteFileWhen::new(when),
                operations::ReposDeleteFileThen::new(then),
            )
        })
    }

    fn repos_list_contributors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListContributorsWhen, operations::ReposListContributorsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListContributorsWhen::new(when),
                operations::ReposListContributorsThen::new(then),
            )
        })
    }

    fn dependabot_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListAlertsForRepoWhen,
            operations::DependabotListAlertsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListAlertsForRepoWhen::new(when),
                operations::DependabotListAlertsForRepoThen::new(then),
            )
        })
    }

    fn dependabot_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetAlertWhen, operations::DependabotGetAlertThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotGetAlertWhen::new(when),
                operations::DependabotGetAlertThen::new(then),
            )
        })
    }

    fn dependabot_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotUpdateAlertWhen, operations::DependabotUpdateAlertThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotUpdateAlertWhen::new(when),
                operations::DependabotUpdateAlertThen::new(then),
            )
        })
    }

    fn dependabot_list_repo_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotListRepoSecretsWhen,
            operations::DependabotListRepoSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotListRepoSecretsWhen::new(when),
                operations::DependabotListRepoSecretsThen::new(then),
            )
        })
    }

    fn dependabot_get_repo_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotGetRepoPublicKeyWhen,
            operations::DependabotGetRepoPublicKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotGetRepoPublicKeyWhen::new(when),
                operations::DependabotGetRepoPublicKeyThen::new(then),
            )
        })
    }

    fn dependabot_get_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::DependabotGetRepoSecretWhen, operations::DependabotGetRepoSecretThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotGetRepoSecretWhen::new(when),
                operations::DependabotGetRepoSecretThen::new(then),
            )
        })
    }

    fn dependabot_create_or_update_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotCreateOrUpdateRepoSecretWhen,
            operations::DependabotCreateOrUpdateRepoSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotCreateOrUpdateRepoSecretWhen::new(when),
                operations::DependabotCreateOrUpdateRepoSecretThen::new(then),
            )
        })
    }

    fn dependabot_delete_repo_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependabotDeleteRepoSecretWhen,
            operations::DependabotDeleteRepoSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependabotDeleteRepoSecretWhen::new(when),
                operations::DependabotDeleteRepoSecretThen::new(then),
            )
        })
    }

    fn dependency_graph_diff_range<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphDiffRangeWhen,
            operations::DependencyGraphDiffRangeThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependencyGraphDiffRangeWhen::new(when),
                operations::DependencyGraphDiffRangeThen::new(then),
            )
        })
    }

    fn dependency_graph_export_sbom<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphExportSbomWhen,
            operations::DependencyGraphExportSbomThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependencyGraphExportSbomWhen::new(when),
                operations::DependencyGraphExportSbomThen::new(then),
            )
        })
    }

    fn dependency_graph_create_repository_snapshot<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::DependencyGraphCreateRepositorySnapshotWhen,
            operations::DependencyGraphCreateRepositorySnapshotThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::DependencyGraphCreateRepositorySnapshotWhen::new(when),
                operations::DependencyGraphCreateRepositorySnapshotThen::new(then),
            )
        })
    }

    fn repos_list_deployments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListDeploymentsWhen, operations::ReposListDeploymentsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListDeploymentsWhen::new(when),
                operations::ReposListDeploymentsThen::new(then),
            )
        })
    }

    fn repos_create_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateDeploymentWhen, operations::ReposCreateDeploymentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDeploymentWhen::new(when),
                operations::ReposCreateDeploymentThen::new(then),
            )
        })
    }

    fn repos_get_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetDeploymentWhen, operations::ReposGetDeploymentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetDeploymentWhen::new(when),
                operations::ReposGetDeploymentThen::new(then),
            )
        })
    }

    fn repos_delete_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteDeploymentWhen, operations::ReposDeleteDeploymentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteDeploymentWhen::new(when),
                operations::ReposDeleteDeploymentThen::new(then),
            )
        })
    }

    fn repos_list_deployment_statuses<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListDeploymentStatusesWhen,
            operations::ReposListDeploymentStatusesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListDeploymentStatusesWhen::new(when),
                operations::ReposListDeploymentStatusesThen::new(then),
            )
        })
    }

    fn repos_create_deployment_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentStatusWhen,
            operations::ReposCreateDeploymentStatusThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDeploymentStatusWhen::new(when),
                operations::ReposCreateDeploymentStatusThen::new(then),
            )
        })
    }

    fn repos_get_deployment_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetDeploymentStatusWhen,
            operations::ReposGetDeploymentStatusThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetDeploymentStatusWhen::new(when),
                operations::ReposGetDeploymentStatusThen::new(then),
            )
        })
    }

    fn repos_create_dispatch_event<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDispatchEventWhen,
            operations::ReposCreateDispatchEventThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDispatchEventWhen::new(when),
                operations::ReposCreateDispatchEventThen::new(then),
            )
        })
    }

    fn repos_get_all_environments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAllEnvironmentsWhen, operations::ReposGetAllEnvironmentsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAllEnvironmentsWhen::new(when),
                operations::ReposGetAllEnvironmentsThen::new(then),
            )
        })
    }

    fn repos_get_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetEnvironmentWhen, operations::ReposGetEnvironmentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetEnvironmentWhen::new(when),
                operations::ReposGetEnvironmentThen::new(then),
            )
        })
    }

    fn repos_create_or_update_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateOrUpdateEnvironmentWhen,
            operations::ReposCreateOrUpdateEnvironmentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateOrUpdateEnvironmentWhen::new(when),
                operations::ReposCreateOrUpdateEnvironmentThen::new(then),
            )
        })
    }

    fn repos_delete_an_environment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteAnEnvironmentWhen,
            operations::ReposDeleteAnEnvironmentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteAnEnvironmentWhen::new(when),
                operations::ReposDeleteAnEnvironmentThen::new(then),
            )
        })
    }

    fn repos_list_deployment_branch_policies<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListDeploymentBranchPoliciesWhen,
            operations::ReposListDeploymentBranchPoliciesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListDeploymentBranchPoliciesWhen::new(when),
                operations::ReposListDeploymentBranchPoliciesThen::new(then),
            )
        })
    }

    fn repos_create_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentBranchPolicyWhen,
            operations::ReposCreateDeploymentBranchPolicyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDeploymentBranchPolicyWhen::new(when),
                operations::ReposCreateDeploymentBranchPolicyThen::new(then),
            )
        })
    }

    fn repos_get_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetDeploymentBranchPolicyWhen,
            operations::ReposGetDeploymentBranchPolicyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetDeploymentBranchPolicyWhen::new(when),
                operations::ReposGetDeploymentBranchPolicyThen::new(then),
            )
        })
    }

    fn repos_update_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateDeploymentBranchPolicyWhen,
            operations::ReposUpdateDeploymentBranchPolicyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateDeploymentBranchPolicyWhen::new(when),
                operations::ReposUpdateDeploymentBranchPolicyThen::new(then),
            )
        })
    }

    fn repos_delete_deployment_branch_policy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteDeploymentBranchPolicyWhen,
            operations::ReposDeleteDeploymentBranchPolicyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteDeploymentBranchPolicyWhen::new(when),
                operations::ReposDeleteDeploymentBranchPolicyThen::new(then),
            )
        })
    }

    fn repos_get_all_deployment_protection_rules<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetAllDeploymentProtectionRulesWhen,
            operations::ReposGetAllDeploymentProtectionRulesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAllDeploymentProtectionRulesWhen::new(when),
                operations::ReposGetAllDeploymentProtectionRulesThen::new(then),
            )
        })
    }

    fn repos_create_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateDeploymentProtectionRuleWhen,
            operations::ReposCreateDeploymentProtectionRuleThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDeploymentProtectionRuleWhen::new(when),
                operations::ReposCreateDeploymentProtectionRuleThen::new(then),
            )
        })
    }

    fn repos_list_custom_deployment_rule_integrations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListCustomDeploymentRuleIntegrationsWhen,
            operations::ReposListCustomDeploymentRuleIntegrationsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListCustomDeploymentRuleIntegrationsWhen::new(when),
                operations::ReposListCustomDeploymentRuleIntegrationsThen::new(then),
            )
        })
    }

    fn repos_get_custom_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCustomDeploymentProtectionRuleWhen,
            operations::ReposGetCustomDeploymentProtectionRuleThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCustomDeploymentProtectionRuleWhen::new(when),
                operations::ReposGetCustomDeploymentProtectionRuleThen::new(then),
            )
        })
    }

    fn repos_disable_deployment_protection_rule<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableDeploymentProtectionRuleWhen,
            operations::ReposDisableDeploymentProtectionRuleThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDisableDeploymentProtectionRuleWhen::new(when),
                operations::ReposDisableDeploymentProtectionRuleThen::new(then),
            )
        })
    }

    fn activity_list_repo_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ActivityListRepoEventsWhen, operations::ActivityListRepoEventsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListRepoEventsWhen::new(when),
                operations::ActivityListRepoEventsThen::new(then),
            )
        })
    }

    fn repos_list_forks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForksWhen, operations::ReposListForksThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListForksWhen::new(when),
                operations::ReposListForksThen::new(then),
            )
        })
    }

    fn repos_create_fork<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateForkWhen, operations::ReposCreateForkThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateForkWhen::new(when),
                operations::ReposCreateForkThen::new(then),
            )
        })
    }

    fn git_create_blob<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateBlobWhen, operations::GitCreateBlobThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitCreateBlobWhen::new(when),
                operations::GitCreateBlobThen::new(then),
            )
        })
    }

    fn git_get_blob<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetBlobWhen, operations::GitGetBlobThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitGetBlobWhen::new(when),
                operations::GitGetBlobThen::new(then),
            )
        })
    }

    fn git_create_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateCommitWhen, operations::GitCreateCommitThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitCreateCommitWhen::new(when),
                operations::GitCreateCommitThen::new(then),
            )
        })
    }

    fn git_get_commit<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetCommitWhen, operations::GitGetCommitThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitGetCommitWhen::new(when),
                operations::GitGetCommitThen::new(then),
            )
        })
    }

    fn git_list_matching_refs<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitListMatchingRefsWhen, operations::GitListMatchingRefsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitListMatchingRefsWhen::new(when),
                operations::GitListMatchingRefsThen::new(then),
            )
        })
    }

    fn git_get_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetRefWhen, operations::GitGetRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitGetRefWhen::new(when),
                operations::GitGetRefThen::new(then),
            )
        })
    }

    fn git_create_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateRefWhen, operations::GitCreateRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitCreateRefWhen::new(when),
                operations::GitCreateRefThen::new(then),
            )
        })
    }

    fn git_delete_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitDeleteRefWhen, operations::GitDeleteRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitDeleteRefWhen::new(when),
                operations::GitDeleteRefThen::new(then),
            )
        })
    }

    fn git_update_ref<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitUpdateRefWhen, operations::GitUpdateRefThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitUpdateRefWhen::new(when),
                operations::GitUpdateRefThen::new(then),
            )
        })
    }

    fn git_create_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateTagWhen, operations::GitCreateTagThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitCreateTagWhen::new(when),
                operations::GitCreateTagThen::new(then),
            )
        })
    }

    fn git_get_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetTagWhen, operations::GitGetTagThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitGetTagWhen::new(when),
                operations::GitGetTagThen::new(then),
            )
        })
    }

    fn git_create_tree<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitCreateTreeWhen, operations::GitCreateTreeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitCreateTreeWhen::new(when),
                operations::GitCreateTreeThen::new(then),
            )
        })
    }

    fn git_get_tree<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GitGetTreeWhen, operations::GitGetTreeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GitGetTreeWhen::new(when),
                operations::GitGetTreeThen::new(then),
            )
        })
    }

    fn repos_list_webhooks<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListWebhooksWhen, operations::ReposListWebhooksThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListWebhooksWhen::new(when),
                operations::ReposListWebhooksThen::new(then),
            )
        })
    }

    fn repos_create_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateWebhookWhen, operations::ReposCreateWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateWebhookWhen::new(when),
                operations::ReposCreateWebhookThen::new(then),
            )
        })
    }

    fn repos_get_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWebhookWhen, operations::ReposGetWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetWebhookWhen::new(when),
                operations::ReposGetWebhookThen::new(then),
            )
        })
    }

    fn repos_delete_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteWebhookWhen, operations::ReposDeleteWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteWebhookWhen::new(when),
                operations::ReposDeleteWebhookThen::new(then),
            )
        })
    }

    fn repos_update_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateWebhookWhen, operations::ReposUpdateWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateWebhookWhen::new(when),
                operations::ReposUpdateWebhookThen::new(then),
            )
        })
    }

    fn repos_get_webhook_config_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetWebhookConfigForRepoWhen,
            operations::ReposGetWebhookConfigForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetWebhookConfigForRepoWhen::new(when),
                operations::ReposGetWebhookConfigForRepoThen::new(then),
            )
        })
    }

    fn repos_update_webhook_config_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateWebhookConfigForRepoWhen,
            operations::ReposUpdateWebhookConfigForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateWebhookConfigForRepoWhen::new(when),
                operations::ReposUpdateWebhookConfigForRepoThen::new(then),
            )
        })
    }

    fn repos_list_webhook_deliveries<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListWebhookDeliveriesWhen,
            operations::ReposListWebhookDeliveriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListWebhookDeliveriesWhen::new(when),
                operations::ReposListWebhookDeliveriesThen::new(then),
            )
        })
    }

    fn repos_get_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetWebhookDeliveryWhen, operations::ReposGetWebhookDeliveryThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetWebhookDeliveryWhen::new(when),
                operations::ReposGetWebhookDeliveryThen::new(then),
            )
        })
    }

    fn repos_redeliver_webhook_delivery<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposRedeliverWebhookDeliveryWhen,
            operations::ReposRedeliverWebhookDeliveryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRedeliverWebhookDeliveryWhen::new(when),
                operations::ReposRedeliverWebhookDeliveryThen::new(then),
            )
        })
    }

    fn repos_ping_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposPingWebhookWhen, operations::ReposPingWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposPingWebhookWhen::new(when),
                operations::ReposPingWebhookThen::new(then),
            )
        })
    }

    fn repos_test_push_webhook<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposTestPushWebhookWhen, operations::ReposTestPushWebhookThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposTestPushWebhookWhen::new(when),
                operations::ReposTestPushWebhookThen::new(then),
            )
        })
    }

    fn migrations_get_import_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetImportStatusWhen,
            operations::MigrationsGetImportStatusThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetImportStatusWhen::new(when),
                operations::MigrationsGetImportStatusThen::new(then),
            )
        })
    }

    fn migrations_start_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsStartImportWhen, operations::MigrationsStartImportThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsStartImportWhen::new(when),
                operations::MigrationsStartImportThen::new(then),
            )
        })
    }

    fn migrations_cancel_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsCancelImportWhen, operations::MigrationsCancelImportThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsCancelImportWhen::new(when),
                operations::MigrationsCancelImportThen::new(then),
            )
        })
    }

    fn migrations_update_import<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsUpdateImportWhen, operations::MigrationsUpdateImportThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsUpdateImportWhen::new(when),
                operations::MigrationsUpdateImportThen::new(then),
            )
        })
    }

    fn migrations_get_commit_authors<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetCommitAuthorsWhen,
            operations::MigrationsGetCommitAuthorsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetCommitAuthorsWhen::new(when),
                operations::MigrationsGetCommitAuthorsThen::new(then),
            )
        })
    }

    fn migrations_map_commit_author<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsMapCommitAuthorWhen,
            operations::MigrationsMapCommitAuthorThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsMapCommitAuthorWhen::new(when),
                operations::MigrationsMapCommitAuthorThen::new(then),
            )
        })
    }

    fn migrations_get_large_files<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::MigrationsGetLargeFilesWhen, operations::MigrationsGetLargeFilesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetLargeFilesWhen::new(when),
                operations::MigrationsGetLargeFilesThen::new(then),
            )
        })
    }

    fn migrations_set_lfs_preference<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsSetLfsPreferenceWhen,
            operations::MigrationsSetLfsPreferenceThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsSetLfsPreferenceWhen::new(when),
                operations::MigrationsSetLfsPreferenceThen::new(then),
            )
        })
    }

    fn apps_get_repo_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetRepoInstallationWhen, operations::AppsGetRepoInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetRepoInstallationWhen::new(when),
                operations::AppsGetRepoInstallationThen::new(then),
            )
        })
    }

    fn interactions_get_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForRepoWhen,
            operations::InteractionsGetRestrictionsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsGetRestrictionsForRepoWhen::new(when),
                operations::InteractionsGetRestrictionsForRepoThen::new(then),
            )
        })
    }

    fn interactions_set_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForRepoWhen,
            operations::InteractionsSetRestrictionsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsSetRestrictionsForRepoWhen::new(when),
                operations::InteractionsSetRestrictionsForRepoThen::new(then),
            )
        })
    }

    fn interactions_remove_restrictions_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForRepoWhen,
            operations::InteractionsRemoveRestrictionsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsRemoveRestrictionsForRepoWhen::new(when),
                operations::InteractionsRemoveRestrictionsForRepoThen::new(then),
            )
        })
    }

    fn repos_list_invitations<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListInvitationsWhen, operations::ReposListInvitationsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListInvitationsWhen::new(when),
                operations::ReposListInvitationsThen::new(then),
            )
        })
    }

    fn repos_delete_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteInvitationWhen, operations::ReposDeleteInvitationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteInvitationWhen::new(when),
                operations::ReposDeleteInvitationThen::new(then),
            )
        })
    }

    fn repos_update_invitation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateInvitationWhen, operations::ReposUpdateInvitationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateInvitationWhen::new(when),
                operations::ReposUpdateInvitationThen::new(then),
            )
        })
    }

    fn issues_list_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListForRepoWhen, operations::IssuesListForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListForRepoWhen::new(when),
                operations::IssuesListForRepoThen::new(then),
            )
        })
    }

    fn issues_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateWhen, operations::IssuesCreateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCreateWhen::new(when),
                operations::IssuesCreateThen::new(then),
            )
        })
    }

    fn issues_list_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListCommentsForRepoWhen,
            operations::IssuesListCommentsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListCommentsForRepoWhen::new(when),
                operations::IssuesListCommentsForRepoThen::new(then),
            )
        })
    }

    fn issues_get_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetCommentWhen, operations::IssuesGetCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesGetCommentWhen::new(when),
                operations::IssuesGetCommentThen::new(then),
            )
        })
    }

    fn issues_delete_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteCommentWhen, operations::IssuesDeleteCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesDeleteCommentWhen::new(when),
                operations::IssuesDeleteCommentThen::new(then),
            )
        })
    }

    fn issues_update_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateCommentWhen, operations::IssuesUpdateCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesUpdateCommentWhen::new(when),
                operations::IssuesUpdateCommentThen::new(then),
            )
        })
    }

    fn reactions_list_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForIssueCommentWhen,
            operations::ReactionsListForIssueCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForIssueCommentWhen::new(when),
                operations::ReactionsListForIssueCommentThen::new(then),
            )
        })
    }

    fn reactions_create_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForIssueCommentWhen,
            operations::ReactionsCreateForIssueCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForIssueCommentWhen::new(when),
                operations::ReactionsCreateForIssueCommentThen::new(then),
            )
        })
    }

    fn reactions_delete_for_issue_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForIssueCommentWhen,
            operations::ReactionsDeleteForIssueCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForIssueCommentWhen::new(when),
                operations::ReactionsDeleteForIssueCommentThen::new(then),
            )
        })
    }

    fn issues_list_events_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListEventsForRepoWhen, operations::IssuesListEventsForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListEventsForRepoWhen::new(when),
                operations::IssuesListEventsForRepoThen::new(then),
            )
        })
    }

    fn issues_get_event<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetEventWhen, operations::IssuesGetEventThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesGetEventWhen::new(when),
                operations::IssuesGetEventThen::new(then),
            )
        })
    }

    fn issues_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetWhen, operations::IssuesGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesGetWhen::new(when),
                operations::IssuesGetThen::new(then),
            )
        })
    }

    fn issues_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateWhen, operations::IssuesUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesUpdateWhen::new(when),
                operations::IssuesUpdateThen::new(then),
            )
        })
    }

    fn issues_add_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesAddAssigneesWhen, operations::IssuesAddAssigneesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesAddAssigneesWhen::new(when),
                operations::IssuesAddAssigneesThen::new(then),
            )
        })
    }

    fn issues_remove_assignees<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveAssigneesWhen, operations::IssuesRemoveAssigneesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesRemoveAssigneesWhen::new(when),
                operations::IssuesRemoveAssigneesThen::new(then),
            )
        })
    }

    fn issues_check_user_can_be_assigned_to_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesCheckUserCanBeAssignedToIssueWhen,
            operations::IssuesCheckUserCanBeAssignedToIssueThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCheckUserCanBeAssignedToIssueWhen::new(when),
                operations::IssuesCheckUserCanBeAssignedToIssueThen::new(then),
            )
        })
    }

    fn issues_list_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListCommentsWhen, operations::IssuesListCommentsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListCommentsWhen::new(when),
                operations::IssuesListCommentsThen::new(then),
            )
        })
    }

    fn issues_create_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateCommentWhen, operations::IssuesCreateCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCreateCommentWhen::new(when),
                operations::IssuesCreateCommentThen::new(then),
            )
        })
    }

    fn issues_list_events<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListEventsWhen, operations::IssuesListEventsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListEventsWhen::new(when),
                operations::IssuesListEventsThen::new(then),
            )
        })
    }

    fn issues_list_labels_on_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListLabelsOnIssueWhen, operations::IssuesListLabelsOnIssueThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListLabelsOnIssueWhen::new(when),
                operations::IssuesListLabelsOnIssueThen::new(then),
            )
        })
    }

    fn issues_set_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesSetLabelsWhen, operations::IssuesSetLabelsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesSetLabelsWhen::new(when),
                operations::IssuesSetLabelsThen::new(then),
            )
        })
    }

    fn issues_add_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesAddLabelsWhen, operations::IssuesAddLabelsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesAddLabelsWhen::new(when),
                operations::IssuesAddLabelsThen::new(then),
            )
        })
    }

    fn issues_remove_all_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveAllLabelsWhen, operations::IssuesRemoveAllLabelsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesRemoveAllLabelsWhen::new(when),
                operations::IssuesRemoveAllLabelsThen::new(then),
            )
        })
    }

    fn issues_remove_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesRemoveLabelWhen, operations::IssuesRemoveLabelThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesRemoveLabelWhen::new(when),
                operations::IssuesRemoveLabelThen::new(then),
            )
        })
    }

    fn issues_lock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesLockWhen, operations::IssuesLockThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesLockWhen::new(when),
                operations::IssuesLockThen::new(then),
            )
        })
    }

    fn issues_unlock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUnlockWhen, operations::IssuesUnlockThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesUnlockWhen::new(when),
                operations::IssuesUnlockThen::new(then),
            )
        })
    }

    fn reactions_list_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsListForIssueWhen, operations::ReactionsListForIssueThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForIssueWhen::new(when),
                operations::ReactionsListForIssueThen::new(then),
            )
        })
    }

    fn reactions_create_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsCreateForIssueWhen, operations::ReactionsCreateForIssueThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForIssueWhen::new(when),
                operations::ReactionsCreateForIssueThen::new(then),
            )
        })
    }

    fn reactions_delete_for_issue<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsDeleteForIssueWhen, operations::ReactionsDeleteForIssueThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForIssueWhen::new(when),
                operations::ReactionsDeleteForIssueThen::new(then),
            )
        })
    }

    fn issues_list_events_for_timeline<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListEventsForTimelineWhen,
            operations::IssuesListEventsForTimelineThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListEventsForTimelineWhen::new(when),
                operations::IssuesListEventsForTimelineThen::new(then),
            )
        })
    }

    fn repos_list_deploy_keys<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListDeployKeysWhen, operations::ReposListDeployKeysThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListDeployKeysWhen::new(when),
                operations::ReposListDeployKeysThen::new(then),
            )
        })
    }

    fn repos_create_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateDeployKeyWhen, operations::ReposCreateDeployKeyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateDeployKeyWhen::new(when),
                operations::ReposCreateDeployKeyThen::new(then),
            )
        })
    }

    fn repos_get_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetDeployKeyWhen, operations::ReposGetDeployKeyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetDeployKeyWhen::new(when),
                operations::ReposGetDeployKeyThen::new(then),
            )
        })
    }

    fn repos_delete_deploy_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteDeployKeyWhen, operations::ReposDeleteDeployKeyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteDeployKeyWhen::new(when),
                operations::ReposDeleteDeployKeyThen::new(then),
            )
        })
    }

    fn issues_list_labels_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListLabelsForRepoWhen, operations::IssuesListLabelsForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListLabelsForRepoWhen::new(when),
                operations::IssuesListLabelsForRepoThen::new(then),
            )
        })
    }

    fn issues_create_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateLabelWhen, operations::IssuesCreateLabelThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCreateLabelWhen::new(when),
                operations::IssuesCreateLabelThen::new(then),
            )
        })
    }

    fn issues_get_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetLabelWhen, operations::IssuesGetLabelThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesGetLabelWhen::new(when),
                operations::IssuesGetLabelThen::new(then),
            )
        })
    }

    fn issues_delete_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteLabelWhen, operations::IssuesDeleteLabelThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesDeleteLabelWhen::new(when),
                operations::IssuesDeleteLabelThen::new(then),
            )
        })
    }

    fn issues_update_label<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateLabelWhen, operations::IssuesUpdateLabelThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesUpdateLabelWhen::new(when),
                operations::IssuesUpdateLabelThen::new(then),
            )
        })
    }

    fn repos_list_languages<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListLanguagesWhen, operations::ReposListLanguagesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListLanguagesWhen::new(when),
                operations::ReposListLanguagesThen::new(then),
            )
        })
    }

    fn repos_enable_lfs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposEnableLfsForRepoWhen, operations::ReposEnableLfsForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposEnableLfsForRepoWhen::new(when),
                operations::ReposEnableLfsForRepoThen::new(then),
            )
        })
    }

    fn repos_disable_lfs_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDisableLfsForRepoWhen, operations::ReposDisableLfsForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDisableLfsForRepoWhen::new(when),
                operations::ReposDisableLfsForRepoThen::new(then),
            )
        })
    }

    fn licenses_get_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::LicensesGetForRepoWhen, operations::LicensesGetForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::LicensesGetForRepoWhen::new(when),
                operations::LicensesGetForRepoThen::new(then),
            )
        })
    }

    fn repos_merge_upstream<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposMergeUpstreamWhen, operations::ReposMergeUpstreamThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposMergeUpstreamWhen::new(when),
                operations::ReposMergeUpstreamThen::new(then),
            )
        })
    }

    fn repos_merge<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposMergeWhen, operations::ReposMergeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposMergeWhen::new(when),
                operations::ReposMergeThen::new(then),
            )
        })
    }

    fn issues_list_milestones<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesListMilestonesWhen, operations::IssuesListMilestonesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListMilestonesWhen::new(when),
                operations::IssuesListMilestonesThen::new(then),
            )
        })
    }

    fn issues_create_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesCreateMilestoneWhen, operations::IssuesCreateMilestoneThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesCreateMilestoneWhen::new(when),
                operations::IssuesCreateMilestoneThen::new(then),
            )
        })
    }

    fn issues_get_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesGetMilestoneWhen, operations::IssuesGetMilestoneThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesGetMilestoneWhen::new(when),
                operations::IssuesGetMilestoneThen::new(then),
            )
        })
    }

    fn issues_delete_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesDeleteMilestoneWhen, operations::IssuesDeleteMilestoneThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesDeleteMilestoneWhen::new(when),
                operations::IssuesDeleteMilestoneThen::new(then),
            )
        })
    }

    fn issues_update_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::IssuesUpdateMilestoneWhen, operations::IssuesUpdateMilestoneThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesUpdateMilestoneWhen::new(when),
                operations::IssuesUpdateMilestoneThen::new(then),
            )
        })
    }

    fn issues_list_labels_for_milestone<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListLabelsForMilestoneWhen,
            operations::IssuesListLabelsForMilestoneThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListLabelsForMilestoneWhen::new(when),
                operations::IssuesListLabelsForMilestoneThen::new(then),
            )
        })
    }

    fn activity_list_repo_notifications_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListRepoNotificationsForAuthenticatedUserWhen,
            operations::ActivityListRepoNotificationsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListRepoNotificationsForAuthenticatedUserWhen::new(when),
                operations::ActivityListRepoNotificationsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_mark_repo_notifications_as_read<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityMarkRepoNotificationsAsReadWhen,
            operations::ActivityMarkRepoNotificationsAsReadThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityMarkRepoNotificationsAsReadWhen::new(when),
                operations::ActivityMarkRepoNotificationsAsReadThen::new(then),
            )
        })
    }

    fn repos_get_pages<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPagesWhen, operations::ReposGetPagesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetPagesWhen::new(when),
                operations::ReposGetPagesThen::new(then),
            )
        })
    }

    fn repos_update_information_about_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposUpdateInformationAboutPagesSiteWhen,
            operations::ReposUpdateInformationAboutPagesSiteThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateInformationAboutPagesSiteWhen::new(when),
                operations::ReposUpdateInformationAboutPagesSiteThen::new(then),
            )
        })
    }

    fn repos_create_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreatePagesSiteWhen, operations::ReposCreatePagesSiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreatePagesSiteWhen::new(when),
                operations::ReposCreatePagesSiteThen::new(then),
            )
        })
    }

    fn repos_delete_pages_site<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeletePagesSiteWhen, operations::ReposDeletePagesSiteThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeletePagesSiteWhen::new(when),
                operations::ReposDeletePagesSiteThen::new(then),
            )
        })
    }

    fn repos_list_pages_builds<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListPagesBuildsWhen, operations::ReposListPagesBuildsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListPagesBuildsWhen::new(when),
                operations::ReposListPagesBuildsThen::new(then),
            )
        })
    }

    fn repos_request_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposRequestPagesBuildWhen, operations::ReposRequestPagesBuildThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposRequestPagesBuildWhen::new(when),
                operations::ReposRequestPagesBuildThen::new(then),
            )
        })
    }

    fn repos_get_latest_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetLatestPagesBuildWhen,
            operations::ReposGetLatestPagesBuildThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetLatestPagesBuildWhen::new(when),
                operations::ReposGetLatestPagesBuildThen::new(then),
            )
        })
    }

    fn repos_get_pages_build<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPagesBuildWhen, operations::ReposGetPagesBuildThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetPagesBuildWhen::new(when),
                operations::ReposGetPagesBuildThen::new(then),
            )
        })
    }

    fn repos_create_pages_deployment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreatePagesDeploymentWhen,
            operations::ReposCreatePagesDeploymentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreatePagesDeploymentWhen::new(when),
                operations::ReposCreatePagesDeploymentThen::new(then),
            )
        })
    }

    fn repos_get_pages_health_check<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetPagesHealthCheckWhen,
            operations::ReposGetPagesHealthCheckThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetPagesHealthCheckWhen::new(when),
                operations::ReposGetPagesHealthCheckThen::new(then),
            )
        })
    }

    fn projects_list_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForRepoWhen, operations::ProjectsListForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsListForRepoWhen::new(when),
                operations::ProjectsListForRepoThen::new(then),
            )
        })
    }

    fn projects_create_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsCreateForRepoWhen, operations::ProjectsCreateForRepoThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsCreateForRepoWhen::new(when),
                operations::ProjectsCreateForRepoThen::new(then),
            )
        })
    }

    fn pulls_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListWhen, operations::PullsListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListWhen::new(when),
                operations::PullsListThen::new(then),
            )
        })
    }

    fn pulls_create<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCreateWhen, operations::PullsCreateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsCreateWhen::new(when),
                operations::PullsCreateThen::new(then),
            )
        })
    }

    fn pulls_list_review_comments_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListReviewCommentsForRepoWhen,
            operations::PullsListReviewCommentsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListReviewCommentsForRepoWhen::new(when),
                operations::PullsListReviewCommentsForRepoThen::new(then),
            )
        })
    }

    fn pulls_get_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetReviewCommentWhen, operations::PullsGetReviewCommentThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsGetReviewCommentWhen::new(when),
                operations::PullsGetReviewCommentThen::new(then),
            )
        })
    }

    fn pulls_delete_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsDeleteReviewCommentWhen,
            operations::PullsDeleteReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsDeleteReviewCommentWhen::new(when),
                operations::PullsDeleteReviewCommentThen::new(then),
            )
        })
    }

    fn pulls_update_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsUpdateReviewCommentWhen,
            operations::PullsUpdateReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsUpdateReviewCommentWhen::new(when),
                operations::PullsUpdateReviewCommentThen::new(then),
            )
        })
    }

    fn reactions_list_for_pull_request_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForPullRequestReviewCommentWhen,
            operations::ReactionsListForPullRequestReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForPullRequestReviewCommentWhen::new(when),
                operations::ReactionsListForPullRequestReviewCommentThen::new(then),
            )
        })
    }

    fn reactions_create_for_pull_request_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForPullRequestReviewCommentWhen,
            operations::ReactionsCreateForPullRequestReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForPullRequestReviewCommentWhen::new(when),
                operations::ReactionsCreateForPullRequestReviewCommentThen::new(then),
            )
        })
    }

    fn reactions_delete_for_pull_request_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForPullRequestCommentWhen,
            operations::ReactionsDeleteForPullRequestCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForPullRequestCommentWhen::new(when),
                operations::ReactionsDeleteForPullRequestCommentThen::new(then),
            )
        })
    }

    fn pulls_get<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetWhen, operations::PullsGetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsGetWhen::new(when),
                operations::PullsGetThen::new(then),
            )
        })
    }

    fn pulls_update<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateWhen, operations::PullsUpdateThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsUpdateWhen::new(when),
                operations::PullsUpdateThen::new(then),
            )
        })
    }

    fn codespaces_create_with_pr_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateWithPrForAuthenticatedUserWhen,
            operations::CodespacesCreateWithPrForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateWithPrForAuthenticatedUserWhen::new(when),
                operations::CodespacesCreateWithPrForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn pulls_list_review_comments<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListReviewCommentsWhen, operations::PullsListReviewCommentsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListReviewCommentsWhen::new(when),
                operations::PullsListReviewCommentsThen::new(then),
            )
        })
    }

    fn pulls_create_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsCreateReviewCommentWhen,
            operations::PullsCreateReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsCreateReviewCommentWhen::new(when),
                operations::PullsCreateReviewCommentThen::new(then),
            )
        })
    }

    fn pulls_create_reply_for_review_comment<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsCreateReplyForReviewCommentWhen,
            operations::PullsCreateReplyForReviewCommentThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsCreateReplyForReviewCommentWhen::new(when),
                operations::PullsCreateReplyForReviewCommentThen::new(then),
            )
        })
    }

    fn pulls_list_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListCommitsWhen, operations::PullsListCommitsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListCommitsWhen::new(when),
                operations::PullsListCommitsThen::new(then),
            )
        })
    }

    fn pulls_list_files<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListFilesWhen, operations::PullsListFilesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListFilesWhen::new(when),
                operations::PullsListFilesThen::new(then),
            )
        })
    }

    fn pulls_check_if_merged<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCheckIfMergedWhen, operations::PullsCheckIfMergedThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsCheckIfMergedWhen::new(when),
                operations::PullsCheckIfMergedThen::new(then),
            )
        })
    }

    fn pulls_merge<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsMergeWhen, operations::PullsMergeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsMergeWhen::new(when),
                operations::PullsMergeThen::new(then),
            )
        })
    }

    fn pulls_list_requested_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListRequestedReviewersWhen,
            operations::PullsListRequestedReviewersThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListRequestedReviewersWhen::new(when),
                operations::PullsListRequestedReviewersThen::new(then),
            )
        })
    }

    fn pulls_request_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsRequestReviewersWhen, operations::PullsRequestReviewersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsRequestReviewersWhen::new(when),
                operations::PullsRequestReviewersThen::new(then),
            )
        })
    }

    fn pulls_remove_requested_reviewers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsRemoveRequestedReviewersWhen,
            operations::PullsRemoveRequestedReviewersThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsRemoveRequestedReviewersWhen::new(when),
                operations::PullsRemoveRequestedReviewersThen::new(then),
            )
        })
    }

    fn pulls_list_reviews<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsListReviewsWhen, operations::PullsListReviewsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListReviewsWhen::new(when),
                operations::PullsListReviewsThen::new(then),
            )
        })
    }

    fn pulls_create_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsCreateReviewWhen, operations::PullsCreateReviewThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsCreateReviewWhen::new(when),
                operations::PullsCreateReviewThen::new(then),
            )
        })
    }

    fn pulls_get_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsGetReviewWhen, operations::PullsGetReviewThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsGetReviewWhen::new(when),
                operations::PullsGetReviewThen::new(then),
            )
        })
    }

    fn pulls_update_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateReviewWhen, operations::PullsUpdateReviewThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsUpdateReviewWhen::new(when),
                operations::PullsUpdateReviewThen::new(then),
            )
        })
    }

    fn pulls_delete_pending_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsDeletePendingReviewWhen,
            operations::PullsDeletePendingReviewThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsDeletePendingReviewWhen::new(when),
                operations::PullsDeletePendingReviewThen::new(then),
            )
        })
    }

    fn pulls_list_comments_for_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PullsListCommentsForReviewWhen,
            operations::PullsListCommentsForReviewThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsListCommentsForReviewWhen::new(when),
                operations::PullsListCommentsForReviewThen::new(then),
            )
        })
    }

    fn pulls_dismiss_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsDismissReviewWhen, operations::PullsDismissReviewThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsDismissReviewWhen::new(when),
                operations::PullsDismissReviewThen::new(then),
            )
        })
    }

    fn pulls_submit_review<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsSubmitReviewWhen, operations::PullsSubmitReviewThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsSubmitReviewWhen::new(when),
                operations::PullsSubmitReviewThen::new(then),
            )
        })
    }

    fn pulls_update_branch<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::PullsUpdateBranchWhen, operations::PullsUpdateBranchThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PullsUpdateBranchWhen::new(when),
                operations::PullsUpdateBranchThen::new(then),
            )
        })
    }

    fn repos_get_readme<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReadmeWhen, operations::ReposGetReadmeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetReadmeWhen::new(when),
                operations::ReposGetReadmeThen::new(then),
            )
        })
    }

    fn repos_get_readme_in_directory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetReadmeInDirectoryWhen,
            operations::ReposGetReadmeInDirectoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetReadmeInDirectoryWhen::new(when),
                operations::ReposGetReadmeInDirectoryThen::new(then),
            )
        })
    }

    fn activity_list_repos_watched_by_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposWatchedByUserWhen,
            operations::ActivityListReposWatchedByUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListReposWatchedByUserWhen::new(when),
                operations::ActivityListReposWatchedByUserThen::new(then),
            )
        })
    }

    fn repos_get_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReleaseAssetWhen, operations::ReposGetReleaseAssetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetReleaseAssetWhen::new(when),
                operations::ReposGetReleaseAssetThen::new(then),
            )
        })
    }

    fn repos_delete_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteReleaseAssetWhen, operations::ReposDeleteReleaseAssetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteReleaseAssetWhen::new(when),
                operations::ReposDeleteReleaseAssetThen::new(then),
            )
        })
    }

    fn repos_update_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateReleaseAssetWhen, operations::ReposUpdateReleaseAssetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateReleaseAssetWhen::new(when),
                operations::ReposUpdateReleaseAssetThen::new(then),
            )
        })
    }

    fn repos_generate_release_notes<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGenerateReleaseNotesWhen,
            operations::ReposGenerateReleaseNotesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGenerateReleaseNotesWhen::new(when),
                operations::ReposGenerateReleaseNotesThen::new(then),
            )
        })
    }

    fn repos_get_latest_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetLatestReleaseWhen, operations::ReposGetLatestReleaseThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetLatestReleaseWhen::new(when),
                operations::ReposGetLatestReleaseThen::new(then),
            )
        })
    }

    fn repos_get_release_by_tag<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetReleaseByTagWhen, operations::ReposGetReleaseByTagThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetReleaseByTagWhen::new(when),
                operations::ReposGetReleaseByTagThen::new(then),
            )
        })
    }

    fn activity_list_repos_starred_by_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposStarredByUserWhen,
            operations::ActivityListReposStarredByUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListReposStarredByUserWhen::new(when),
                operations::ActivityListReposStarredByUserThen::new(then),
            )
        })
    }

    fn repos_list_release_assets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListReleaseAssetsWhen, operations::ReposListReleaseAssetsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListReleaseAssetsWhen::new(when),
                operations::ReposListReleaseAssetsThen::new(then),
            )
        })
    }

    fn repos_upload_release_asset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUploadReleaseAssetWhen, operations::ReposUploadReleaseAssetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUploadReleaseAssetWhen::new(when),
                operations::ReposUploadReleaseAssetThen::new(then),
            )
        })
    }

    fn reactions_list_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReactionsListForReleaseWhen, operations::ReactionsListForReleaseThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForReleaseWhen::new(when),
                operations::ReactionsListForReleaseThen::new(then),
            )
        })
    }

    fn reactions_create_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForReleaseWhen,
            operations::ReactionsCreateForReleaseThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForReleaseWhen::new(when),
                operations::ReactionsCreateForReleaseThen::new(then),
            )
        })
    }

    fn reactions_delete_for_release<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsDeleteForReleaseWhen,
            operations::ReactionsDeleteForReleaseThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsDeleteForReleaseWhen::new(when),
                operations::ReactionsDeleteForReleaseThen::new(then),
            )
        })
    }

    fn repos_get_branch_rules<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetBranchRulesWhen, operations::ReposGetBranchRulesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetBranchRulesWhen::new(when),
                operations::ReposGetBranchRulesThen::new(then),
            )
        })
    }

    fn repos_get_repo_rulesets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetRepoRulesetsWhen, operations::ReposGetRepoRulesetsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetRepoRulesetsWhen::new(when),
                operations::ReposGetRepoRulesetsThen::new(then),
            )
        })
    }

    fn repos_create_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateRepoRulesetWhen, operations::ReposCreateRepoRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateRepoRulesetWhen::new(when),
                operations::ReposCreateRepoRulesetThen::new(then),
            )
        })
    }

    fn repos_get_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetRepoRulesetWhen, operations::ReposGetRepoRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetRepoRulesetWhen::new(when),
                operations::ReposGetRepoRulesetThen::new(then),
            )
        })
    }

    fn repos_update_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposUpdateRepoRulesetWhen, operations::ReposUpdateRepoRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposUpdateRepoRulesetWhen::new(when),
                operations::ReposUpdateRepoRulesetThen::new(then),
            )
        })
    }

    fn repos_delete_repo_ruleset<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposDeleteRepoRulesetWhen, operations::ReposDeleteRepoRulesetThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteRepoRulesetWhen::new(when),
                operations::ReposDeleteRepoRulesetThen::new(then),
            )
        })
    }

    fn secret_scanning_list_alerts_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListAlertsForRepoWhen,
            operations::SecretScanningListAlertsForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningListAlertsForRepoWhen::new(when),
                operations::SecretScanningListAlertsForRepoThen::new(then),
            )
        })
    }

    fn secret_scanning_get_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SecretScanningGetAlertWhen, operations::SecretScanningGetAlertThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningGetAlertWhen::new(when),
                operations::SecretScanningGetAlertThen::new(then),
            )
        })
    }

    fn secret_scanning_update_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningUpdateAlertWhen,
            operations::SecretScanningUpdateAlertThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningUpdateAlertWhen::new(when),
                operations::SecretScanningUpdateAlertThen::new(then),
            )
        })
    }

    fn secret_scanning_list_locations_for_alert<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecretScanningListLocationsForAlertWhen,
            operations::SecretScanningListLocationsForAlertThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecretScanningListLocationsForAlertWhen::new(when),
                operations::SecretScanningListLocationsForAlertThen::new(then),
            )
        })
    }

    fn security_advisories_list_repository_advisories<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesListRepositoryAdvisoriesWhen,
            operations::SecurityAdvisoriesListRepositoryAdvisoriesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecurityAdvisoriesListRepositoryAdvisoriesWhen::new(when),
                operations::SecurityAdvisoriesListRepositoryAdvisoriesThen::new(then),
            )
        })
    }

    fn security_advisories_create_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesCreateRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesCreateRepositoryAdvisoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecurityAdvisoriesCreateRepositoryAdvisoryWhen::new(when),
                operations::SecurityAdvisoriesCreateRepositoryAdvisoryThen::new(then),
            )
        })
    }

    fn security_advisories_create_private_vulnerability_report<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportWhen,
            operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportWhen::new(when),
                operations::SecurityAdvisoriesCreatePrivateVulnerabilityReportThen::new(then),
            )
        })
    }

    fn security_advisories_get_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesGetRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesGetRepositoryAdvisoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecurityAdvisoriesGetRepositoryAdvisoryWhen::new(when),
                operations::SecurityAdvisoriesGetRepositoryAdvisoryThen::new(then),
            )
        })
    }

    fn security_advisories_update_repository_advisory<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SecurityAdvisoriesUpdateRepositoryAdvisoryWhen,
            operations::SecurityAdvisoriesUpdateRepositoryAdvisoryThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SecurityAdvisoriesUpdateRepositoryAdvisoryWhen::new(when),
                operations::SecurityAdvisoriesUpdateRepositoryAdvisoryThen::new(then),
            )
        })
    }

    fn activity_list_stargazers_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListStargazersForRepoWhen,
            operations::ActivityListStargazersForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListStargazersForRepoWhen::new(when),
                operations::ActivityListStargazersForRepoThen::new(then),
            )
        })
    }

    fn repos_get_code_frequency_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCodeFrequencyStatsWhen,
            operations::ReposGetCodeFrequencyStatsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCodeFrequencyStatsWhen::new(when),
                operations::ReposGetCodeFrequencyStatsThen::new(then),
            )
        })
    }

    fn repos_get_commit_activity_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetCommitActivityStatsWhen,
            operations::ReposGetCommitActivityStatsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetCommitActivityStatsWhen::new(when),
                operations::ReposGetCommitActivityStatsThen::new(then),
            )
        })
    }

    fn repos_get_contributors_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetContributorsStatsWhen,
            operations::ReposGetContributorsStatsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetContributorsStatsWhen::new(when),
                operations::ReposGetContributorsStatsThen::new(then),
            )
        })
    }

    fn repos_get_participation_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposGetParticipationStatsWhen,
            operations::ReposGetParticipationStatsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetParticipationStatsWhen::new(when),
                operations::ReposGetParticipationStatsThen::new(then),
            )
        })
    }

    fn repos_get_punch_card_stats<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetPunchCardStatsWhen, operations::ReposGetPunchCardStatsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetPunchCardStatsWhen::new(when),
                operations::ReposGetPunchCardStatsThen::new(then),
            )
        })
    }

    fn repos_create_commit_status<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposCreateCommitStatusWhen, operations::ReposCreateCommitStatusThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateCommitStatusWhen::new(when),
                operations::ReposCreateCommitStatusThen::new(then),
            )
        })
    }

    fn activity_list_watchers_for_repo<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListWatchersForRepoWhen,
            operations::ActivityListWatchersForRepoThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListWatchersForRepoWhen::new(when),
                operations::ActivityListWatchersForRepoThen::new(then),
            )
        })
    }

    fn activity_get_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityGetRepoSubscriptionWhen,
            operations::ActivityGetRepoSubscriptionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityGetRepoSubscriptionWhen::new(when),
                operations::ActivityGetRepoSubscriptionThen::new(then),
            )
        })
    }

    fn activity_set_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivitySetRepoSubscriptionWhen,
            operations::ActivitySetRepoSubscriptionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivitySetRepoSubscriptionWhen::new(when),
                operations::ActivitySetRepoSubscriptionThen::new(then),
            )
        })
    }

    fn activity_delete_repo_subscription<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityDeleteRepoSubscriptionWhen,
            operations::ActivityDeleteRepoSubscriptionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityDeleteRepoSubscriptionWhen::new(when),
                operations::ActivityDeleteRepoSubscriptionThen::new(then),
            )
        })
    }

    fn repos_list_tags<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTagsWhen, operations::ReposListTagsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListTagsWhen::new(when),
                operations::ReposListTagsThen::new(then),
            )
        })
    }

    fn repos_list_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTagProtectionWhen, operations::ReposListTagProtectionThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListTagProtectionWhen::new(when),
                operations::ReposListTagProtectionThen::new(then),
            )
        })
    }

    fn repos_create_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateTagProtectionWhen,
            operations::ReposCreateTagProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateTagProtectionWhen::new(when),
                operations::ReposCreateTagProtectionThen::new(then),
            )
        })
    }

    fn repos_delete_tag_protection<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeleteTagProtectionWhen,
            operations::ReposDeleteTagProtectionThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeleteTagProtectionWhen::new(when),
                operations::ReposDeleteTagProtectionThen::new(then),
            )
        })
    }

    fn repos_download_tarball_archive<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDownloadTarballArchiveWhen,
            operations::ReposDownloadTarballArchiveThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDownloadTarballArchiveWhen::new(when),
                operations::ReposDownloadTarballArchiveThen::new(then),
            )
        })
    }

    fn repos_list_teams<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListTeamsWhen, operations::ReposListTeamsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListTeamsWhen::new(when),
                operations::ReposListTeamsThen::new(then),
            )
        })
    }

    fn repos_get_all_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetAllTopicsWhen, operations::ReposGetAllTopicsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetAllTopicsWhen::new(when),
                operations::ReposGetAllTopicsThen::new(then),
            )
        })
    }

    fn repos_replace_all_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposReplaceAllTopicsWhen, operations::ReposReplaceAllTopicsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposReplaceAllTopicsWhen::new(when),
                operations::ReposReplaceAllTopicsThen::new(then),
            )
        })
    }

    fn repos_get_clones<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetClonesWhen, operations::ReposGetClonesThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetClonesWhen::new(when),
                operations::ReposGetClonesThen::new(then),
            )
        })
    }

    fn repos_get_top_paths<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetTopPathsWhen, operations::ReposGetTopPathsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetTopPathsWhen::new(when),
                operations::ReposGetTopPathsThen::new(then),
            )
        })
    }

    fn repos_get_top_referrers<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetTopReferrersWhen, operations::ReposGetTopReferrersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetTopReferrersWhen::new(when),
                operations::ReposGetTopReferrersThen::new(then),
            )
        })
    }

    fn repos_get_views<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposGetViewsWhen, operations::ReposGetViewsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposGetViewsWhen::new(when),
                operations::ReposGetViewsThen::new(then),
            )
        })
    }

    fn repos_transfer<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposTransferWhen, operations::ReposTransferThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposTransferWhen::new(when),
                operations::ReposTransferThen::new(then),
            )
        })
    }

    fn repos_check_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCheckVulnerabilityAlertsWhen,
            operations::ReposCheckVulnerabilityAlertsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCheckVulnerabilityAlertsWhen::new(when),
                operations::ReposCheckVulnerabilityAlertsThen::new(then),
            )
        })
    }

    fn repos_enable_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposEnableVulnerabilityAlertsWhen,
            operations::ReposEnableVulnerabilityAlertsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposEnableVulnerabilityAlertsWhen::new(when),
                operations::ReposEnableVulnerabilityAlertsThen::new(then),
            )
        })
    }

    fn repos_disable_vulnerability_alerts<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDisableVulnerabilityAlertsWhen,
            operations::ReposDisableVulnerabilityAlertsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDisableVulnerabilityAlertsWhen::new(when),
                operations::ReposDisableVulnerabilityAlertsThen::new(then),
            )
        })
    }

    fn repos_download_zipball_archive<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDownloadZipballArchiveWhen,
            operations::ReposDownloadZipballArchiveThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDownloadZipballArchiveWhen::new(when),
                operations::ReposDownloadZipballArchiveThen::new(then),
            )
        })
    }

    fn repos_create_using_template<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateUsingTemplateWhen,
            operations::ReposCreateUsingTemplateThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateUsingTemplateWhen::new(when),
                operations::ReposCreateUsingTemplateThen::new(then),
            )
        })
    }

    fn repos_list_public<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListPublicWhen, operations::ReposListPublicThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListPublicWhen::new(when),
                operations::ReposListPublicThen::new(then),
            )
        })
    }

    fn actions_list_environment_secrets<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListEnvironmentSecretsWhen,
            operations::ActionsListEnvironmentSecretsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListEnvironmentSecretsWhen::new(when),
                operations::ActionsListEnvironmentSecretsThen::new(then),
            )
        })
    }

    fn actions_get_environment_public_key<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentPublicKeyWhen,
            operations::ActionsGetEnvironmentPublicKeyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetEnvironmentPublicKeyWhen::new(when),
                operations::ActionsGetEnvironmentPublicKeyThen::new(then),
            )
        })
    }

    fn actions_get_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentSecretWhen,
            operations::ActionsGetEnvironmentSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetEnvironmentSecretWhen::new(when),
                operations::ActionsGetEnvironmentSecretThen::new(then),
            )
        })
    }

    fn actions_create_or_update_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateOrUpdateEnvironmentSecretWhen,
            operations::ActionsCreateOrUpdateEnvironmentSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateOrUpdateEnvironmentSecretWhen::new(when),
                operations::ActionsCreateOrUpdateEnvironmentSecretThen::new(then),
            )
        })
    }

    fn actions_delete_environment_secret<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteEnvironmentSecretWhen,
            operations::ActionsDeleteEnvironmentSecretThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteEnvironmentSecretWhen::new(when),
                operations::ActionsDeleteEnvironmentSecretThen::new(then),
            )
        })
    }

    fn actions_list_environment_variables<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsListEnvironmentVariablesWhen,
            operations::ActionsListEnvironmentVariablesThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsListEnvironmentVariablesWhen::new(when),
                operations::ActionsListEnvironmentVariablesThen::new(then),
            )
        })
    }

    fn actions_create_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsCreateEnvironmentVariableWhen,
            operations::ActionsCreateEnvironmentVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsCreateEnvironmentVariableWhen::new(when),
                operations::ActionsCreateEnvironmentVariableThen::new(then),
            )
        })
    }

    fn actions_get_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsGetEnvironmentVariableWhen,
            operations::ActionsGetEnvironmentVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsGetEnvironmentVariableWhen::new(when),
                operations::ActionsGetEnvironmentVariableThen::new(then),
            )
        })
    }

    fn actions_delete_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsDeleteEnvironmentVariableWhen,
            operations::ActionsDeleteEnvironmentVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsDeleteEnvironmentVariableWhen::new(when),
                operations::ActionsDeleteEnvironmentVariableThen::new(then),
            )
        })
    }

    fn actions_update_environment_variable<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActionsUpdateEnvironmentVariableWhen,
            operations::ActionsUpdateEnvironmentVariableThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActionsUpdateEnvironmentVariableWhen::new(when),
                operations::ActionsUpdateEnvironmentVariableThen::new(then),
            )
        })
    }

    fn search_code<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchCodeWhen, operations::SearchCodeThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchCodeWhen::new(when),
                operations::SearchCodeThen::new(then),
            )
        })
    }

    fn search_commits<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchCommitsWhen, operations::SearchCommitsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchCommitsWhen::new(when),
                operations::SearchCommitsThen::new(then),
            )
        })
    }

    fn search_issues_and_pull_requests<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::SearchIssuesAndPullRequestsWhen,
            operations::SearchIssuesAndPullRequestsThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchIssuesAndPullRequestsWhen::new(when),
                operations::SearchIssuesAndPullRequestsThen::new(then),
            )
        })
    }

    fn search_labels<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchLabelsWhen, operations::SearchLabelsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchLabelsWhen::new(when),
                operations::SearchLabelsThen::new(then),
            )
        })
    }

    fn search_repos<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchReposWhen, operations::SearchReposThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchReposWhen::new(when),
                operations::SearchReposThen::new(then),
            )
        })
    }

    fn search_topics<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchTopicsWhen, operations::SearchTopicsThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchTopicsWhen::new(when),
                operations::SearchTopicsThen::new(then),
            )
        })
    }

    fn search_users<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::SearchUsersWhen, operations::SearchUsersThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::SearchUsersWhen::new(when),
                operations::SearchUsersThen::new(then),
            )
        })
    }

    fn teams_get_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetLegacyWhen, operations::TeamsGetLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetLegacyWhen::new(when),
                operations::TeamsGetLegacyThen::new(then),
            )
        })
    }

    fn teams_delete_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsDeleteLegacyWhen, operations::TeamsDeleteLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteLegacyWhen::new(when),
                operations::TeamsDeleteLegacyThen::new(then),
            )
        })
    }

    fn teams_update_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsUpdateLegacyWhen, operations::TeamsUpdateLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateLegacyWhen::new(when),
                operations::TeamsUpdateLegacyThen::new(then),
            )
        })
    }

    fn teams_list_discussions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionsLegacyWhen,
            operations::TeamsListDiscussionsLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListDiscussionsLegacyWhen::new(when),
                operations::TeamsListDiscussionsLegacyThen::new(then),
            )
        })
    }

    fn teams_create_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionLegacyWhen,
            operations::TeamsCreateDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCreateDiscussionLegacyWhen::new(when),
                operations::TeamsCreateDiscussionLegacyThen::new(then),
            )
        })
    }

    fn teams_get_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionLegacyWhen,
            operations::TeamsGetDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetDiscussionLegacyWhen::new(when),
                operations::TeamsGetDiscussionLegacyThen::new(then),
            )
        })
    }

    fn teams_delete_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionLegacyWhen,
            operations::TeamsDeleteDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteDiscussionLegacyWhen::new(when),
                operations::TeamsDeleteDiscussionLegacyThen::new(then),
            )
        })
    }

    fn teams_update_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionLegacyWhen,
            operations::TeamsUpdateDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateDiscussionLegacyWhen::new(when),
                operations::TeamsUpdateDiscussionLegacyThen::new(then),
            )
        })
    }

    fn teams_list_discussion_comments_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListDiscussionCommentsLegacyWhen,
            operations::TeamsListDiscussionCommentsLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListDiscussionCommentsLegacyWhen::new(when),
                operations::TeamsListDiscussionCommentsLegacyThen::new(then),
            )
        })
    }

    fn teams_create_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCreateDiscussionCommentLegacyWhen,
            operations::TeamsCreateDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCreateDiscussionCommentLegacyWhen::new(when),
                operations::TeamsCreateDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn teams_get_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetDiscussionCommentLegacyWhen,
            operations::TeamsGetDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetDiscussionCommentLegacyWhen::new(when),
                operations::TeamsGetDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn teams_delete_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsDeleteDiscussionCommentLegacyWhen,
            operations::TeamsDeleteDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsDeleteDiscussionCommentLegacyWhen::new(when),
                operations::TeamsDeleteDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn teams_update_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsUpdateDiscussionCommentLegacyWhen,
            operations::TeamsUpdateDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsUpdateDiscussionCommentLegacyWhen::new(when),
                operations::TeamsUpdateDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn reactions_list_for_team_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionCommentLegacyWhen,
            operations::ReactionsListForTeamDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForTeamDiscussionCommentLegacyWhen::new(when),
                operations::ReactionsListForTeamDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn reactions_create_for_team_discussion_comment_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionCommentLegacyWhen,
            operations::ReactionsCreateForTeamDiscussionCommentLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForTeamDiscussionCommentLegacyWhen::new(when),
                operations::ReactionsCreateForTeamDiscussionCommentLegacyThen::new(then),
            )
        })
    }

    fn reactions_list_for_team_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsListForTeamDiscussionLegacyWhen,
            operations::ReactionsListForTeamDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsListForTeamDiscussionLegacyWhen::new(when),
                operations::ReactionsListForTeamDiscussionLegacyThen::new(then),
            )
        })
    }

    fn reactions_create_for_team_discussion_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReactionsCreateForTeamDiscussionLegacyWhen,
            operations::ReactionsCreateForTeamDiscussionLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReactionsCreateForTeamDiscussionLegacyWhen::new(when),
                operations::ReactionsCreateForTeamDiscussionLegacyThen::new(then),
            )
        })
    }

    fn teams_list_pending_invitations_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListPendingInvitationsLegacyWhen,
            operations::TeamsListPendingInvitationsLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListPendingInvitationsLegacyWhen::new(when),
                operations::TeamsListPendingInvitationsLegacyThen::new(then),
            )
        })
    }

    fn teams_list_members_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListMembersLegacyWhen, operations::TeamsListMembersLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListMembersLegacyWhen::new(when),
                operations::TeamsListMembersLegacyThen::new(then),
            )
        })
    }

    fn teams_get_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsGetMemberLegacyWhen, operations::TeamsGetMemberLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetMemberLegacyWhen::new(when),
                operations::TeamsGetMemberLegacyThen::new(then),
            )
        })
    }

    fn teams_add_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsAddMemberLegacyWhen, operations::TeamsAddMemberLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddMemberLegacyWhen::new(when),
                operations::TeamsAddMemberLegacyThen::new(then),
            )
        })
    }

    fn teams_remove_member_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveMemberLegacyWhen, operations::TeamsRemoveMemberLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveMemberLegacyWhen::new(when),
                operations::TeamsRemoveMemberLegacyThen::new(then),
            )
        })
    }

    fn teams_get_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsGetMembershipForUserLegacyWhen,
            operations::TeamsGetMembershipForUserLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsGetMembershipForUserLegacyWhen::new(when),
                operations::TeamsGetMembershipForUserLegacyThen::new(then),
            )
        })
    }

    fn teams_add_or_update_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateMembershipForUserLegacyWhen,
            operations::TeamsAddOrUpdateMembershipForUserLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateMembershipForUserLegacyWhen::new(when),
                operations::TeamsAddOrUpdateMembershipForUserLegacyThen::new(then),
            )
        })
    }

    fn teams_remove_membership_for_user_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveMembershipForUserLegacyWhen,
            operations::TeamsRemoveMembershipForUserLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveMembershipForUserLegacyWhen::new(when),
                operations::TeamsRemoveMembershipForUserLegacyThen::new(then),
            )
        })
    }

    fn teams_list_projects_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListProjectsLegacyWhen, operations::TeamsListProjectsLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListProjectsLegacyWhen::new(when),
                operations::TeamsListProjectsLegacyThen::new(then),
            )
        })
    }

    fn teams_check_permissions_for_project_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForProjectLegacyWhen,
            operations::TeamsCheckPermissionsForProjectLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCheckPermissionsForProjectLegacyWhen::new(when),
                operations::TeamsCheckPermissionsForProjectLegacyThen::new(then),
            )
        })
    }

    fn teams_add_or_update_project_permissions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateProjectPermissionsLegacyWhen,
            operations::TeamsAddOrUpdateProjectPermissionsLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateProjectPermissionsLegacyWhen::new(when),
                operations::TeamsAddOrUpdateProjectPermissionsLegacyThen::new(then),
            )
        })
    }

    fn teams_remove_project_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsRemoveProjectLegacyWhen,
            operations::TeamsRemoveProjectLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveProjectLegacyWhen::new(when),
                operations::TeamsRemoveProjectLegacyThen::new(then),
            )
        })
    }

    fn teams_list_repos_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListReposLegacyWhen, operations::TeamsListReposLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListReposLegacyWhen::new(when),
                operations::TeamsListReposLegacyThen::new(then),
            )
        })
    }

    fn teams_check_permissions_for_repo_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsCheckPermissionsForRepoLegacyWhen,
            operations::TeamsCheckPermissionsForRepoLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsCheckPermissionsForRepoLegacyWhen::new(when),
                operations::TeamsCheckPermissionsForRepoLegacyThen::new(then),
            )
        })
    }

    fn teams_add_or_update_repo_permissions_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsAddOrUpdateRepoPermissionsLegacyWhen,
            operations::TeamsAddOrUpdateRepoPermissionsLegacyThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsAddOrUpdateRepoPermissionsLegacyWhen::new(when),
                operations::TeamsAddOrUpdateRepoPermissionsLegacyThen::new(then),
            )
        })
    }

    fn teams_remove_repo_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsRemoveRepoLegacyWhen, operations::TeamsRemoveRepoLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsRemoveRepoLegacyWhen::new(when),
                operations::TeamsRemoveRepoLegacyThen::new(then),
            )
        })
    }

    fn teams_list_child_legacy<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::TeamsListChildLegacyWhen, operations::TeamsListChildLegacyThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListChildLegacyWhen::new(when),
                operations::TeamsListChildLegacyThen::new(then),
            )
        })
    }

    fn users_get_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetAuthenticatedWhen, operations::UsersGetAuthenticatedThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetAuthenticatedWhen::new(when),
                operations::UsersGetAuthenticatedThen::new(then),
            )
        })
    }

    fn users_update_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersUpdateAuthenticatedWhen,
            operations::UsersUpdateAuthenticatedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersUpdateAuthenticatedWhen::new(when),
                operations::UsersUpdateAuthenticatedThen::new(then),
            )
        })
    }

    fn users_list_blocked_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListBlockedByAuthenticatedUserWhen,
            operations::UsersListBlockedByAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListBlockedByAuthenticatedUserWhen::new(when),
                operations::UsersListBlockedByAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_check_blocked<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersCheckBlockedWhen, operations::UsersCheckBlockedThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCheckBlockedWhen::new(when),
                operations::UsersCheckBlockedThen::new(then),
            )
        })
    }

    fn users_block<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersBlockWhen, operations::UsersBlockThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersBlockWhen::new(when),
                operations::UsersBlockThen::new(then),
            )
        })
    }

    fn users_unblock<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersUnblockWhen, operations::UsersUnblockThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersUnblockWhen::new(when),
                operations::UsersUnblockThen::new(then),
            )
        })
    }

    fn codespaces_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListForAuthenticatedUserWhen,
            operations::CodespacesListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListForAuthenticatedUserWhen::new(when),
                operations::CodespacesListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateForAuthenticatedUserWhen,
            operations::CodespacesCreateForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateForAuthenticatedUserWhen::new(when),
                operations::CodespacesCreateForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_list_secrets_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListSecretsForAuthenticatedUserWhen,
            operations::CodespacesListSecretsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListSecretsForAuthenticatedUserWhen::new(when),
                operations::CodespacesListSecretsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_get_public_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetPublicKeyForAuthenticatedUserWhen,
            operations::CodespacesGetPublicKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetPublicKeyForAuthenticatedUserWhen::new(when),
                operations::CodespacesGetPublicKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_get_secret_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetSecretForAuthenticatedUserWhen,
            operations::CodespacesGetSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesGetSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_create_or_update_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserWhen,
            operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesCreateOrUpdateSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_delete_secret_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteSecretForAuthenticatedUserWhen,
            operations::CodespacesDeleteSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesDeleteSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_list_repositories_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesListRepositoriesForSecretForAuthenticatedUserWhen,
            operations::CodespacesListRepositoriesForSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesListRepositoriesForSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesListRepositoriesForSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_set_repositories_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserWhen,
            operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesSetRepositoriesForSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_add_repository_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesAddRepositoryForSecretForAuthenticatedUserWhen,
            operations::CodespacesAddRepositoryForSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesAddRepositoryForSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesAddRepositoryForSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_remove_repository_for_secret_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserWhen,
            operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserWhen::new(when),
                operations::CodespacesRemoveRepositoryForSecretForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_get_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetForAuthenticatedUserWhen,
            operations::CodespacesGetForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetForAuthenticatedUserWhen::new(when),
                operations::CodespacesGetForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_delete_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesDeleteForAuthenticatedUserWhen,
            operations::CodespacesDeleteForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesDeleteForAuthenticatedUserWhen::new(when),
                operations::CodespacesDeleteForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_update_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesUpdateForAuthenticatedUserWhen,
            operations::CodespacesUpdateForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesUpdateForAuthenticatedUserWhen::new(when),
                operations::CodespacesUpdateForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_export_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesExportForAuthenticatedUserWhen,
            operations::CodespacesExportForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesExportForAuthenticatedUserWhen::new(when),
                operations::CodespacesExportForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_get_export_details_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesGetExportDetailsForAuthenticatedUserWhen,
            operations::CodespacesGetExportDetailsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesGetExportDetailsForAuthenticatedUserWhen::new(when),
                operations::CodespacesGetExportDetailsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_codespace_machines_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesCodespaceMachinesForAuthenticatedUserWhen,
            operations::CodespacesCodespaceMachinesForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesCodespaceMachinesForAuthenticatedUserWhen::new(when),
                operations::CodespacesCodespaceMachinesForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_publish_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesPublishForAuthenticatedUserWhen,
            operations::CodespacesPublishForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesPublishForAuthenticatedUserWhen::new(when),
                operations::CodespacesPublishForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_start_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStartForAuthenticatedUserWhen,
            operations::CodespacesStartForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesStartForAuthenticatedUserWhen::new(when),
                operations::CodespacesStartForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn codespaces_stop_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::CodespacesStopForAuthenticatedUserWhen,
            operations::CodespacesStopForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::CodespacesStopForAuthenticatedUserWhen::new(when),
                operations::CodespacesStopForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_list_docker_migration_conflicting_packages_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserThen,
        ),
    {
        self . mock (| when , then | { config_fn (operations :: PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserWhen :: new (when) , operations :: PackagesListDockerMigrationConflictingPackagesForAuthenticatedUserThen :: new (then) ,) })
    }

    fn users_set_primary_email_visibility_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserWhen,
            operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserWhen::new(when),
                operations::UsersSetPrimaryEmailVisibilityForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_emails_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListEmailsForAuthenticatedUserWhen,
            operations::UsersListEmailsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListEmailsForAuthenticatedUserWhen::new(when),
                operations::UsersListEmailsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_add_email_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersAddEmailForAuthenticatedUserWhen,
            operations::UsersAddEmailForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersAddEmailForAuthenticatedUserWhen::new(when),
                operations::UsersAddEmailForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_delete_email_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteEmailForAuthenticatedUserWhen,
            operations::UsersDeleteEmailForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersDeleteEmailForAuthenticatedUserWhen::new(when),
                operations::UsersDeleteEmailForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_followers_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowersForAuthenticatedUserWhen,
            operations::UsersListFollowersForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListFollowersForAuthenticatedUserWhen::new(when),
                operations::UsersListFollowersForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_followed_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowedByAuthenticatedUserWhen,
            operations::UsersListFollowedByAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListFollowedByAuthenticatedUserWhen::new(when),
                operations::UsersListFollowedByAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_check_person_is_followed_by_authenticated<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCheckPersonIsFollowedByAuthenticatedWhen,
            operations::UsersCheckPersonIsFollowedByAuthenticatedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCheckPersonIsFollowedByAuthenticatedWhen::new(when),
                operations::UsersCheckPersonIsFollowedByAuthenticatedThen::new(then),
            )
        })
    }

    fn users_follow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersFollowWhen, operations::UsersFollowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersFollowWhen::new(when),
                operations::UsersFollowThen::new(then),
            )
        })
    }

    fn users_unfollow<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersUnfollowWhen, operations::UsersUnfollowThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersUnfollowWhen::new(when),
                operations::UsersUnfollowThen::new(then),
            )
        })
    }

    fn users_list_gpg_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListGpgKeysForAuthenticatedUserWhen,
            operations::UsersListGpgKeysForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListGpgKeysForAuthenticatedUserWhen::new(when),
                operations::UsersListGpgKeysForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_create_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreateGpgKeyForAuthenticatedUserWhen,
            operations::UsersCreateGpgKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCreateGpgKeyForAuthenticatedUserWhen::new(when),
                operations::UsersCreateGpgKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_get_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetGpgKeyForAuthenticatedUserWhen,
            operations::UsersGetGpgKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetGpgKeyForAuthenticatedUserWhen::new(when),
                operations::UsersGetGpgKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_delete_gpg_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteGpgKeyForAuthenticatedUserWhen,
            operations::UsersDeleteGpgKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersDeleteGpgKeyForAuthenticatedUserWhen::new(when),
                operations::UsersDeleteGpgKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_list_installations_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationsForAuthenticatedUserWhen,
            operations::AppsListInstallationsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListInstallationsForAuthenticatedUserWhen::new(when),
                operations::AppsListInstallationsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_list_installation_repos_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListInstallationReposForAuthenticatedUserWhen,
            operations::AppsListInstallationReposForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListInstallationReposForAuthenticatedUserWhen::new(when),
                operations::AppsListInstallationReposForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_add_repo_to_installation_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsAddRepoToInstallationForAuthenticatedUserWhen,
            operations::AppsAddRepoToInstallationForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsAddRepoToInstallationForAuthenticatedUserWhen::new(when),
                operations::AppsAddRepoToInstallationForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_remove_repo_from_installation_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsRemoveRepoFromInstallationForAuthenticatedUserWhen,
            operations::AppsRemoveRepoFromInstallationForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsRemoveRepoFromInstallationForAuthenticatedUserWhen::new(when),
                operations::AppsRemoveRepoFromInstallationForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn interactions_get_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsGetRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsGetRestrictionsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsGetRestrictionsForAuthenticatedUserWhen::new(when),
                operations::InteractionsGetRestrictionsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn interactions_set_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsSetRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsSetRestrictionsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsSetRestrictionsForAuthenticatedUserWhen::new(when),
                operations::InteractionsSetRestrictionsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn interactions_remove_restrictions_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::InteractionsRemoveRestrictionsForAuthenticatedUserWhen,
            operations::InteractionsRemoveRestrictionsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::InteractionsRemoveRestrictionsForAuthenticatedUserWhen::new(when),
                operations::InteractionsRemoveRestrictionsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn issues_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::IssuesListForAuthenticatedUserWhen,
            operations::IssuesListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::IssuesListForAuthenticatedUserWhen::new(when),
                operations::IssuesListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_public_ssh_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicSshKeysForAuthenticatedUserWhen,
            operations::UsersListPublicSshKeysForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListPublicSshKeysForAuthenticatedUserWhen::new(when),
                operations::UsersListPublicSshKeysForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_create_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreatePublicSshKeyForAuthenticatedUserWhen,
            operations::UsersCreatePublicSshKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCreatePublicSshKeyForAuthenticatedUserWhen::new(when),
                operations::UsersCreatePublicSshKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_get_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetPublicSshKeyForAuthenticatedUserWhen,
            operations::UsersGetPublicSshKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetPublicSshKeyForAuthenticatedUserWhen::new(when),
                operations::UsersGetPublicSshKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_delete_public_ssh_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeletePublicSshKeyForAuthenticatedUserWhen,
            operations::UsersDeletePublicSshKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersDeletePublicSshKeyForAuthenticatedUserWhen::new(when),
                operations::UsersDeletePublicSshKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_list_subscriptions_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListSubscriptionsForAuthenticatedUserWhen,
            operations::AppsListSubscriptionsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListSubscriptionsForAuthenticatedUserWhen::new(when),
                operations::AppsListSubscriptionsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn apps_list_subscriptions_for_authenticated_user_stubbed<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::AppsListSubscriptionsForAuthenticatedUserStubbedWhen,
            operations::AppsListSubscriptionsForAuthenticatedUserStubbedThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsListSubscriptionsForAuthenticatedUserStubbedWhen::new(when),
                operations::AppsListSubscriptionsForAuthenticatedUserStubbedThen::new(then),
            )
        })
    }

    fn orgs_list_memberships_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListMembershipsForAuthenticatedUserWhen,
            operations::OrgsListMembershipsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListMembershipsForAuthenticatedUserWhen::new(when),
                operations::OrgsListMembershipsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn orgs_get_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsGetMembershipForAuthenticatedUserWhen,
            operations::OrgsGetMembershipForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsGetMembershipForAuthenticatedUserWhen::new(when),
                operations::OrgsGetMembershipForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn orgs_update_membership_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsUpdateMembershipForAuthenticatedUserWhen,
            operations::OrgsUpdateMembershipForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsUpdateMembershipForAuthenticatedUserWhen::new(when),
                operations::OrgsUpdateMembershipForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListForAuthenticatedUserWhen,
            operations::MigrationsListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsListForAuthenticatedUserWhen::new(when),
                operations::MigrationsListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_start_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsStartForAuthenticatedUserWhen,
            operations::MigrationsStartForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsStartForAuthenticatedUserWhen::new(when),
                operations::MigrationsStartForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_get_status_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetStatusForAuthenticatedUserWhen,
            operations::MigrationsGetStatusForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetStatusForAuthenticatedUserWhen::new(when),
                operations::MigrationsGetStatusForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_get_archive_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsGetArchiveForAuthenticatedUserWhen,
            operations::MigrationsGetArchiveForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsGetArchiveForAuthenticatedUserWhen::new(when),
                operations::MigrationsGetArchiveForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_delete_archive_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsDeleteArchiveForAuthenticatedUserWhen,
            operations::MigrationsDeleteArchiveForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsDeleteArchiveForAuthenticatedUserWhen::new(when),
                operations::MigrationsDeleteArchiveForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_unlock_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsUnlockRepoForAuthenticatedUserWhen,
            operations::MigrationsUnlockRepoForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsUnlockRepoForAuthenticatedUserWhen::new(when),
                operations::MigrationsUnlockRepoForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn migrations_list_repos_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::MigrationsListReposForAuthenticatedUserWhen,
            operations::MigrationsListReposForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::MigrationsListReposForAuthenticatedUserWhen::new(when),
                operations::MigrationsListReposForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn orgs_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::OrgsListForAuthenticatedUserWhen,
            operations::OrgsListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListForAuthenticatedUserWhen::new(when),
                operations::OrgsListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_list_packages_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForAuthenticatedUserWhen,
            operations::PackagesListPackagesForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesListPackagesForAuthenticatedUserWhen::new(when),
                operations::PackagesListPackagesForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_get_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForAuthenticatedUserWhen,
            operations::PackagesGetPackageForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageForAuthenticatedUserWhen::new(when),
                operations::PackagesGetPackageForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_delete_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForAuthenticatedUserWhen,
            operations::PackagesDeletePackageForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageForAuthenticatedUserWhen::new(when),
                operations::PackagesDeletePackageForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_restore_package_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForAuthenticatedUserWhen,
            operations::PackagesRestorePackageForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageForAuthenticatedUserWhen::new(when),
                operations::PackagesRestorePackageForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_get_all_package_versions_for_package_owned_by_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserThen,
        ),
    {
        self . mock (| when , then | { config_fn (operations :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserWhen :: new (when) , operations :: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserThen :: new (then) ,) })
    }

    fn packages_get_package_version_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForAuthenticatedUserWhen,
            operations::PackagesGetPackageVersionForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageVersionForAuthenticatedUserWhen::new(when),
                operations::PackagesGetPackageVersionForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_delete_package_version_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForAuthenticatedUserWhen,
            operations::PackagesDeletePackageVersionForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageVersionForAuthenticatedUserWhen::new(when),
                operations::PackagesDeletePackageVersionForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn packages_restore_package_version_for_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForAuthenticatedUserWhen,
            operations::PackagesRestorePackageVersionForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageVersionForAuthenticatedUserWhen::new(when),
                operations::PackagesRestorePackageVersionForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn projects_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ProjectsCreateForAuthenticatedUserWhen,
            operations::ProjectsCreateForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsCreateForAuthenticatedUserWhen::new(when),
                operations::ProjectsCreateForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_public_emails_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicEmailsForAuthenticatedUserWhen,
            operations::UsersListPublicEmailsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListPublicEmailsForAuthenticatedUserWhen::new(when),
                operations::UsersListPublicEmailsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListForAuthenticatedUserWhen,
            operations::ReposListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListForAuthenticatedUserWhen::new(when),
                operations::ReposListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_create_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposCreateForAuthenticatedUserWhen,
            operations::ReposCreateForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposCreateForAuthenticatedUserWhen::new(when),
                operations::ReposCreateForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_list_invitations_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposListInvitationsForAuthenticatedUserWhen,
            operations::ReposListInvitationsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListInvitationsForAuthenticatedUserWhen::new(when),
                operations::ReposListInvitationsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_decline_invitation_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposDeclineInvitationForAuthenticatedUserWhen,
            operations::ReposDeclineInvitationForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposDeclineInvitationForAuthenticatedUserWhen::new(when),
                operations::ReposDeclineInvitationForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn repos_accept_invitation_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ReposAcceptInvitationForAuthenticatedUserWhen,
            operations::ReposAcceptInvitationForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposAcceptInvitationForAuthenticatedUserWhen::new(when),
                operations::ReposAcceptInvitationForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_social_accounts_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSocialAccountsForAuthenticatedUserWhen,
            operations::UsersListSocialAccountsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListSocialAccountsForAuthenticatedUserWhen::new(when),
                operations::UsersListSocialAccountsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_add_social_account_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersAddSocialAccountForAuthenticatedUserWhen,
            operations::UsersAddSocialAccountForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersAddSocialAccountForAuthenticatedUserWhen::new(when),
                operations::UsersAddSocialAccountForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_delete_social_account_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteSocialAccountForAuthenticatedUserWhen,
            operations::UsersDeleteSocialAccountForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersDeleteSocialAccountForAuthenticatedUserWhen::new(when),
                operations::UsersDeleteSocialAccountForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list_ssh_signing_keys_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSshSigningKeysForAuthenticatedUserWhen,
            operations::UsersListSshSigningKeysForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListSshSigningKeysForAuthenticatedUserWhen::new(when),
                operations::UsersListSshSigningKeysForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_create_ssh_signing_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCreateSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersCreateSshSigningKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCreateSshSigningKeyForAuthenticatedUserWhen::new(when),
                operations::UsersCreateSshSigningKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_get_ssh_signing_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersGetSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersGetSshSigningKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetSshSigningKeyForAuthenticatedUserWhen::new(when),
                operations::UsersGetSshSigningKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_delete_ssh_signing_key_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersDeleteSshSigningKeyForAuthenticatedUserWhen,
            operations::UsersDeleteSshSigningKeyForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersDeleteSshSigningKeyForAuthenticatedUserWhen::new(when),
                operations::UsersDeleteSshSigningKeyForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_list_repos_starred_by_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReposStarredByAuthenticatedUserWhen,
            operations::ActivityListReposStarredByAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListReposStarredByAuthenticatedUserWhen::new(when),
                operations::ActivityListReposStarredByAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_check_repo_is_starred_by_authenticated_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityCheckRepoIsStarredByAuthenticatedUserWhen,
            operations::ActivityCheckRepoIsStarredByAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityCheckRepoIsStarredByAuthenticatedUserWhen::new(when),
                operations::ActivityCheckRepoIsStarredByAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_star_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityStarRepoForAuthenticatedUserWhen,
            operations::ActivityStarRepoForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityStarRepoForAuthenticatedUserWhen::new(when),
                operations::ActivityStarRepoForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_unstar_repo_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityUnstarRepoForAuthenticatedUserWhen,
            operations::ActivityUnstarRepoForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityUnstarRepoForAuthenticatedUserWhen::new(when),
                operations::ActivityUnstarRepoForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_list_watched_repos_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListWatchedReposForAuthenticatedUserWhen,
            operations::ActivityListWatchedReposForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListWatchedReposForAuthenticatedUserWhen::new(when),
                operations::ActivityListWatchedReposForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn teams_list_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::TeamsListForAuthenticatedUserWhen,
            operations::TeamsListForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::TeamsListForAuthenticatedUserWhen::new(when),
                operations::TeamsListForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn users_list<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersListWhen, operations::UsersListThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListWhen::new(when),
                operations::UsersListThen::new(then),
            )
        })
    }

    fn users_get_by_username<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetByUsernameWhen, operations::UsersGetByUsernameThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetByUsernameWhen::new(when),
                operations::UsersGetByUsernameThen::new(then),
            )
        })
    }

    fn packages_list_docker_migration_conflicting_packages_for_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListDockerMigrationConflictingPackagesForUserWhen,
            operations::PackagesListDockerMigrationConflictingPackagesForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesListDockerMigrationConflictingPackagesForUserWhen::new(when),
                operations::PackagesListDockerMigrationConflictingPackagesForUserThen::new(then),
            )
        })
    }

    fn activity_list_events_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListEventsForAuthenticatedUserWhen,
            operations::ActivityListEventsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListEventsForAuthenticatedUserWhen::new(when),
                operations::ActivityListEventsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_list_org_events_for_authenticated_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListOrgEventsForAuthenticatedUserWhen,
            operations::ActivityListOrgEventsForAuthenticatedUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListOrgEventsForAuthenticatedUserWhen::new(when),
                operations::ActivityListOrgEventsForAuthenticatedUserThen::new(then),
            )
        })
    }

    fn activity_list_public_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListPublicEventsForUserWhen,
            operations::ActivityListPublicEventsForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListPublicEventsForUserWhen::new(when),
                operations::ActivityListPublicEventsForUserThen::new(then),
            )
        })
    }

    fn users_list_followers_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowersForUserWhen,
            operations::UsersListFollowersForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListFollowersForUserWhen::new(when),
                operations::UsersListFollowersForUserThen::new(then),
            )
        })
    }

    fn users_list_following_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListFollowingForUserWhen,
            operations::UsersListFollowingForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListFollowingForUserWhen::new(when),
                operations::UsersListFollowingForUserThen::new(then),
            )
        })
    }

    fn users_check_following_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersCheckFollowingForUserWhen,
            operations::UsersCheckFollowingForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersCheckFollowingForUserWhen::new(when),
                operations::UsersCheckFollowingForUserThen::new(then),
            )
        })
    }

    fn gists_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::GistsListForUserWhen, operations::GistsListForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::GistsListForUserWhen::new(when),
                operations::GistsListForUserThen::new(then),
            )
        })
    }

    fn users_list_gpg_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersListGpgKeysForUserWhen, operations::UsersListGpgKeysForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListGpgKeysForUserWhen::new(when),
                operations::UsersListGpgKeysForUserThen::new(then),
            )
        })
    }

    fn users_get_context_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::UsersGetContextForUserWhen, operations::UsersGetContextForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersGetContextForUserWhen::new(when),
                operations::UsersGetContextForUserThen::new(then),
            )
        })
    }

    fn apps_get_user_installation<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::AppsGetUserInstallationWhen, operations::AppsGetUserInstallationThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::AppsGetUserInstallationWhen::new(when),
                operations::AppsGetUserInstallationThen::new(then),
            )
        })
    }

    fn users_list_public_keys_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListPublicKeysForUserWhen,
            operations::UsersListPublicKeysForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListPublicKeysForUserWhen::new(when),
                operations::UsersListPublicKeysForUserThen::new(then),
            )
        })
    }

    fn orgs_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::OrgsListForUserWhen, operations::OrgsListForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::OrgsListForUserWhen::new(when),
                operations::OrgsListForUserThen::new(then),
            )
        })
    }

    fn packages_list_packages_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesListPackagesForUserWhen,
            operations::PackagesListPackagesForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesListPackagesForUserWhen::new(when),
                operations::PackagesListPackagesForUserThen::new(then),
            )
        })
    }

    fn packages_get_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageForUserWhen,
            operations::PackagesGetPackageForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageForUserWhen::new(when),
                operations::PackagesGetPackageForUserThen::new(then),
            )
        })
    }

    fn packages_delete_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageForUserWhen,
            operations::PackagesDeletePackageForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageForUserWhen::new(when),
                operations::PackagesDeletePackageForUserThen::new(then),
            )
        })
    }

    fn packages_restore_package_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageForUserWhen,
            operations::PackagesRestorePackageForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageForUserWhen::new(when),
                operations::PackagesRestorePackageForUserThen::new(then),
            )
        })
    }

    fn packages_get_all_package_versions_for_package_owned_by_user<F>(
        &self,
        config_fn: F,
    ) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetAllPackageVersionsForPackageOwnedByUserWhen,
            operations::PackagesGetAllPackageVersionsForPackageOwnedByUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetAllPackageVersionsForPackageOwnedByUserWhen::new(when),
                operations::PackagesGetAllPackageVersionsForPackageOwnedByUserThen::new(then),
            )
        })
    }

    fn packages_get_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesGetPackageVersionForUserWhen,
            operations::PackagesGetPackageVersionForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesGetPackageVersionForUserWhen::new(when),
                operations::PackagesGetPackageVersionForUserThen::new(then),
            )
        })
    }

    fn packages_delete_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesDeletePackageVersionForUserWhen,
            operations::PackagesDeletePackageVersionForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesDeletePackageVersionForUserWhen::new(when),
                operations::PackagesDeletePackageVersionForUserThen::new(then),
            )
        })
    }

    fn packages_restore_package_version_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::PackagesRestorePackageVersionForUserWhen,
            operations::PackagesRestorePackageVersionForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::PackagesRestorePackageVersionForUserWhen::new(when),
                operations::PackagesRestorePackageVersionForUserThen::new(then),
            )
        })
    }

    fn projects_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ProjectsListForUserWhen, operations::ProjectsListForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ProjectsListForUserWhen::new(when),
                operations::ProjectsListForUserThen::new(then),
            )
        })
    }

    fn activity_list_received_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReceivedEventsForUserWhen,
            operations::ActivityListReceivedEventsForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListReceivedEventsForUserWhen::new(when),
                operations::ActivityListReceivedEventsForUserThen::new(then),
            )
        })
    }

    fn activity_list_received_public_events_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::ActivityListReceivedPublicEventsForUserWhen,
            operations::ActivityListReceivedPublicEventsForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ActivityListReceivedPublicEventsForUserWhen::new(when),
                operations::ActivityListReceivedPublicEventsForUserThen::new(then),
            )
        })
    }

    fn repos_list_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(operations::ReposListForUserWhen, operations::ReposListForUserThen),
    {
        self.mock(|when, then| {
            config_fn(
                operations::ReposListForUserWhen::new(when),
                operations::ReposListForUserThen::new(then),
            )
        })
    }

    fn billing_get_github_actions_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubActionsBillingUserWhen,
            operations::BillingGetGithubActionsBillingUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetGithubActionsBillingUserWhen::new(when),
                operations::BillingGetGithubActionsBillingUserThen::new(then),
            )
        })
    }

    fn billing_get_github_packages_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetGithubPackagesBillingUserWhen,
            operations::BillingGetGithubPackagesBillingUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetGithubPackagesBillingUserWhen::new(when),
                operations::BillingGetGithubPackagesBillingUserThen::new(then),
            )
        })
    }

    fn billing_get_shared_storage_billing_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::BillingGetSharedStorageBillingUserWhen,
            operations::BillingGetSharedStorageBillingUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::BillingGetSharedStorageBillingUserWhen::new(when),
                operations::BillingGetSharedStorageBillingUserThen::new(then),
            )
        })
    }

    fn users_list_social_accounts_for_user<F>(&self, config_fn: F) -> httpmock::Mock
    where
        F: FnOnce(
            operations::UsersListSocialAccountsForUserWhen,
            operations::UsersListSocialAccountsForUserThen,
        ),
    {
        self.mock(|when, then| {
            config_fn(
                operations::UsersListSocialAccountsForUserWhen::new(when),
                operations::UsersListSocialAccountsForUserThen::new(then),
            )
        })
    }
}
